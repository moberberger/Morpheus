<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MorpheusStandard</name>
    </assembly>
    <members>
        <member name="T:Morpheus.CHelper">
            <summary>
            This class contains "helper" methods for varying things.
            </summary>
        </member>
        <member name="F:Morpheus.CHelper.NumberFindingRegex">
            <summary>
            This is a very commonly used REGEX that simply identifies numbers of any length. It
            will not recognize a number with commas in it as a single number. For example,
            "1,234" will be recognized as two numbers- "1" and "234".
            </summary>
        </member>
        <member name="M:Morpheus.CHelper.IsValidEnum(System.Enum)">
            <summary>
            Connect this method (as an Extension) to the Enum class to determine if the "Value"
            of the enumeration is a "valid" value given the enumeration. Unlike
            <see cref="M:System.Enum.IsDefined(System.Type,System.Object)"/> , this will return TRUE if the Enum is a bitmask that
            contains only "valid" bits.
            </summary>
            <param name="_this"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CHelper.GetFirstNumberInString(System.String)">
            <summary>
            A bit more flexible than <see cref="M:System.Int32.Parse(System.String)"/> , this routine will find
            the first integer in the string and turn that into an integer.
            </summary>
            <param name="_stringWithNumber">A string with an integer embedded in it.</param>
            <returns>The first number found in the string as an integer</returns>
        </member>
        <member name="M:Morpheus.CHelper.ConvertArrayToString(System.Array)">
            <summary>
            Convert an array of values, each assumed to be ".ToString"'able, into a
            comma-separated list of values, represented as a string.
            </summary>
            <param name="_array">The array to convert</param>
            <returns>A string representing the comma-separated list of values.</returns>
        </member>
        <member name="M:Morpheus.CHelper.ConvertStringToArray(System.String,System.Type)">
            <summary>
            Convert a string containing a comma-separated list of values into an array of values
            of the type specified
            </summary>
            <param name="_string">The comma-separated list</param>
            <param name="_arrayType">The type of each element in the array to return.</param>
            <returns>An Array object containing the values retrieved from the CSList</returns>
        </member>
        <member name="M:Morpheus.CHelper.ConvertStringToArray``1(System.String,System.Char)">
            <summary>
            Convert a string containing a comma-separated list of values into an array of values
            of the type specified
            </summary>
            <typeparam name="T">
            The Type that each element in the separated-list-string
            </typeparam>
            <param name="_string">The comma-separated list</param>
            <param name="_separator">
            The Separator used to distinguish individual elements in the list
            </param>
            <returns>The array created from the elements in the list.</returns>
        </member>
        <member name="M:Morpheus.CHelper.ParseNextSegment(System.String,System.Char,System.Int32@,System.Int32@)">
            <summary>
            Use this method successively to extract individual strings that have been separated
            by some "separator" character. The first call should pass -1 in for _index.
            </summary>
            <remarks>
            This method is 8%-10% faster than using String.Split . It is written to minimize
            overheads from arrays, enumerators, etc. An alternate method was written that used
            "yield", but that was found to be SLOWER than String.Split . As such, if performance
            is truly an issue, this method is available, but it is clunky to use and
            String.Split should be used in general circumstances.
            </remarks>
            <example>
            <code>
            string sentence = "Take thy beak from out my heart, and take thy form from off my door";
            string token;
            int len = 0, idx = -1;
            do
            {
                token = CHelper.ParseNextSegment( sentence, ' ', ref idx, ref len );
                if (token != null)
                {
                    // The token is usable in this block
                }
            } while (token != null);
            </code>
            </example>
            <param name="_string">The string that is being parsed</param>
            <param name="_index">
            The "current index"- The index in the string where the current substring starts.
            Must pass in -1 to initialize the routine.
            </param>
            <param name="_length">The Length of the current substring</param>
            <param name="_separator">
            The separator used to separate substrings from each other
            </param>
            <returns>The "next" substring, or NULL if there are no more substrings</returns>
        </member>
        <member name="M:Morpheus.CHelper.AppendElementToArray``1(``0[]@,``0)">
            <summary>
            Given a "simple" array and a new object to add to the array, increase the simple
            array's length by 1 and set the last element in the new array to the "new" object.
            This involves a new allocation and copy operation for the array, so this should be
            used only as a non-performant convenience method.
            </summary>
            <typeparam name="TElementType">The Type of the array</typeparam>
            <param name="_array">
            The array itself which is to be lengthened and have the item added
            </param>
            <param name="_newObject">
            The object to add to the end of the lengthened array
            </param>
        </member>
        <member name="M:Morpheus.CHelper.Compress(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Compress one byte array into another
            </summary>
            <param name="_bytes">The array to compress</param>
            <param name="_offset">
            The offset into the array from where to start compressing
            </param>
            <param name="_length">The number of bytes, starting at _offset, to compress</param>
            <returns>A byte[] containing exactly those compressed bytes</returns>
        </member>
        <member name="M:Morpheus.CHelper.Compress(System.Byte[])">
            <summary>
            Compress a byte array into a new byte array
            </summary>
            <param name="_bytes">The array to compress</param>
            <returns>A byte[] containing exactly those compressed bytes</returns>
        </member>
        <member name="M:Morpheus.CHelper.CompressString(System.String)">
            <summary>
            Helper function that will return a compressed byte[] from a string.
            </summary>
            <param name="_string">The unicode string</param>
            <returns>A byte[] containing the string after its been compressed</returns>
        </member>
        <member name="M:Morpheus.CHelper.Decompress(System.Byte[])">
            <summary>
            Decompress an array of bytes into the "original" byte array
            </summary>
            <param name="_compressedBytes">
            The bytes that have been compressed with a <see cref="T:System.IO.Compression.DeflateStream"/> (GZIP)
            </param>
            <returns>The uncompressed bytes in an array</returns>
        </member>
        <member name="M:Morpheus.CHelper.DecompressString(System.Byte[])">
            <summary>
            Helper function to turn a string that was compressed using "CompressString" back
            into a string
            </summary>
            <param name="_compressedString">
            The bytes resulting from the "CompressSTring" operation
            </param>
            <returns>The original string that had been compressed</returns>
        </member>
        <member name="M:Morpheus.CHelper.TransferStream(System.IO.Stream,System.IO.Stream)">
            <summary>
            Transfer the bytes from one stream to another
            </summary>
            <param name="_source">The stream containing the bytes to transfer</param>
            <param name="_destination">The stream to receive the bytes</param>
            <returns>The actual number of bytes transferred</returns>
        </member>
        <member name="M:Morpheus.CHelper.TransferStream(System.IO.Stream,System.IO.Stream,System.Int32)">
            <summary>
            Transfer the bytes from one stream to another
            </summary>
            <param name="_source">The stream containing the bytes to transfer</param>
            <param name="_destination">The stream to receive the bytes</param>
            <param name="_bufferSize">
            The size of the buffer used as temporary storage as the bytes are transferred
            </param>
            <returns>The actual number of bytes transferred</returns>
        </member>
        <member name="M:Morpheus.CHelper.TransferStream(System.IO.Stream,System.IO.Stream,System.Int32,System.Int32)">
            <summary>
            Transfer the bytes from one stream to another
            </summary>
            <param name="_source">The stream containing the bytes to transfer</param>
            <param name="_destination">The stream to receive the bytes</param>
            <param name="_bufferSize">
            The size of the buffer used as temporary storage as the bytes are transferred
            </param>
            <param name="_count">
            The number of bytes to transfer. If this is -1, all bytes in the source stream will
            be read.
            </param>
            <returns>The actual number of bytes transferred</returns>
        </member>
        <member name="M:Morpheus.CHelper.Swap``1(``0@,``0@)">
            <summary>
            Swap two values
            </summary>
            <typeparam name="T">The Type of the values</typeparam>
            <param name="_first">First Value</param>
            <param name="_second">Second Value</param>
        </member>
        <member name="M:Morpheus.CHelper.AddSomethingToFilename(System.String,System.String)">
            <summary>
            Add some token to a filename between the extension and the name. For example, adding
            "BACKUP" to "T.TXT" yields "T.BACKUP.TXT"
            </summary>
            <param name="_filename">The filename</param>
            <param name="_whatToAdd">
            The token to add to the filename (before the extension)
            </param>
            <returns>The resulting filename</returns>
        </member>
        <member name="M:Morpheus.CHelper.FindByteSubstring(System.Byte[],System.Byte[])">
            <summary>
            Find a byte[] substring within a larger byte[]
            </summary>
            <param name="_source">The array of bytes to search</param>
            <param name="_toFind">The bytes to find within the source byte array</param>
            <returns>
            The index of the "_toFind" array in the source array, or -1 if nothing was found.
            </returns>
        </member>
        <member name="M:Morpheus.CHelper.FindByteSubstring(System.Byte[],System.Byte[],System.Int32)">
            <summary>
            Find a byte[] substring within a larger byte[]. Will never find null arrays or
            zero-length arrays (returns -1)
            </summary>
            <param name="_source">The array of bytes to search</param>
            <param name="_toFind">The bytes to find within the source byte array</param>
            <param name="_startIndex">
            The first index within the source array to start looking
            </param>
            <returns>
            The index of the "_toFind" array in the source array, or -1 if nothing was found.
            </returns>
        </member>
        <member name="M:Morpheus.CHelper.RemoveDuplicateWhitespace(System.String)">
            <summary>
            Convert all whitespace into spaces, and remove duplicates, and remove whitespace
            before and after the string
            </summary>
            <param name="_string">The string to "clean up"</param>
            <returns>A new string with the modifications requested</returns>
        </member>
        <member name="M:Morpheus.CHelper.IsSet(System.String)">
            <summary>
            Return TRUE if the string contains something other than whitespace. NULL strings
            return false.
            </summary>
            <param name="_someString">The string to test</param>
            <returns>TRUE if the string contains any non-whitespace characters</returns>
        </member>
        <member name="M:Morpheus.CHelper.IsNullOrWhitespace(System.String)">
            <summary>
            Return FALSE if the string contains something other than whitespace. NULL strings
            return TRUE.
            </summary>
            <param name="_someString">The string to test</param>
            <returns>FALSE if the string contains any non-whitespace characters</returns>
        </member>
        <member name="M:Morpheus.CHelper.ToBase64(System.Byte[])">
            <summary>
            Convert a byte array to a string that represents the byte array encoded as Base64
            </summary>
            <param name="_array">The bytes that are to be converted into a Base64 string</param>
            <returns>A string representing the Base64 version of the binary data.</returns>
        </member>
        <member name="M:Morpheus.CHelper.FromBase64(System.String)">
            <summary>
            Convert a string into the byte array equivalent
            </summary>
            <param name="_string">
            The string to convert into a byte array. The string must be a Base64 representation.
            </param>
            <returns>
            The byte array containing the original data before it was converted to Base64
            </returns>
        </member>
        <member name="M:Morpheus.CHelper.MakeMetricString(System.Double,System.String)">
            <summary>
            Turn a double into a metric string. At this time, this routine only adds a prefix if
            the value is millis or smaller (down to yocto's for now)
            </summary>
            <param name="_value">
            The value to convert. Should be very small (less than 1 or so) to take advantage of
            this method.
            </param>
            <param name="_units">
            If present, this string shall be appended to the string.
            </param>
            <returns>A string containing the value converted to a metric string</returns>
        </member>
        <member name="T:Morpheus.CLambdaComparer`1">
            <summary>
            This is a "plugin" that allows the application a more expressive method of specifying a
            comparator for two objects.
            </summary>
            <typeparam name="T">The type of the data that is to be compared</typeparam>
        </member>
        <member name="T:Morpheus.CLambdaComparer`1.DLambdaComparer">
            <summary>
            A delegate used by this class as an IComparer
            </summary>
            <param name="_left">The left side of the inequality being tested</param>
            <param name="_right">The right side of the inequality being tested</param>
            <returns>
            NEGATIVE if the left side is LESS THAN the right, POSITIVE if its GREATER THAN, and
            zero if they are EQUAL
            </returns>
        </member>
        <member name="M:Morpheus.CLambdaComparer`1.#ctor(Morpheus.CLambdaComparer{`0}.DLambdaComparer)">
            <summary>
            Construct an IComparer object for use in datasets requiring ordering of elements.
            </summary>
            <param name="_comparer">
            A lambda returning a Negative number if the left is less than the right, 0 if
            they're equal, Positive if the left is greater than the right
            </param>
        </member>
        <member name="M:Morpheus.CLambdaComparer`1.Compare(`0,`0)">
            <summary>
            Implementation of IComparer using the comparer lambda specified in the constructor
            </summary>
            <param name="_left">The "left-hand" parameter for the relationship operator</param>
            <param name="_right">The "right-hand" parameter for the relationship operator</param>
            <returns>
            Negative number if the left is less than the right, 0 if they're equal, Positive if
            the left is greater than the right
            </returns>
        </member>
        <member name="M:Morpheus.CLambdaComparer`1.FromFunc(System.Func{`0,`0,System.Int32})">
            <summary>
            Create a CLambdaComparer based on the system "Func(T,T,int)" delegate
            </summary>
            <param name="_comparer">The lambda to create an IComparer for</param>
            <returns>A new IComparer using the specified "Func(T,T,int) delegate</returns>
        </member>
        <member name="T:Morpheus.CMath">
            <summary>
            A class containing a variety of Math helper functions
            </summary>
        </member>
        <member name="F:Morpheus.CMath.NaturalLogOf2">
            <summary>
            The natural logarithm of 2
            </summary>
        </member>
        <member name="F:Morpheus.CMath.PI">
            <summary>
            PI
            </summary>
        </member>
        <member name="F:Morpheus.CMath.PI_OVER_2">
            <summary>
            PI over 2 (half of PI)
            </summary>
        </member>
        <member name="F:Morpheus.CMath.PI_OVER_4">
            <summary>
            PI over 4
            </summary>
        </member>
        <member name="F:Morpheus.CMath.TWO_PI">
            <summary>
            Two times PI
            </summary>
        </member>
        <member name="F:Morpheus.CMath.PI_FLOAT">
            <summary>
            PI as a float (not a double)
            </summary>
        </member>
        <member name="F:Morpheus.CMath.TWO_PI_FLOAT">
            <summary>
            Two times PI as a float (not a double)
            </summary>
        </member>
        <member name="F:Morpheus.CMath.SquareRootOf2">
            <summary>
            The square root of 2
            </summary>
        </member>
        <member name="M:Morpheus.CMath.SumOfConsecutiveInts(System.Int32)">
            <summary>
            Calculate the sum of all consecutive integers between 0 and some value, inclusive.
            </summary>
            <param name="_int">The last consecutive integer to include in the sum</param>
            <returns>
            The sum of all integers between 0 and <paramref name="_int"/> , inclusive
            </returns>
        </member>
        <member name="M:Morpheus.CMath.InverseSumOfConsecutiveInts(System.Int32)">
            <summary>
            Calculate the largest integer where the <see cref="M:Morpheus.CMath.SumOfConsecutiveInts(System.Int32)"/> is less
            than or equal to some value.
            </summary>
            <param name="_sum">An integer</param>
            <returns>
            The largest integer producing a "SumOfConsecutiveInts" less than or equal to
            <paramref name="_sum"/> .
            </returns>
        </member>
        <member name="M:Morpheus.CMath.Sigmoid(System.Double,System.Double)">
            <summary>
            A sigmoid function that will re-scale values between 0 and 1 to the curve between
            _base and (1 - _base).
            </summary>
            <remarks>
            This calculation takes approx .165 Microseconds on a 2.8GHz Intel processor.
            </remarks>
            <param name="_x">The value to scale</param>
            <param name="_base">
            The return value for an input of 0, or (1-return) for an input of 1
            </param>
            <returns>
            Approaches 0 as _x approaches negative-infinity, and approches 1 as _x approaches
            infinity
            </returns>
        </member>
        <member name="M:Morpheus.CMath.CheapSigmoid(System.Double,System.Double)">
            <summary>
            Given a number between -1 and 1, assumed to be a linear scale, translate the number
            onto an "S" with the degree being the "verticalness" of the middle line of the "S"
            </summary>
            <param name="_number"></param>
            <param name="_degree"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CMath.CheapSigmoidZeroBased(System.Double,System.Double)">
            <summary>
            Given a number between 0 and 1, assumed to be a linear scale, translate the number
            onto an "S" with the degree being the "verticalness" of the middle line of the "S"
            </summary>
            <param name="_number"></param>
            <param name="_degree"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CMath.Clamp(System.Double,System.Double,System.Double)">
            <summary>
            Return a number that's guaranteed to be greater than min, but less than max, and
            equal to "this" number if its in this range.
            </summary>
            <param name="_value">The value to test</param>
            <param name="_min">If the number is less than this value, return this value</param>
            <param name="_max">
            If the number is greater than this value, return this value
            </param>
            <returns>A number "clamped" between two numbers</returns>
        </member>
        <member name="M:Morpheus.CMath.Clamp(System.Single,System.Single,System.Single)">
            <summary>
            Return a number that's guaranteed to be greater than min, but less than max, and
            equal to "this" number if its in this range.
            </summary>
            <param name="_value">The value to test</param>
            <param name="_min">If the number is less than this value, return this value</param>
            <param name="_max">
            If the number is greater than this value, return this value
            </param>
            <returns>A number "clamped" between two numbers</returns>
        </member>
        <member name="M:Morpheus.CMath.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary>
            Return a number that's guaranteed to be greater than or equal to min, but less than
            or equal to max, and equal to "this" number if its in this range.
            </summary>
            <param name="_value">The value to test</param>
            <param name="_min">If the number is less than this value, return this value</param>
            <param name="_max">
            If the number is greater than this value, return this value
            </param>
            <returns>A number "clamped" between two numbers</returns>
        </member>
        <member name="M:Morpheus.CMath.Order(System.Double@,System.Double@)">
            <summary>
            Order two numbers- Swap them if they are not in ascending order.
            </summary>
            <param name="_1">The first number, you want this to be smaller</param>
            <param name="_2">The second number, you want this to be larger</param>
        </member>
        <member name="M:Morpheus.CMath.Order(System.Single@,System.Single@)">
            <summary>
            Order two numbers- Swap them if they are not in ascending order.
            </summary>
            <param name="_1">The first number, you want this to be smaller</param>
            <param name="_2">The second number, you want this to be larger</param>
        </member>
        <member name="M:Morpheus.CMath.Order(System.Byte@,System.Byte@)">
            <summary>
            Order two numbers- Swap them if they are not in ascending order.
            </summary>
            <param name="_1">The first number, you want this to be smaller</param>
            <param name="_2">The second number, you want this to be larger</param>
        </member>
        <member name="M:Morpheus.CMath.Order(System.Int16@,System.Int16@)">
            <summary>
            Order two numbers- Swap them if they are not in ascending order.
            </summary>
            <param name="_1">The first number, you want this to be smaller</param>
            <param name="_2">The second number, you want this to be larger</param>
        </member>
        <member name="M:Morpheus.CMath.Order(System.Int32@,System.Int32@)">
            <summary>
            Order two numbers- Swap them if they are not in ascending order.
            </summary>
            <param name="_1">The first number, you want this to be smaller</param>
            <param name="_2">The second number, you want this to be larger</param>
        </member>
        <member name="M:Morpheus.CMath.Order(System.Int64@,System.Int64@)">
            <summary>
            Order two numbers- Swap them if they are not in ascending order.
            </summary>
            <param name="_1">The first number, you want this to be smaller</param>
            <param name="_2">The second number, you want this to be larger</param>
        </member>
        <member name="M:Morpheus.CMath.IsBetween(System.Double,System.Double,System.Double)">
            <summary>
            Determine if a value is "between" two other values- If the value EQUALS either
            value, it IS considered "between" them. The parameters can be in either order.
            </summary>
            <param name="_value">The value to test</param>
            <param name="_1">The first value to check against</param>
            <param name="_2">The second value to check against</param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CMath.IsBetween(System.Single,System.Single,System.Single)">
            <summary>
            Determine if a value is "between" two other values- If the value EQUALS either
            value, it IS considered "between" them. The parameters can be in either order.
            </summary>
            <param name="_value">The value to test</param>
            <param name="_1">The first value to check against</param>
            <param name="_2">The second value to check against</param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CMath.IsBetween(System.Byte,System.Byte,System.Byte)">
            <summary>
            Determine if a value is "between" two other values- If the value EQUALS either
            value, it IS considered "between" them. The parameters can be in either order.
            </summary>
            <param name="_value">The value to test</param>
            <param name="_1">The first value to check against</param>
            <param name="_2">The second value to check against</param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CMath.IsBetween(System.Int32,System.Int32,System.Int32)">
            <summary>
            Determine if a value is "between" two other values- If the value EQUALS either
            value, it IS considered "between" them. The parameters can be in either order.
            </summary>
            <param name="_value">The value to test</param>
            <param name="_1">The first value to check against</param>
            <param name="_2">The second value to check against</param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CMath.IsBetween(System.Int64,System.Int64,System.Int64)">
            <summary>
            Determine if a value is "between" two other values- If the value EQUALS either
            value, it IS considered "between" them. The parameters can be in either order.
            </summary>
            <param name="_value">The value to test</param>
            <param name="_1">The first value to check against</param>
            <param name="_2">The second value to check against</param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CMath.IsClose(System.Double,System.Double,System.Double)">
            <summary>
            Returns TRUE if two values are "close", as defined by one hundredth of one percent
            of the smaller of the two values
            </summary>
            <param name="_this">One of the values to test</param>
            <param name="_other">One of the values to test</param>
            <param name="_tolerance">
            How close the two values should be in order to be considered "Close"
            </param>
            <returns>TRUE if the two values are close to each other</returns>
        </member>
        <member name="M:Morpheus.CMath.IsClose(System.Single,System.Single)">
            <summary>
            Returns TRUE if two values are "close", as defined by one hundredth of one percent
            of the smaller of the two values
            </summary>
            <param name="_this">One of the values to test</param>
            <param name="_other">One of the values to test</param>
            <returns>TRUE if the two values are close to each other</returns>
        </member>
        <member name="M:Morpheus.CMath.FixAngle(System.Double)">
            <summary>
            Make sure an angle, in radians, fits between ( -PI .. PI ]
            </summary>
            <param name="_radians">
            The angle to "fix" if its outside the range ( -PI .. PI ]
            </param>
            <returns>The angle, adjusted if necessary to fit within ( -PI .. PI ]</returns>
        </member>
        <member name="M:Morpheus.CMath.FixAngle(System.Single)">
            <summary>
            Make sure an angle, in radians, fits between ( -PI .. PI ]
            </summary>
            <param name="_radians">
            The angle to "fix" if its outside the range ( -PI .. PI ]
            </param>
            <returns>The angle, adjusted if necessary to fit within ( -PI .. PI ]</returns>
        </member>
        <member name="M:Morpheus.CMath.Lerp(System.Single,System.Single,System.Single)">
            <summary>
            Linear Interpolation between two values- Lerp amount 0 returns _1, Lerp amount 1 =
            _2
            </summary>
            <param name="_1">The first point, corresponding to Lerp Amount == 0</param>
            <param name="_2">The second point, corresponding to Lerp Amount == 1</param>
            <param name="_lerpAmount">The position, relative to _1 and _2</param>
            <returns>
            A value linearly interpolated between _1 and _2 based on _lerpAmount
            </returns>
        </member>
        <member name="M:Morpheus.CMath.Lerp(System.Double,System.Double,System.Double)">
            <summary>
            Linear Interpolation between two values- Lerp amount 0 returns _1, Lerp amount 1 =
            _2
            </summary>
            <param name="_1">The first point, corresponding to Lerp Amount == 0</param>
            <param name="_2">The second point, corresponding to Lerp Amount == 1</param>
            <param name="_lerpAmount">The position, relative to _1 and _2</param>
            <returns>
            A value linearly interpolated between _1 and _2 based on _lerpAmount
            </returns>
        </member>
        <member name="M:Morpheus.CMath.QuadraticSolver(System.Double,System.Double,System.Double,System.Double@,System.Double@)">
            <summary>
            Solve a quadratic equation in the form ax^2 + bx + c = 0
            </summary>
            <param name="_a">Coefficient for x^2</param>
            <param name="_b">Coefficient for x</param>
            <param name="_c">Constant</param>
            <param name="_solution1">The first solution</param>
            <param name="_solution2">The second solution</param>
            <returns>TRUE if a solution exists, FALSE if one does not</returns>
        </member>
        <member name="M:Morpheus.CMath.Log2Int(System.Int32)">
            <summary>
            This is a speed-optimized calculator of the integral value of the "log2" (logarithm
            base 2) of an Int32
            </summary>
            <param name="_number">The number to calculate the Log2 of</param>
            <returns>The integer part of the Log2 of _number</returns>
        </member>
        <member name="M:Morpheus.CMath.GCD(System.Int32,System.Int32)">
            <summary>
            Return the greatest common divisor of two integers.
            </summary>
            <param name="_x">One of the integers</param>
            <param name="_y">Another of the integers</param>
            <returns>The GCD of the two integers</returns>
        </member>
        <member name="M:Morpheus.CMath.GCD(System.Int64,System.Int64)">
            <summary>
            Return the greatest common divisor of two integers.
            </summary>
            <param name="_x">One of the integers</param>
            <param name="_y">Another of the integers</param>
            <returns>The GCD of the two integers</returns>
        </member>
        <member name="M:Morpheus.CMath.LCM(System.Int64[])">
            <summary>
            Return the least common multiple of an array of integers. Can be used as a variadic
            function.
            </summary>
            <param name="_numbers">
            A set of numbers, either as an array or a parameter list
            </param>
            <returns>The LCM of the integers</returns>
        </member>
        <member name="M:Morpheus.CMath.DifferenceAsRatioOf(System.Double,System.Double)">
            <summary>
            Return the difference between this value and some target value, represented as a
            fraction of the target value.
            </summary>
            <param name="_val"></param>
            <param name="_target"></param>
            <returns></returns>
        </member>
        <member name="T:Morpheus.CShutdownEvent">
            <summary>
            This class describes a generic "shutdown event".
            </summary>
            <remarks>
            It uses a standard <see cref="T:System.Threading.ManualResetEvent"/> along with a <see cref="T:System.Boolean"/> value to provide "shutdown" information and functionality
            </remarks>
        </member>
        <member name="M:Morpheus.CShutdownEvent.Shutdown">
            <summary>
            Signal the application to shut down.
            </summary>
        </member>
        <member name="P:Morpheus.CShutdownEvent.IsShutdown">
            <summary>
            Check to see if the application has been shut down.
            </summary>
        </member>
        <member name="M:Morpheus.CShutdownEvent.WaitForShutdown(System.Int32)">
            <summary>
            Block the thread, waiting on the shutdown to occur.
            </summary>
            <returns>
            TRUE if there was a SHUTDOWN, FALSE if there was a TIMEOUT
            </returns>
        </member>
        <member name="M:Morpheus.CShutdownEvent.op_Implicit(Morpheus.CShutdownEvent)~System.Threading.WaitHandle">
            <summary>
            Allow an object of this type to be passed into a "WaitOne" or "WaitAny" call.
            </summary>
            <param name="_object">The CShutdownEvent object</param>
            <returns>The "WaitHandle" part of the ManualResetEvent field of the object</returns>
        </member>
        <member name="M:Morpheus.CShutdownEvent.op_Implicit(Morpheus.CShutdownEvent)~System.Threading.ManualResetEvent">
            <summary>
            Allow an object of this type to be passed into a "WaitOne" or "WaitAny" call.
            </summary>
            <param name="_object">The CShutdownEvent object</param>
            <returns>The "WaitHandle" part of the ManualResetEvent field of the object</returns>
        </member>
        <member name="T:Morpheus.CXmlHelper">
            <summary>
            A helper to do various simple operations on XML documents Elements
            </summary>
        </member>
        <member name="M:Morpheus.CXmlHelper.AddAttribute(System.Xml.XmlNode,System.String,System.Object)">
            <summary>
            Helper function to add an attribute, including the name and value, to an Xml node
            </summary>
            <param name="_node">The node that is receiving the attribute</param>
            <param name="_name">The name of the attribute</param>
            <param name="_value">The value of the attribute, which will be turned into a string with ".ToString"</param>
        </member>
        <member name="M:Morpheus.CXmlHelper.AddAttribute(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Helper function to add an attribute, including the name and value, to an Xml node
            </summary>
            <param name="_node">The node that is receiving the attribute</param>
            <param name="_name">The name of the attribute</param>
            <param name="_value">The value of the attribute, which will be turned into a string with ".ToString"</param>
        </member>
        <member name="M:Morpheus.CXmlHelper.GetAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Get the value of the named attribute. Return NULL if that name doesn't exist in the attributes.
            </summary>
            <param name="_node">The node (presumably an XmlElement) that contains the attribute whose value is interesting to the application</param>
            <param name="_name">The name of the attribute</param>
            <returns>The value of the attribute whose name is passed in, or NULL if that attribute does not exist on the node</returns>
        </member>
        <member name="M:Morpheus.CXmlHelper.GetRequiredAttribute(System.Xml.XmlNode,System.String)">
            <summary>
            Get the value of the named attribute. Return NULL if that name doesn't exist in the attributes.
            </summary>
            <param name="_node">The node (presumably an XmlElement) that contains the attribute whose value is interesting to the application</param>
            <param name="_name">The name of the attribute</param>
            <returns>The value of the attribute whose name is passed in, or NULL if that attribute does not exist on the node</returns>
        </member>
        <member name="M:Morpheus.CXmlHelper.HasAttribute(System.Xml.XmlNode,System.String)">
            <summary>
            Determine if a named attribute is found in an element's attribute list.
            </summary>
            <param name="_node">The node to search for the attribute</param>
            <param name="_name">The name of the attribute to try to find</param>
            <returns>TRUE if an attribute exists with the name specified</returns>
        </member>
        <member name="M:Morpheus.CXmlHelper.CreateElement(System.Xml.XmlNode,System.String)">
            <summary>
            Given any Xml node, create a new Element node using the document that owns the passed in node.
            </summary>
            <param name="_anyNode">Any node in the document, or the document itself</param>
            <param name="_name">The name of the element to be created.</param>
            <returns>A newly created XmlElement with the nodename of <paramref name="_name"/>.</returns>
        </member>
        <member name="M:Morpheus.CXmlHelper.CreateSimpleElement(System.Xml.XmlNode,System.String,System.Object)">
            <summary>
            Given any Xml node, create a new Element node using the document that owns the passed in node. Add "InnerText" to the element
            </summary>
            <param name="_parent">Any node in the document, or the document itself.</param>
            <param name="_name">The name of the element to be created.</param>
            <param name="_innerTextObject">An object whose ".ToString()" value will be used to create the "InnerText" of the element</param>
            <returns>A newly created XmlElement with the nodename of <paramref name="_name"/>.</returns>
        </member>
        <member name="M:Morpheus.CXmlHelper.AddElement(System.Xml.XmlNode,System.String)">
            <summary>
            Add an element to a parent node, naming the element in the process
            </summary>
            <param name="_parentNode">The parent node to contain the new element</param>
            <param name="_elementName">The name of the new element</param>
            <returns>The element that was added</returns>
        </member>
        <member name="M:Morpheus.CXmlHelper.AddElement(System.Xml.XmlNode,System.String,System.Object)">
            <summary>
            Add an element to a parent node, naming the element in the process
            </summary>
            <param name="_parentNode">The parent node to contain the new element</param>
            <param name="_elementName">The name of the new element</param>
            <param name="_elementValue">The object whose .ToString value will be inserted into the new element</param>
            <returns>The element that was added</returns>
        </member>
        <member name="M:Morpheus.CXmlHelper.AddElementWithAttribute(System.Xml.XmlNode,System.String,System.String,System.Object)">
            <summary>
            Add a new element with a specific name to the parent node, along with a single attribute on that element which has a value
            </summary>
            <param name="_parentNode">The parent XmlElement to receive the new element</param>
            <param name="_elementName">The name of the new element</param>
            <param name="_attributeName">The name of the attribute</param>
            <param name="_attributeValue">The value for the attribute</param>
            <returns>The element that was created</returns>
        </member>
        <member name="M:Morpheus.CXmlHelper.GetElementValue(System.Xml.XmlNode,System.String)">
            <summary>
            Given a node, presumably an XmlElement, find a child node whose name is specified and return the ".InnerText" of that node
            </summary>
            <param name="_root">The "parent node" to search</param>
            <param name="_nodeName">The name of the child-node to find</param>
            <returns>The "innerText" of the child-node if its found, otherwise NULL</returns>
        </member>
        <member name="M:Morpheus.CXmlHelper.GetRequiredElement(System.Xml.XmlNode,System.String)">
            <summary>
            Given a node, presumably an XmlElement, find a child node whose name is specified and return the ".InnerText" of that node
            </summary>
            <param name="_root">The "parent node" to search</param>
            <param name="_nodeName">The name of the child-node to find</param>
            <returns>The "innerText" of the child-node if its found, otherwise NULL</returns>
        </member>
        <member name="M:Morpheus.CXmlHelper.RemoveAttribute(System.Xml.XmlNode,System.String)">
            <summary>
            Remove an attribute from a node.
            </summary>
            <param name="_node">The node that supposedly contains the attribute</param>
            <param name="_attributeName">The name of the attribute to remove</param>
            <returns>TRUE if the attribute was removed, FALSE if it was not (or didn't exist)</returns>
        </member>
        <member name="M:Morpheus.CXmlHelper.GetFormattedString(System.Xml.XmlDocument)">
            <summary>
            Return a formatted string from an XmlDocument
            </summary>
            <param name="_document">The document to get the string for</param>
            <returns>The formatted XML for the document</returns>
        </member>
        <member name="M:Morpheus.CXmlHelper.Depth(System.Xml.XmlNode)">
            <summary>
            Find the "Depth" of an XmlNode.
            </summary>
            <param name="_node">The node to analyze</param>
            <returns>the "Depth" of the document- XmlText IS considered for depth.</returns>
        </member>
        <member name="M:Morpheus.CXmlHelper.ElementCount(System.Xml.XmlNode)">
            <summary>
            Count the number of XmlElements in the document.
            </summary>
            <param name="_node">The node to analyze</param>
            <returns>The number of XmlElements found in the document</returns>
        </member>
        <member name="M:Morpheus.CXmlHelper.ForceValidName(System.String)">
            <summary>
            This routine will try to turn a string into one that can be used as an element or attribute name by replacing invalid characters with "_"
            This is a destructive operation that will leave the length of the string unchanged, but it will not preserve any information about what the
            original character was.
            </summary>
            <param name="_name"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CXmlHelper.EncodeString(System.String)">
            <summary>
            This will convert a variable into a value that is usable as an XML element name. Unlike similar routines (XmlConvert.EncodeName,
            SecurityElement.Escape), this routine is useful when trying to turn a .NET variable/field/property name into an XmlElement name.
            
            It assumes that, since the period (.) is an operator and not a part of a member name, the period is a better escape char
            than the underscore (_) used by XmlConvert.EncodeName. Also, since the escape chars used by SecurityElement.Escape are not
            valid XML element name characters, they can't be used either.
            
            For now, only angle brackets and the period is "escaped". This is because auto-generated backing fields for Properties use 
            angle brackets in their names, and dots (periods) are not part of a valid field name.
            </summary>
            <remarks>
            A better choice altogether would be the use of the dash (-) as an escape character, as it cannot possibly ever be used in a
            .NET identifier. However, the XML specification prevents the dash from being the first token in an XmlElement name. Therefore,
            and since a major reason for the creation of this routine is to represent .NET reflected Fields as XML elements, and since
            auto-generated property backing fields take the form of <![CDATA[    <PropertyName>k__backingField    ]]>, there would 
            almost always need to be an escape character as the first character in a string.
            
            http://www.w3.org/TR/2006/REC-xml-20060816/#NT-Names
            
            </remarks>
            <param name="_name">The string needing escape chars to be used as an XmlElement name</param>
            <returns>A string with escape chars inserted</returns>
        </member>
        <member name="M:Morpheus.CXmlHelper.DecodeString(System.String)">
            <summary>
            Given a string encoded using <see cref="M:Morpheus.CXmlHelper.EncodeString(System.String)"/>, decode the string into its original form
            </summary>
            <param name="_name">The string to decode, presumed to be used as the name of an XML element</param>
            <returns>The decoded string, presumably derived from an XML element</returns>
        </member>
        <member name="T:Morpheus.CClosestObjects`1">
            <summary>
            This class was designed as an optimization for the KDTree. It is meant to optimally keep a list (or
            maybe a single) of "closest objects" based on a Distance value.
            
            It is meant to be used as an "accumulator", where every visited node is "added", but only retained
            by this class if it meets the criteria set up by the "mode" of the object and the parameter for that
            mode.
            </summary>
            <remarks>
            This class operates in three "modes". Were the design based on the best OO principles, there would be
            three separate classes, one for each mode. However, the design is focused on SPEED OF EXECUTION, so 
            the implementation of an interface would prevent any inlining of functionality. This is especially
            undesirable for the "FindNearest(1)" trivial case.
            </remarks>
        </member>
        <member name="T:Morpheus.CClosestObjects`1.CNodeDistance">
            <summary>
            A simple object that encapsulates a distance and an object, used for the <see cref="F:Morpheus.CClosestObjects`1.EClosestMode.ClosestCount"/>
            mode of the CClosestObjects class
            </summary>
        </member>
        <member name="F:Morpheus.CClosestObjects`1.EClosestMode.ClosestSingle">
            <summary>
            The object is meant to track only the single closest object. Most trivial case.
            </summary>
        </member>
        <member name="F:Morpheus.CClosestObjects`1.EClosestMode.ClosestCount">
            <summary>
            The object is meant to track the N closest objects. The most complex case.
            </summary>
        </member>
        <member name="F:Morpheus.CClosestObjects`1.EClosestMode.CloserThan">
            <summary>
            The object is meant to track all objects closer than some distance D
            </summary>
        </member>
        <member name="F:Morpheus.CClosestObjects`1.m_distance">
            <summary>
            For <see cref="F:Morpheus.CClosestObjects`1.EClosestMode.ClosestSingle"/>, this value denotes the smallest distance seen,
            associated with the m_bestObject field.
            
            For <see cref="F:Morpheus.CClosestObjects`1.EClosestMode.CloserThan"/>, this field contains the max distance to retain nodes.
            
            For <see cref="F:Morpheus.CClosestObjects`1.EClosestMode.ClosestCount"/>, this field has no semantic value.
            </summary>
            <remarks>
            This is overloaded to minimize the size of this object, to help with L1-3 cache hits.
            </remarks>
        </member>
        <member name="F:Morpheus.CClosestObjects`1.m_maxCount">
            <summary>
            The maximum number of objects to keep track of. This is only useful for the
            <see cref="F:Morpheus.CClosestObjects`1.EClosestMode.ClosestCount"/> mode.
            </summary>
        </member>
        <member name="F:Morpheus.CClosestObjects`1.m_bestObject">
            <summary>
            For <see cref="F:Morpheus.CClosestObjects`1.EClosestMode.ClosestSingle"/>, this value references the object with the best
            (shortest) distance seen so far
            </summary>
        </member>
        <member name="F:Morpheus.CClosestObjects`1.m_closeObjects">
            <summary>
            The list of all objects that are closer than the parameter specified. Used ONLY for mode 
            <see cref="F:Morpheus.CClosestObjects`1.EClosestMode.CloserThan"/>
            </summary>
        </member>
        <member name="F:Morpheus.CClosestObjects`1.m_bestObjectsSoFar">
            <summary>
            The set of the N closest objects seen so far. Used ONLY for mode <see cref="F:Morpheus.CClosestObjects`1.EClosestMode.ClosestCount"/>
            </summary>
        </member>
        <member name="M:Morpheus.CClosestObjects`1.#ctor">
            <summary>
            Constructor specifying how to set up the closest objects collection for <see cref="F:Morpheus.CClosestObjects`1.EClosestMode.ClosestSingle"/>.
            The collection will only maintain knowledge of the closest single node seen so far
            </summary>
        </member>
        <member name="M:Morpheus.CClosestObjects`1.#ctor(System.Int32)">
            <summary>
            Constructor specifying how to set up the closest objects collection for <see cref="F:Morpheus.CClosestObjects`1.EClosestMode.ClosestCount"/>.
            The collection will only maintain knowledge of the closest _closestCount objects seen so far.
            </summary>
        </member>
        <member name="M:Morpheus.CClosestObjects`1.#ctor(System.Double)">
            <summary>
            Constructor specifying how to set up the closest objects collection for <see cref="F:Morpheus.CClosestObjects`1.EClosestMode.CloserThan"/>.
            The collection will only maintain knowledge of all added objects that are closer than this value.
            </summary>
        </member>
        <member name="M:Morpheus.CClosestObjects`1.Add(`0,System.Double)">
            <summary>
            Accumulate an item (with its distance value) into this collection. This method determines the "mode" of the
            collection. 
            </summary>
            <param name="_item">The item to add</param>
            <param name="_distance">The item's distance to use for "close" comparison</param>
            <returns>The "worst distance so far", used to compare against cross-axis values</returns>
        </member>
        <member name="M:Morpheus.CClosestObjects`1.GetClosestSingle">
            <summary>
            Return the closest single object. If the "CloserThan" mode was chosen, then the first object found that
            met the closeness measurement will be returned, which may NOT be the closest.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CClosestObjects`1.GetClosestObjects">
            <summary>
            Get the objects in this collection. Does the right thing based on the "mode" of this collection.
            </summary>
            <returns>An enumeration of objects in this collection</returns>
        </member>
        <member name="T:Morpheus.CInterceptCalculator2d">
            <summary>
            A class that determines how to make one object intercept a second moving object
            </summary>
            <remarks>
            To use this class, set the four input properties ChaserPosition, ChaserSpeed,
            RunnerPosition and RunnerVelocity.
            
            Then, simply "get" the properties InterceptionPoint, ChaserVelocity,
            TimeToInterception and InterceptionPossible.
            </remarks>
        </member>
        <member name="P:Morpheus.CInterceptCalculator2d.ChaserPosition">
            <summary>
            SET: The location of the chaser
            </summary>
        </member>
        <member name="P:Morpheus.CInterceptCalculator2d.ChaserSpeed">
            <summary>
            SET: How fast the chaser can move in "some" direction, tbd by this class
            </summary>
        </member>
        <member name="P:Morpheus.CInterceptCalculator2d.RunnerPosition">
            <summary>
            SET: The postion of the Runner
            </summary>
        </member>
        <member name="P:Morpheus.CInterceptCalculator2d.RunnerVelocity">
            <summary>
            SET: The velocity vector (Speed and Direction) of the Runner
            </summary>
        </member>
        <member name="P:Morpheus.CInterceptCalculator2d.InterceptionPoint">
            <summary>
            GET: The point where interception will occur, if it is possible
            </summary>
        </member>
        <member name="P:Morpheus.CInterceptCalculator2d.ChaserVelocity">
            <summary>
            The Velocity of the chaser
            </summary>
        </member>
        <member name="P:Morpheus.CInterceptCalculator2d.TimeToInterception">
            <summary>
            The time when interception will occur
            </summary>
        </member>
        <member name="P:Morpheus.CInterceptCalculator2d.InterceptionPossible">
            <summary>
            TRUE if interception is possible, FALSE if not
            </summary>
        </member>
        <member name="M:Morpheus.CInterceptCalculator2d.ClearResults">
            <summary>
            Force re-compute of the interception when any output variables are queried
            </summary>
        </member>
        <member name="P:Morpheus.CInterceptCalculator2d.HasValidInputs">
            <summary>
            TRUE if all inputs are valid, FALSE if not. All inputs must be valid in order
            for any of the outputs to be valid.
            </summary>
        </member>
        <member name="M:Morpheus.CInterceptCalculator2d.SetResults">
            <summary>
            Internal- Calculate the interception
            </summary>
        </member>
        <member name="T:Morpheus.CKDTree`1">
            <summary>
            A K-D Tree
            </summary>
            <typeparam name="T">
            The Type of the objects stored in this KD tree. Must be a "Class". Must be able to
            identify at least one "double" value as a dimensional coordinate.
            </typeparam>
            <remarks>
            The KD Tree does allow duplicate elements. When looking for the nearest element, if
            there are multiple duplicate elements that are "nearest", there is no guarantee
            which of the duplicates will be returned.
            </remarks>
        </member>
        <member name="F:Morpheus.CKDTree`1.m_selector">
            <summary>
            The Selector- Given an object of type T and an Axis, return the coordinate
            </summary>
        </member>
        <member name="F:Morpheus.CKDTree`1.m_distanceFunction">
            <summary>
            The Distance Function- Return the SQUARE of the euclidean distance between two
            objects of type T
            </summary>
        </member>
        <member name="F:Morpheus.CKDTree`1.m_tree">
            <summary>
            The underlying data structure containing the tree's data
            </summary>
        </member>
        <member name="F:Morpheus.CKDTree`1.m_axisCount">
            <summary>
            The number of axes that the tree is splitting on
            </summary>
        </member>
        <member name="F:Morpheus.CKDTree`1.m_count">
            <summary>
            The number of nodes in the tree
            </summary>
        </member>
        <member name="F:Morpheus.CKDTree`1.ExploredNodes">
            <summary>
            Can be used by the application to monitor how many nodes are being explored when
            a "Find" method is invoked. If ExploredNodes is not-null, then each Find
            operation will clear it, then fill it with all nodes explored. This is for
            debugging and display purposes only- This list is not used by this class in any
            other way.
            </summary>
        </member>
        <member name="M:Morpheus.CKDTree`1.AssertIMultiDimensionalPoint(`0)">
            <summary>
            Assert that an object (of type T) is also implementing
            <see cref="T:Morpheus.IMultiDimensionalPoint"/>
            </summary>
            <param name="_obj">The object of type T</param>
            <returns>
            The object represented as an <see cref="T:Morpheus.IMultiDimensionalPoint"/>
            </returns>
        </member>
        <member name="M:Morpheus.CKDTree`1.IsTMultiDimensional">
            <summary>
            Checks to see if the generic type T implements
            <see cref="T:Morpheus.IMultiDimensionalPoint"/>
            </summary>
            <returns>
            TRUE if T implements <see cref="T:Morpheus.IMultiDimensionalPoint"/> , FALSE if not
            </returns>
        </member>
        <member name="M:Morpheus.CKDTree`1.GetMultiDimensionalCoord(`0,System.Int32)">
            <summary>
            A version of the Func(T, int, double) for <see cref="F:Morpheus.CKDTree`1.m_selector"/> that depends
            on T implementing <see cref="T:Morpheus.IMultiDimensionalPoint"/>
            </summary>
            <param name="_obj">
            The object to cast as <see cref="T:Morpheus.IMultiDimensionalPoint"/> and get an axis
            coordinate from
            </param>
            <param name="_axis">The axis to look at</param>
            <returns>The coordinate of the object for the specified axis</returns>
        </member>
        <member name="M:Morpheus.CKDTree`1.GetMultiDimensionalDistance(`0,`0)">
            <summary>
            A version of the Func(T, T, double) that treats the object as an
            <see cref="T:Morpheus.IMultiDimensionalPoint"/> OR it uses <see cref="F:Morpheus.CKDTree`1.m_selector"/> to get
            the coordinates of both objects. In either case, the distanceSquared between the
            two points is returned.
            </summary>
            <param name="_p1">One of the points</param>
            <param name="_p2">The other point</param>
            <returns>The square of the distance between the two points</returns>
        </member>
        <member name="F:Morpheus.CKDTree`1.m_comparers">
            <summary>
            An array of IComparers for this KD tree.
            </summary>
        </member>
        <member name="T:Morpheus.CKDTree`1.CAxisComparer">
            <summary>
            Implements IComparer for a particular axis
            </summary>
        </member>
        <member name="M:Morpheus.CKDTree`1.BuildComparers">
            <summary>
            Builds the m_comparers array for this KD tree
            </summary>
        </member>
        <member name="M:Morpheus.CKDTree`1.#ctor">
            <summary>
            Construct a new K-D Tree, using the default selector for objects. This is a
            performance-hindered version, as it relies on
            <see cref="T:Morpheus.IMultiDimensionalPoint"/> .
            </summary>
        </member>
        <member name="M:Morpheus.CKDTree`1.#ctor(System.Int32,System.Func{`0,System.Int32,System.Double},System.Func{`0,`0,System.Double})">
            <summary>
            Construct a new K-D Tree, using the specified selector for objects
            </summary>
        </member>
        <member name="M:Morpheus.CKDTree`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32,System.Func{`0,System.Int32,System.Double},System.Func{`0,`0,System.Double})">
            <summary>
            Set up the K-D Tree based on an enumeration of elements. If the enumeration is
            another KDTree of type T, then a copy constructor <see cref="M:Morpheus.CKDTree`1.Clone"/> will be
            used.
            </summary>
            <param name="_collection">The collection of objects</param>
            <param name="_axisCount">
            The number of dimensions present in this KD Tree... use default if T implements
            <see cref="T:Morpheus.IMultiDimensionalPoint"/>
            </param>
            <param name="_selector">
            The selector to use on the objects- if NULL, relies on the objects to implement
            <see cref="T:Morpheus.IMultiDimensionalPoint"/>
            </param>
            <param name="_distanceFunction">
            A function that determines the distance between two nodes in the tree. Assumes
            Distances are measured using double precision floating point scalar values.
            </param>
            <remarks>
            If _axisCount == -1 and/or _selector == null, then T MUST implement
            <see cref="T:Morpheus.IMultiDimensionalPoint"/> .
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if _axisCount is less than 1 AND T is not an implementation of
            ArgumentOutOfRangeException
            </exception>
            <exception cref="T:System.ArgumentNullException">
            Thrown if _selector is NULL AND T is not an implementation of
            ArgumentOutOfRangeException
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if _axisCount is less than 1 AND there are no elements in the
            collection, even if T implements <see cref="T:Morpheus.IMultiDimensionalPoint"/> .
            </exception>
        </member>
        <member name="M:Morpheus.CKDTree`1.CopyConstructor(Morpheus.CKDTree{`0})">
            <summary>
            Simple copy constructor that assumes the structure of the existing KD Tree is
            intact
            </summary>
            <param name="_toCopy">The KD Tree to copy</param>
        </member>
        <member name="M:Morpheus.CKDTree`1.ConstructFromArray(`0[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Recursive function that will construct a KD Tree from a (subset of an) array of
            data.
            </summary>
            <param name="_array">The array containing the data</param>
            <param name="_low">The lowest index to process</param>
            <param name="_high">The highest index to process (inclusive)</param>
            <param name="_currentAxis">The axis that this is used to compare</param>
            <param name="_currentIdx">
            The node to populate with the median value from this array subset
            </param>
        </member>
        <member name="M:Morpheus.CKDTree`1.RebuildTree">
            <summary>
            Use this method when a significant number of nodes have been added to the tree
            after its construction. This has the effect of re-balancing the tree. This is
            not a cheap operation - O(n log n)
            </summary>
        </member>
        <member name="M:Morpheus.CKDTree`1.RebuildTree(System.Int32)">
            <summary>
            Use this method when a significant number of nodes have been added to the tree
            after its construction. This has the effect of re-balancing the tree. This is
            not a cheap operation - O(n log n)
            </summary>
        </member>
        <member name="M:Morpheus.CKDTree`1.Clone">
            <summary>
            Clone this tree. This operation will NOT balance the cloned tree.
            </summary>
            <returns>
            A copy of this KD-Tree, but NOT a deep-copy of the data found in the tree
            </returns>
        </member>
        <member name="M:Morpheus.CKDTree`1.SetDistanceFunction(System.Func{`0,`0,System.Double})">
            <summary>
            Allows the application to set the distance function for the KD Tree. Setting
            this function will speed up performance. If this function is not set, then the
            default mechanism (either using <see cref="T:Morpheus.IMultiDimensionalPoint"/> or using
            the Selector to determine distance in a generic way will be used.
            </summary>
            <param name="_fn">
            The function used to determine the distance between two points of type T. The
            distance returned should represent the SQUARE of the euclidean distance.
            </param>
        </member>
        <member name="M:Morpheus.CKDTree`1.FindNearest(`0)">
            <summary>
            Find the nearest element in the KD Tree to the specified element.
            </summary>
            <param name="_item">The item to search for</param>
            <returns>The closest node in the KD tree to the node specified</returns>
        </member>
        <member name="M:Morpheus.CKDTree`1.FindNearest(`0,System.Int32)">
            <summary>
            Find the nearest N elements in the KD Tree to the specified element.
            </summary>
            <param name="_item">The item to search for</param>
            <param name="_count">The number of closest elements to return</param>
            <returns>
            An enumeration of the closest N elements to the item specified
            </returns>
        </member>
        <member name="M:Morpheus.CKDTree`1.FindClose(`0,System.Double)">
            <summary>
            Find all items that are within a certain distance of an item
            </summary>
            <param name="_item">The item to find close other items for</param>
            <param name="_maxDistance">The maximum distance from _item to include</param>
            <returns>
            An enumeration of objects that are closer than _distance to _item
            </returns>
        </member>
        <member name="M:Morpheus.CKDTree`1.FindNearest(`0,System.Int32,System.Int32,Morpheus.CClosestObjects{`0})">
            <summary>
            Internal method for finding the closest N items to some item
            </summary>
            <param name="_item">The item to search for</param>
            <param name="_nodeIdx">The index of the node to start searching</param>
            <param name="_axis">The axis of the node at the index specified</param>
            <param name="_closest">A collection of close and valid nodes</param>
        </member>
        <member name="M:Morpheus.CKDTree`1.Add(`0)">
            <summary>
            Add a new item to this KD-Tree. This is not a balancing operation, so adding
            nodes may result in the KD-Tree becoming unbalanced quickly. Use "GetDepthFill"
            to determine the fill factor of lower depths.
            </summary>
            <param name="_item">The item to add to the tree</param>
        </member>
        <member name="M:Morpheus.CKDTree`1.FindMin(System.Int32,System.Int32,System.Int32)">
            <summary>
            Find the index of the item with the smallest coordinate for a specified axis
            </summary>
            <param name="_index">The index to start searching on</param>
            <param name="_targetAxis">The axis that is interesting</param>
            <param name="_axis">The current axis of the search</param>
            <returns>
            -1 if the index specified doesn't have a node associated with it, otherwise the
            index of the item with the smallest coordinate for the specified axis
            </returns>
        </member>
        <member name="M:Morpheus.CKDTree`1.FindMin(System.Int32)">
            <summary>
            Find the item with the smallest value for a given axis
            </summary>
            <param name="_axis">The axis to search for the lowest</param>
            <returns>
            -1 if the tree is empty, otherwise the item with the smallest coordinate for the
            specified axis
            </returns>
        </member>
        <member name="M:Morpheus.CKDTree`1.FindMax(System.Int32,System.Int32,System.Int32)">
            <summary>
            Find the index of the item with the largest coordinate for a specified axis
            </summary>
            <param name="_index">The index to start searching on</param>
            <param name="_targetAxis">The axis that is interesting</param>
            <param name="_axis">The current axis of the search</param>
            <returns>
            -1 if the index specified doesn't have a node associated with it, otherwise the
            index of the item with the largest coordinate for the specified axis
            </returns>
        </member>
        <member name="M:Morpheus.CKDTree`1.FindMax(System.Int32)">
            <summary>
            Find the item with the largest value for a given axis
            </summary>
            <param name="_axis">The axis to search for the largest</param>
            <returns>
            -1 if the tree is empty, otherwise the item with the largest coordinate for the
            specified axis
            </returns>
        </member>
        <member name="M:Morpheus.CKDTree`1.Remove(`0)">
            <summary>
            Remove a node from the KD Tree. This does NOT balance the tree
            </summary>
            <param name="_item">
            The item to remove- This must be an exact reference to the item
            </param>
            <returns>TRUE if an item was removed, FALSE if no item was found</returns>
        </member>
        <member name="M:Morpheus.CKDTree`1.Clear">
            <summary>
            Clear this KD-Tree. This operation is not recommended, as filling an empty tree
            node-by-node can be an expensive operation and lead to largely unbalanced trees.
            </summary>
        </member>
        <member name="M:Morpheus.CKDTree`1.Contains(`0)">
            <summary>
            Determine if an item exists in a tree. This is a ReferenceEquals operation, NOT
            a comparison of coordinates. This is an O(lgN) operation.
            </summary>
            <param name="_item">The item to look for</param>
            <returns>True of the item exists in the tree, FALSE if not</returns>
        </member>
        <member name="M:Morpheus.CKDTree`1.FindIndex(`0,System.Int32)">
            <summary>
            Return the index of a specified item in the tree. This is a ReferenceEquals
            operation, NOT a comparison of coordinates. This is an O(lgN) operation.
            </summary>
            <param name="_item">The item to look for</param>
            <param name="_startingIndex">
            The index of the node to start searching for the item. Defaults to the root (0)
            </param>
            <returns>The index of the item, or -1 if the item is not in the tree</returns>
        </member>
        <member name="P:Morpheus.CKDTree`1.Count">
            <summary>
            The number of items placed in the tree
            </summary>
        </member>
        <member name="M:Morpheus.CKDTree`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy the tree elements (in no particular order) to an array
            </summary>
            <param name="_array">The array to receive the items</param>
            <param name="_arrayIndex">The starting index in the array</param>
        </member>
        <member name="P:Morpheus.CKDTree`1.IsReadOnly">
            <summary>
            The KD-Tree is not read-only
            </summary>
        </member>
        <member name="M:Morpheus.CKDTree`1.GetEnumerator">
            <summary>
            An enumerator that returns items in no particular order
            </summary>
            <returns>An enumeration of items in no particular order</returns>
        </member>
        <member name="M:Morpheus.CKDTree`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            An enumerator that returns items in no particular order
            </summary>
            <returns>An enumeration of items in no particular order</returns>
        </member>
        <member name="M:Morpheus.CKDTree`1.GetDepthFillString">
            <summary>
            Return a string that contains the fill levels of each "layer" of the tree
            </summary>
            <returns></returns>
        </member>
        <member name="T:Morpheus.CLineSegment">
            <summary>
            A Line Segment, defined as having two points that describe the endpoints of said
            segment
            </summary>
        </member>
        <member name="M:Morpheus.CLineSegment.#ctor(Morpheus.SVector2d,Morpheus.SVector2d)">
            <summary>
            Construct with two vectors
            </summary>
            <param name="_point1"></param>
            <param name="_point2"></param>
        </member>
        <member name="M:Morpheus.CLineSegment.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Construct with axis coordinates of the endpoints
            </summary>
            <param name="_x1"></param>
            <param name="_y1"></param>
            <param name="_x2"></param>
            <param name="_y2"></param>
        </member>
        <member name="M:Morpheus.CLineSegment.HasInBox(Morpheus.SVector2d)">
            <summary>
            Determine if a point is inside the "box" formed by the endpoints of this segment
            </summary>
            <param name="_point">The point to test</param>
            <returns>
            TRUE if a point in space is inside the "box" formed by the two endpoints of this
            segment
            </returns>
        </member>
        <member name="M:Morpheus.CLineSegment.ClockDirection(Morpheus.SVector2d,Morpheus.SVector2d,Morpheus.SVector2d)">
            <summary>
            Return true if the vector AB to vector AC is counterclockwise. It is
            counterclockwise when the determinant is positive. Clockwise: Negative.
            Co-linear: 0
            </summary>
            <remarks>This is really just a determinant of vectors AB and AC</remarks>
            <param name="_a"></param>
            <param name="_b"></param>
            <param name="_c"></param>
            <returns>-1: Clockwise, 1: CounterClockwise, 0: Colinear</returns>
        </member>
        <member name="M:Morpheus.CLineSegment.DoesIntersect(Morpheus.CLineSegment)">
            <summary>
            Check for intercection using the "Clockwise Test". For intersection, both these
            conditions need to be true:
            
            C needs to be on the "other side" of AB than D
            
            A needs to be on the "other side" of CD than B
            
            The "other side" test is done by checking to see if you need to go clockwise to
            one point and counter-clockwise to the other.
            </summary>
            <param name="_other">The LineSegment to test for intersection</param>
            <returns>
            TRUE if the segments intersect, including if (at least) part of one line segment
            lies on the other
            </returns>
        </member>
        <member name="M:Morpheus.CLineSegment.ToString">
            <summary>
            User and debug friendly version
            </summary>
            <returns></returns>
        </member>
        <member name="T:Morpheus.CMaxLengthList`1">
            <summary>
            A fixed-length list that replaces the "oldest" elements with new elements as they are added.
            Keeps the most recently added N elements added.
            </summary>
            <typeparam name="T">The Type of the elements in the list</typeparam>
        </member>
        <member name="T:Morpheus.Combinations">
            <summary>
            An enumerator used to return all possible combinations of numbers between 1 and N taken
            K at a time.
            </summary>
        </member>
        <member name="M:Morpheus.Combinations.Integers(System.Int32,System.Int32)">
            <summary>
            An enumerator used to return all possible combinations of numbers between 1 and N
            taken K at a time.
            </summary>
            <remarks>
            It is critical to note that the returned array SHOULD NOT BE MODIFIED! It represents the
            state of the generator. If its modified, then the generator will not work
            correctly.
            </remarks>
            <returns>
            A set of _K unique integers from the set of [0.N). Caller SHOULD NOT MODIFY ANY
            ELEMENTS OF THIS ARRAY. To achieve performance, this returned array is also the
            curent state of the generator.
            </returns>
        </member>
        <member name="T:Morpheus.Permutations">
            <summary>
            A fast way of returning all permutations of _K integers at a time from a set of _N
            integers.
            </summary>
            <remarks>
            It is critical to note that the returned array SHOULD NOT BE MODIFIED! It represents the
            state of the permutation generator. If its modified, then the generator will not work
            correctly.
            </remarks>
        </member>
        <member name="M:Morpheus.Permutations.Integers(System.Int32,System.Int32)">
            <summary>
            A fast way of returning all permutations of _K integers at a time from a set of _N
            integers.
            </summary>
            <remarks>
            It is critical to note that the returned array SHOULD NOT BE MODIFIED! It represents
            the state of the permutation generator. If its modified, then the generator will not
            work correctly.
            </remarks>
            <param name="_N">The highest of the integers to return. Returns [0.._N)</param>
            <param name="_K">The number of integers to return each time.</param>
            <returns>
            A set of _K unique integers from the set of [0.N). Caller SHOULD NOT MODIFY ANY
            ELEMENTS OF THIS ARRAY. To achieve performance, this returned array is also the
            curent state of the generator.
            </returns>
        </member>
        <member name="T:Morpheus.COrderedList`1">
            <summary>
            An Ordered List. Uses the Generic List's operations of BinarySearch and Sort to maintain
            order, according to the required IComparable implementation for the Type.
            </summary>
            <typeparam name="T">Any Type that implements IComparable</typeparam>
        </member>
        <member name="M:Morpheus.COrderedList`1.#ctor">
            <summary>
            Create an empty ordered list
            </summary>
        </member>
        <member name="M:Morpheus.COrderedList`1.#ctor(System.Int32)">
            <summary>
            Create an empty ordered list, but with a pre-allocated memory block
            </summary>
            <param name="_initialSize">The amount of memory to pre-allocate</param>
        </member>
        <member name="M:Morpheus.COrderedList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Create and initialize an Ordered List with a set of elements. The OrderedList will
            contain those elements, but in sorted order.
            </summary>
            <param name="_elements">The elements to initialize the list with</param>
        </member>
        <member name="M:Morpheus.COrderedList`1.IndexOf(`0)">
            <summary>
            The index of a specific element within the list. The IComparable{T} implementation
            will be used to detect equal elements.
            </summary>
            <param name="_item">
            The Item to search for. Only those fields used by the IComparable{T} implementation
            need to be populated. This is NOT a reference-equals check.
            </param>
            <returns>
            The Index of the Element in the List, or the ones-complement of the index where the
            element should be inserted IF the element does not already exist in the list.
            
            Note that this is slightly different from the List{T} implementation in that it will
            only return -1 if the item is not found, where this implementation will return a
            negative number, but not necessarily -1
            </returns>
        </member>
        <member name="M:Morpheus.COrderedList`1.Insert(System.Int32,`0)">
            <summary>
            Insert At Index --- NOT IMPLEMENTED as it is likely to perturb sorting order
            </summary>
            <param name="_index">N/A</param>
            <param name="_item">N/A</param>
        </member>
        <member name="M:Morpheus.COrderedList`1.RemoveAt(System.Int32)">
            <summary>
            Remove an element at a given index.
            </summary>
            <param name="_index">The Index to remove the element at</param>
        </member>
        <member name="P:Morpheus.COrderedList`1.Item(System.Int32)">
            <summary>
            Access an element at a given index. The SETTER is not implemented, as it is likely
            to perturb the ordering of elements in the list.
            </summary>
            <param name="_index">The index of the element to look up</param>
            <returns>The Element at the specified index</returns>
        </member>
        <member name="M:Morpheus.COrderedList`1.Add(`0)">
            <summary>
            Add an item to an ordered list
            </summary>
            <param name="_item">The item to add</param>
        </member>
        <member name="M:Morpheus.COrderedList`1.Clear">
            <summary>
            Remove all elements from this ordered list
            </summary>
        </member>
        <member name="M:Morpheus.COrderedList`1.Contains(`0)">
            <summary>
            Check to see if the list contains an element. This is NOT a reference-equals check.
            It uses IComparable == 0 to determine sameness
            </summary>
            <param name="_item">The item to check the list for</param>
            <returns>TRUE if the element exists in the list</returns>
        </member>
        <member name="M:Morpheus.COrderedList`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy the ordered list (or part of it) to an array
            </summary>
            <param name="_array">The Array to copy the elements to</param>
            <param name="_index">The starting index within the destination array</param>
        </member>
        <member name="P:Morpheus.COrderedList`1.Count">
            <summary>
            The number of elements in the ordered list
            </summary>
        </member>
        <member name="P:Morpheus.COrderedList`1.IsReadOnly">
            <summary>
            Always False- Ordered Lists don't have read-only versions (yet)
            </summary>
        </member>
        <member name="M:Morpheus.COrderedList`1.Remove(`0)">
            <summary>
            Remove an Item from the ordered list based on the IComparable implementation
            </summary>
            <param name="_item">The item to remove from the list</param>
            <returns>TRUE if the item was removed, FALSE if it was not found</returns>
        </member>
        <member name="M:Morpheus.COrderedList`1.GetEnumerator">
            <summary>
            Get an enumeration of the items in this list. This is an ordered enumeration.
            </summary>
            <returns>
            An enumeration of the items in this list. This is an ordered enumeration.
            </returns>
        </member>
        <member name="M:Morpheus.COrderedList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get an enumeration of the items in this list. This is an ordered enumeration.
            </summary>
            <returns>
            An enumeration of the items in this list. This is an ordered enumeration.
            </returns>
        </member>
        <member name="M:Morpheus.COrderedList`1.ToArray">
            <summary>
            Return an array perfectly sized to hold all of the elements of this list, in order
            </summary>
            <returns></returns>
        </member>
        <member name="T:Morpheus.CPriorityQueue`1">
            <summary>
            CPriorityQueue is a binary heap based priority queue that supports rapid adding and
            removal of highest priority items, but slow removal of "any" object in the queue.
            
            The concept of "Priority" for this class states that the LOWEST value is the HIGHEST
            priority. In other words, and by example, the value 1 has a higher priority than the
            value 5. The name "Abe" has a higher priority than the name "Ben".
            
            Use a different comparer (specified in the constructors) to change this behavior, or to
            apply a "selector" on object data. Also reference <see cref="T:Morpheus.CLambdaComparer`1"/>
            to specify a lambda function as a comparer instead of an object that implements
            <see cref="T:System.Collections.Generic.IComparer`1"/>.
            </summary>
            <remarks><code>
            Operation   Big-O 
            ---------------------------------------------- 
            Add         lg(N)
            RemoveAny   N
            RemoveFront lg(N)
            PeekFront   1
            Sort        N*lg(N)
            Find/Contains N
            UpdateKey   N Count 1
            Enumerate   N*lg(N)
            </code></remarks>
        </member>
        <member name="F:Morpheus.CPriorityQueue`1.m_heap">
            <summary>
            The binary heap used to store all the data in the tree
            </summary>
        </member>
        <member name="F:Morpheus.CPriorityQueue`1.m_comparer">
            <summary>
            The comparer to use when determining collation order
            </summary>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.#ctor">
            <summary>
            Construct a new priority queue, using the default comparator for objects
            </summary>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Construct a new priority queue, using the specified comparator for objects
            </summary>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Construct a new priority queue with an initialized capacity, optionally specifying a
            comparator
            </summary>
            <param name="_initialCapacity">
            The initial capacity of the heap, used to help reduce memory re-allocation
            </param>
            <param name="_comparer">The comparer to use for collation/ordering</param>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0})">
            <summary>
            Construct the priority queue from an existing collection of objects.
            </summary>
            <param name="_collection">The collection of objects</param>
            <param name="_comparer">The comparer to use for collation/ordering</param>
            <remarks>
            If the collection is a List of T, the capacity of the queue will be set to the
            capacity of the List. If the collection is an Array of T, the capacity of the queue
            will be set to be 10% greater than the Length of the array.
            </remarks>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.ConstructFromEnumerable(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Set up the heap based on an enumeration of elements. This does some optimizing based
            on the type of enumeration given to the Priority Queue. It includes a "copy
            constructor", an optimized List-of-T and an Array-of-T optimization. This also
            "stores" the comparer, if its not null. Any class deriving from this should use this
            helper method in the constructor that accepts an enumeration.
            </summary>
            <param name="_collection">
            The enumeration of objects to construct the PriorityQueue from
            </param>
            <returns>
            TRUE if the "Add" method was used to add a collection to this priority queue, FALSE
            if the base-class heap was constructed without using "Add", thereby requiring
            deriving classes to establish their own internal data structures.
            </returns>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.Allocate(System.Int32)">
            <summary>
            Allocate memory for data structures. Assures derived classes allocate memory at the
            right time.
            </summary>
            <param name="_capacity">
            Negative: Don't allocate here; 0: Allocate without capacity hints
            </param>
        </member>
        <member name="P:Morpheus.CPriorityQueue`1.Capacity">
            <summary>
            Gets or sets the total number of elements the internal data structure can hold
            without resizing.
            </summary>
        </member>
        <member name="P:Morpheus.CPriorityQueue`1.Comparer">
            <summary>
            The IComparer object used to prioritize objects in the priority queue
            </summary>
            <exception cref="T:System.InvalidOperationException">
            The comparer was set after there were more than 1 element added to the data
            structure
            </exception>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.SetComparisonFunction(System.Func{`0,`0,System.Int32})">
            <summary>
            Set the comparer for the priority queue using a lambda function.
            </summary>
            <param name="_comparer">
            The lambda function which prioritizes items in the queue
            </param>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.GetLeftChild(System.Int32)">
            <summary>
            Helper function to retrieve the "Left Child" using the properties of the binary heap
            </summary>
            <param name="_current">The "parent" to find the child for</param>
            <returns>The index of the Left Child</returns>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.GetParent(System.Int32)">
            <summary>
            Helper function to retrieve the "parent" using the properties of the binary heap
            </summary>
            <param name="_current">The "child" to find the parent for</param>
            <returns>The index of the Parent</returns>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.Swap(System.Int32,System.Int32)">
            <summary>
            Helper function to swap two objects in the heap
            </summary>
            <param name="_index1">First object to swap</param>
            <param name="_index2">Second object to swap</param>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.AddReturnIndex(`0)">
            <summary>
            Add a new node to the heap, and prioritize it
            </summary>
            <param name="_newObject">The object to add</param>
            <returns>The index in the heap where the node was added</returns>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.BubbleUp(System.Int32)">
            <summary>
            Designed to move an element "up" the heap (towards the front) after we assume its
            "value" has changed.
            </summary>
            <param name="_index">The index of the element in the heap</param>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.PushDown(System.Int32)">
            <summary>
            Push an element "down" the list, away from the top of the list, until it is in an
            acceptable position
            </summary>
            <param name="_index">The index of the element to push down</param>
            <returns>The new index of the element within the heap</returns>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.RemoveAt(System.Int32)">
            <summary>
            Remove an element at a particular index
            </summary>
            <param name="_index">The index of the element to remove</param>
        </member>
        <member name="P:Morpheus.CPriorityQueue`1.Count">
            <summary>
            Implements Count from ICollection- Return the number of objects in the queue
            </summary>
        </member>
        <member name="P:Morpheus.CPriorityQueue`1.LowestNode">
            <summary>
            A reference to the lowest node. Sort of a "peek" function.
            </summary>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.Clear">
            <summary>
            Remove all elements from this collection
            </summary>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.Add(`0)">
            <summary>
            Add a new node to the heap, and prioritize it
            </summary>
            <remarks>This implements the <see cref="T:System.Collections.ICollection"/> "Add" function</remarks>
            <param name="_newObject">The object to add</param>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add a collection of elements to this queue
            </summary>
            <param name="_collection">
            A collection of elements to add to this priority queue
            </param>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.RemoveLowest">
            <summary>
            Remove the "lowest" node from the heap, adjusting it appropriately
            </summary>
            <returns>The "lowest" node.</returns>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.Remove(`0)">
            <summary>
            Remove a specific node from the collection
            </summary>
            <param name="_element">The element to remove</param>
            <returns>TRUE if the node was removed, FALSE if not found</returns>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.Contains(`0)">
            <summary>
            Deetermine if the priority queue contains a given element. This is an O(n)
            operation.
            </summary>
            <param name="_element">The element to check for</param>
            <returns>TRUE if the queue contains the element, FALSE if not</returns>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.Update(`0)">
            <summary>
            When the Priority of an element changes, this method will re-organize the queue
            considering the new priority for the element. This will adjust the node's position
            in the collection based on its new value. If the node does not exist, it will be
            added to the priority queue.
            </summary>
            <param name="_element">The node whose value has changed.</param>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.CopyTo(`0[],System.Int32)">
            <summary>
            Implements CopyTo from ICollection
            </summary>
            <param name="_targetArray">The destination array</param>
            <param name="_index">The base index in the destination array</param>
        </member>
        <member name="P:Morpheus.CPriorityQueue`1.IsReadOnly">
            <summary>
            Returns FALSE for this implementation- the priority queue is never read-only
            </summary>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.GetEnumerator">
            <summary>
            Get the enumerator for the base heap. This will return an "ordered" list.
            </summary>
            <returns>An Enumerator</returns>
        </member>
        <member name="M:Morpheus.CPriorityQueue`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Other enumerator from base IEnumerator- This is also an ordered list
            </summary>
            <returns>An enumerator over the heap</returns>
        </member>
        <member name="T:Morpheus.CPriorityQueueExtended`1">
            <summary>
            An optimized Priority Queue that maintains internal data structures allowing more efficient operations
            than <see cref="T:Morpheus.CPriorityQueue`1"/> without introducing external dependencies on the data type stored
            like <see cref="T:Morpheus.CPriorityQueueOptimized`1"/> does.
            
            This class requires more than twice the memory overhead of the <see cref="T:Morpheus.CPriorityQueue`1"/> class, so
            it should only be used if the faster operations will be relied upon.
            </summary>
            <typeparam name="T">The Type of the data stored in the queue</typeparam>
            <remarks>
            This version of the <see cref="T:Morpheus.CPriorityQueue`1"/> maintains a separate dictionary that allows quick
            lookup of the index within the binary heap for an object. This provides rapid access to a few other
            operations of the data structure.
            
            Operation       Big-O       Improvement on CPriorityQueue
            -------------------------------------------------------------
            Add             lg(N)
            RemoveAny       lg(N)       *
            RemoveFront     lg(N)
            PeekFront       1
            Sort            N*lg(N)
            Find/Contains   1           *
            UpdateKey       lg(N)       *
            Count           1
            Enumerate       N*lg(N)
            </remarks>
        </member>
        <member name="M:Morpheus.CPriorityQueueExtended`1.#ctor">
            <summary>
            Construct a new priority queue, using the default comparator for objects
            </summary>
        </member>
        <member name="M:Morpheus.CPriorityQueueExtended`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Construct a new priority queue, using the default comparator for objects if none is specified
            </summary>
            <param name="_comparer">The comparer to use for collation/ordering</param>
        </member>
        <member name="M:Morpheus.CPriorityQueueExtended`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Construct a new priority queue with an initialized capacity, optionally specifying a comparator
            </summary>
            <param name="_initialCapacity">The initial capacity of the heap, used to help reduce memory re-allocation</param>
            <param name="_comparer">The comparer to use for collation/ordering</param>
        </member>
        <member name="M:Morpheus.CPriorityQueueExtended`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0})">
            <summary>
            Construct the priority queue from an existing collection of objects.
            </summary>
            <param name="_collection">The collection of objects</param>
            <param name="_comparer">The comparer to use for collation/ordering</param>
            <remarks>
            Relies heavily on the base-class implementation of "ConstructFromEnumerable" to determine an optimal
            method of constructing a queue from a collection.
            </remarks>
        </member>
        <member name="M:Morpheus.CPriorityQueueExtended`1.Allocate(System.Int32)">
            <summary>
            Allocate the dictionary
            </summary>
            <param name="_capacity">The capacity hint: Positive, specify an initial Dictionary capacity, otherwise don't</param>
        </member>
        <member name="M:Morpheus.CPriorityQueueExtended`1.Swap(System.Int32,System.Int32)">
            <summary>
            Helper function to swap two objects in the heap. All base class operations that could affect the
            index of an element in the heap MUST use the "Swap" function to maintain any helper data structures
            with optimization
            </summary>
            <param name="_index1">First object to swap</param>
            <param name="_index2">Second object to swap</param>
        </member>
        <member name="M:Morpheus.CPriorityQueueExtended`1.Clear">
            <summary>
            Remove all elements from this collection
            </summary>
        </member>
        <member name="M:Morpheus.CPriorityQueueExtended`1.Add(`0)">
            <summary>
            Add a new node to the heap, and prioritize it
            </summary>
            <remarks>
            This implements the <see cref="T:System.Collections.Generic.ICollection`1"/> "Add" function
            </remarks>
            <param name="_newObject">The object to add</param>
        </member>
        <member name="M:Morpheus.CPriorityQueueExtended`1.RemoveLowest">
            <summary>
            Remove the "lowest" node from the heap, adjusting it appropriately
            </summary>
            <returns>The "lowest" node.</returns>
        </member>
        <member name="M:Morpheus.CPriorityQueueExtended`1.Remove(`0)">
            <summary>
            Remove an element from the queue
            </summary>
            <param name="_element">The element to remove</param>
            <returns>TRUE if the element was removed, FALSE otherwise</returns>
        </member>
        <member name="M:Morpheus.CPriorityQueueExtended`1.Contains(`0)">
            <summary>
            Does the collection contain this element?
            </summary>
            <param name="_element">The element to check</param>
            <returns>TRUE if the element is in the collection, FALSE if not</returns>
        </member>
        <member name="M:Morpheus.CPriorityQueueExtended`1.Update(`0)">
            <summary>
            When the Priority of an element changes, this method will re-organize the queue considering the new priority for the element.
            This will adjust the node's position in the collection based on its new value. If the node does not exist, it will be added 
            to the priority queue.
            </summary>
            <param name="_element">The node whose value has changed.</param>
        </member>
        <member name="T:Morpheus.IOptimizedBinaryHeapNode">
            <summary>
            If a class implements this interface, it will be able to be used with the Optimized Priority Queue collection
            </summary>
        </member>
        <member name="P:Morpheus.IOptimizedBinaryHeapNode.HeapIndex">
            <summary>
            The index within the Binary Heap used by <see cref="T:Morpheus.CPriorityQueueOptimized`1"/>
            </summary>
        </member>
        <member name="T:Morpheus.CPriorityQueueOptimized`1">
            <summary>
            An Optimized Priority Queue requires that all elements stored in the queue implement the
            <see cref="T:Morpheus.IOptimizedBinaryHeapNode"/> interface. This interface allows this version of
            the queue to store and retrieve the index within the heap (queue) that each element sits at.
            </summary>
            <typeparam name="T">Some type that implements IOptimizedBinaryHeapNode</typeparam>
            <remarks>
            This version offloads the "index" of each object into the object itself. It has the benefit of
            having a smaller memory footprint, but the drawback of allowing an object to belong to at most
            one COptimizedPriorityQueue. The other optimized version of the priority queue <see cref="T:Morpheus.CPriorityQueueExtended`1"/>
            uses an internal dictionary to maintain these indicies.
            </remarks>
        </member>
        <member name="M:Morpheus.CPriorityQueueOptimized`1.#ctor">
            <summary>
            Construct a new priority queue, using the default comparator for objects
            </summary>
        </member>
        <member name="M:Morpheus.CPriorityQueueOptimized`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Construct a new priority queue, using the default comparator for objects if none is specified
            </summary>
            <param name="_comparer">The comparer to use for collation/ordering</param>
        </member>
        <member name="M:Morpheus.CPriorityQueueOptimized`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Construct a new priority queue with an initialized capacity, optionally specifying a comparator
            </summary>
            <param name="_initialCapacity">The initial capacity of the heap, used to help reduce memory re-allocation</param>
            <param name="_comparer">The comparer to use for collation/ordering</param>
        </member>
        <member name="M:Morpheus.CPriorityQueueOptimized`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0})">
            <summary>
            Construct the priority queue from an existing collection of objects.
            </summary>
            <param name="_collection">The collection of objects</param>
            <param name="_comparer">The comparer to use for collation/ordering</param>
            <remarks>
            If the collection is a List of T, the capacity of the queue will be set to the capacity of the List. If the 
            collection is an Array of T, the capacity of the queue will be set to be 10% greater than the Length of the 
            array.
            </remarks>
        </member>
        <member name="M:Morpheus.CPriorityQueueOptimized`1.Swap(System.Int32,System.Int32)">
            <summary>
            Helper function to swap two objects in the heap
            </summary>
            <param name="_index1">First object to swap</param>
            <param name="_index2">Second object to swap</param>
        </member>
        <member name="M:Morpheus.CPriorityQueueOptimized`1.Clear">
            <summary>
            Remove all elements from this collection
            </summary>
        </member>
        <member name="M:Morpheus.CPriorityQueueOptimized`1.Add(`0)">
            <summary>
            Add a new node to the heap, and prioritize it
            </summary>
            <remarks>
            This implements the <see cref="T:System.Collections.Generic.ICollection`1"/> "Add" function
            </remarks>
            <param name="_newObject">The object to add</param>
        </member>
        <member name="M:Morpheus.CPriorityQueueOptimized`1.RemoveLowest">
            <summary>
            Remove the "lowest" node from the heap, adjusting it appropriately
            </summary>
            <returns>The "lowest" node.</returns>
        </member>
        <member name="M:Morpheus.CPriorityQueueOptimized`1.Remove(`0)">
            <summary>
            Remove an element from the queue
            </summary>
            <param name="_element">The element to remove</param>
            <returns>TRUE if the element was removed, FALSE otherwise</returns>
        </member>
        <member name="M:Morpheus.CPriorityQueueOptimized`1.Contains(`0)">
            <summary>
            Does the collection contain this element?
            </summary>
            <param name="_element">The element to check</param>
            <returns>TRUE if the element is in the collection, FALSE if not</returns>
        </member>
        <member name="M:Morpheus.CPriorityQueueOptimized`1.Update(`0)">
            <summary>
            Call when the "value" of a node changes. This will adjust the node's position in the collection based on its new value. If
            the node does not exist, it will be added to the collection.
            </summary>
            <param name="_node">The node whose value has changed.</param>
        </member>
        <member name="T:Morpheus.CSortableBindingList`1">
            <summary>
            This craptastic class makes up for the large deficiency that the base class (<see cref="T:System.ComponentModel.BindingList`1"/>) has
            in that it won't support binding. CRAP-TASTIC, I tell you!
            </summary>
            <remarks>
            Check out the docs at <see cref="M:System.ComponentModel.BindingList`1.ApplySortCore(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)"/> for why I had to do this.
            </remarks>
            <typeparam name="T">The Type of the elements in the list</typeparam>
        </member>
        <member name="T:Morpheus.CSortableBindingList`1.CBindingListComparer`1">
            <summary>
            Helper class to make sure that items are dereferenced properly using the <see cref="T:System.ComponentModel.PropertyDescriptor"/>
            </summary>
            <typeparam name="TT"></typeparam>
        </member>
        <member name="F:Morpheus.CSortableBindingList`1.CBindingListComparer`1.m_bindingList">
            <summary>
            Give me access to the <see cref="T:System.ComponentModel.PropertyDescriptor"/>
            </summary>
        </member>
        <member name="M:Morpheus.CSortableBindingList`1.CBindingListComparer`1.#ctor(Morpheus.CSortableBindingList{`1})">
            <summary>
            Construct with the <see cref="T:Morpheus.CSortableBindingList`1"/> that gives me access to the <see cref="T:System.ComponentModel.PropertyDescriptor"/>
            </summary>
            <param name="_bindingList">The binding list to use this comparer with</param>
        </member>
        <member name="M:Morpheus.CSortableBindingList`1.CBindingListComparer`1.Compare(`1,`1)">
            <summary>
            The comparison operator- dereferences each item using the <see cref="T:System.ComponentModel.PropertyDescriptor"/>
            </summary>
            <param name="_first"></param>
            <param name="_second"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CSortableBindingList`1.#ctor">
            <summary>
            Construct an empty binding list
            </summary>
        </member>
        <member name="M:Morpheus.CSortableBindingList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Initializes a new instance of the BindingList class with the specified list.
            </summary>
            <param name="_items">The items in the list</param>
        </member>
        <member name="M:Morpheus.CSortableBindingList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the BindingList class with the specified list.
            </summary>
            <param name="_items">The items in the list</param>
        </member>
        <member name="P:Morpheus.CSortableBindingList`1.SortDirectionCore">
            <summary>
            The direction of the sort (ascending or descending)
            </summary>
        </member>
        <member name="P:Morpheus.CSortableBindingList`1.SortPropertyCore">
            <summary>
            From ComponentModel, the property descriptor for the sort property
            </summary>
        </member>
        <member name="P:Morpheus.CSortableBindingList`1.SupportsSortingCore">
            <summary>
            This class always supports sorting
            </summary>
        </member>
        <member name="P:Morpheus.CSortableBindingList`1.IsSortedCore">
            <summary>
            If true, the list has been sorted in some way
            </summary>
        </member>
        <member name="M:Morpheus.CSortableBindingList`1.RemoveSortCore">
            <summary>
            Un-sort the list
            </summary>
        </member>
        <member name="M:Morpheus.CSortableBindingList`1.ApplySortCore(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)">
            <summary>
            Sort the list according to some property 
            </summary>
            <param name="_property">The property to sort (from ComponentModel)</param>
            <param name="_direction">The direction to sort</param>
        </member>
        <member name="T:Morpheus.CSortingAlgorithms">
            <summary>
            A collection of various sorting algorithms that may be faster than the IntroSort implemented from within the
            <see cref="T:System.Array"/> class. (Note: It was QuickSort up until 4.5) (Note 2: Its still not stable)
            </summary>
        </member>
        <member name="M:Morpheus.CSortingAlgorithms.InsertionSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sort the IList using an INSERTION SORT- O(n^2) in complexity, but it is a STABLE sort.
            Uses the default comparator for objects of type T
            </summary>
            <typeparam name="T">The type of the elements in the list</typeparam>
            <param name="_list">The list of items to sort</param>
        </member>
        <member name="M:Morpheus.CSortingAlgorithms.InsertionSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sort the IList using an INSERTION SORT- O(n^2) in complexity, but it is a STABLE sort
            </summary>
            <typeparam name="T">The type of the elements in the list</typeparam>
            <param name="_list">The list of items to sort</param>
            <param name="_comparer">The comparer for the sort</param>
        </member>
        <member name="M:Morpheus.CSortingAlgorithms.InsertionSort``2(System.Collections.Generic.IList{``0},System.Func{``0,``1})">
            <summary>
            Sort the IList using an INSERTION SORT- O(n^2) in complexity, but it is a STABLE sort
            </summary>
            <typeparam name="TList">The type of the elements in the list</typeparam>
            <typeparam name="TSelector"></typeparam>
            <param name="_list">The list of items to sort</param>
            <param name="_selector">Selects a member in each TList item to use with the DEFAULT COMPARER</param>
        </member>
        <member name="M:Morpheus.CSortingAlgorithms.InsertionSort``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
            <summary>
            Sort the IList using an INSERTION SORT- O(n^2) in complexity, but it is a STABLE sort
            </summary>
            <typeparam name="T">The type of the elements in the list</typeparam>
            <param name="_list">The list of items to sort</param>
            <param name="_comparer">The comparer for the sort</param>
        </member>
        <member name="M:Morpheus.CSortingAlgorithms.QuickSelect``1(``0[],System.Int32,System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            The QuickSelect algorithm- Split an array such that all items to the "left" of the position requested are "less than"
            the position, and all items to the "right" of the position are "greater than" the item in that position. Useful for
            placing the median of an array at the middle of the array.
            </summary>
            <typeparam name="T">The Type of elements in the array</typeparam>
            <param name="_array">The array</param>
            <param name="_low">Consider this index the "beginning" of the array</param>
            <param name="_high">Consider this index the "end" of the array</param>
            <param name="_position">The position for which elements to the left are less-than, and the elements to the right are greater than</param>
            <param name="_comparer">The comparer to use to compare the elements to each other</param>
        </member>
        <member name="M:Morpheus.CSortingAlgorithms.SwapItems``1(``0[],System.Int32,System.Int32)">
            <summary>
            Swap the elements at two indicies in the array
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_array"></param>
            <param name="_idx1"></param>
            <param name="_idx2"></param>
        </member>
        <member name="T:Morpheus.CSparseLeafBinaryTree`1">
            <summary>
            A Sparse Leaf Binary Tree has a compact set of "roots" coupled with a sparse set of
            "leaves"
            </summary>
            <remarks>
            The Sparse Leaf Binary Tree is composed of two parts.
            
            The "Roots" are implemented as an array of elements that have the general access
            methods used in a Binary Heap, forming a 'complete binary tree'
            
            The leaves are implemented as a Dictionary, forming the sparse nature of the bottom
            of the tree.
            
            There are no assumptions made about ordering- therefore, this is NOT a binary heap.
            
            The construction of this data structure is what forms the "roots" of the tree.
            Elements added after construction can either be added to the roots IFF they fit onto
            the last level of the roots, or they are added to the dictionary if they are deeper
            than the roots.
            
            This data structure should be used when the lg(N) nature of a binary tree is
            desired, when a base set of data is available from which to construct the roots, and
            newly added elements are not expected to be frequent nor numerous, and may cause the
            tree to become (possibly significantly) unbalanced.
            
            The implementation of the T[] for the roots saves the extra memory overhead of the
            index key in the Dictionary. When you know that there are at least N elements, those
            roots can be pre-allocated and compressed.
            
            If the tree will be very small, a Dictionary-based solution would be better, as the
            memory overhead of the indicies would be negligible. But for a tree with millions or
            more nodes, the memory overhead can be reduced with this type of tree.
            
            NOTE This may seem like an overly specific data structure- it is! It is meant to
            optimize the KDTree for searching
            </remarks>
        </member>
        <member name="M:Morpheus.CSparseLeafBinaryTree`1.#ctor(System.Int32)">
            <summary>
            Construct the binary tree with an initial capacity. This capacity determines how
            large the "roots" will be. It will be rounded up to (the nearest power of 2)
            minus 1
            </summary>
            <param name="_capacity">The capacity of the roots</param>
        </member>
        <member name="P:Morpheus.CSparseLeafBinaryTree`1.RootDepth">
            <summary>
            The depth (zero-based) of the roots of the tree. Items will be in the roots down
            to this depth.
            </summary>
        </member>
        <member name="P:Morpheus.CSparseLeafBinaryTree`1.Item(System.Int32)">
            <summary>
            Access the elements in the binary tree by index. It doesn't matter if the index
            is in the roots or in the leaves.
            </summary>
            <param name="_index">The index. There are no out-of-range exceptions.</param>
            <returns>
            The element stored at this index, or NULL if nothing is stored there.
            </returns>
        </member>
        <member name="M:Morpheus.CSparseLeafBinaryTree`1.Clear">
            <summary>
            Clear out all elements of the roots and leaves. This leaves the size of the
            roots intact.
            </summary>
            <remarks>
            This is optimized to assume that the m_root array has been aged to a later GC
            generation. Were m_root not aged (a short-lived object), this routine would
            likely be faster by simply re-allocating the m_root array. Potato-potahto
            </remarks>
        </member>
        <member name="M:Morpheus.CSparseLeafBinaryTree`1.GetLeftIndex(System.Int32)">
            <summary>
            Get the index of the Left child of a given index
            </summary>
            <param name="_index"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CSparseLeafBinaryTree`1.GetLeft(System.Int32)">
            <summary>
            Get the Left child of an item at a specific index
            </summary>
            <param name="_index"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CSparseLeafBinaryTree`1.GetRightIndex(System.Int32)">
            <summary>
            Get the index of the Right child of a given index
            </summary>
            <param name="_index"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CSparseLeafBinaryTree`1.GetRight(System.Int32)">
            <summary>
            Get the Right child of an item at a specific index
            </summary>
            <param name="_index"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CSparseLeafBinaryTree`1.GetParentIndex(System.Int32)">
            <summary>
            Get the index of the Parent of a given index
            </summary>
            <param name="_index"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CSparseLeafBinaryTree`1.GetParent(System.Int32)">
            <summary>
            Get the Parent object of an item at a specific index
            </summary>
            <param name="_index"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CSparseLeafBinaryTree`1.GetSiblingIndex(System.Int32)">
            <summary>
            Get the index of a given index's sibling
            </summary>
            <param name="_index"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CSparseLeafBinaryTree`1.GetSibling(System.Int32)">
            <summary>
            Get the Sibling object of an item at a specific index
            </summary>
            <param name="_index"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CSparseLeafBinaryTree`1.GetDepth(System.Int32)">
            <summary>
            Get the zero-based depth of a given index
            </summary>
            <param name="_index"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CSparseLeafBinaryTree`1.GetSizeForDepth(System.Int32)">
            <summary>
            Get the maximum number of elements that can be in a binary tree of a given
            depth. This is invariant to the actual instantiation of any specific tree.
            </summary>
            <param name="_depth">
            The tree-depth you want the maximum size (containing capacity) of
            </param>
            <returns>
            The maxiumum number of items that can be possibly stored in a tree of the given
            depth
            </returns>
        </member>
        <member name="M:Morpheus.CSparseLeafBinaryTree`1.GetMaxDepth">
            <summary>
            Returns the depth (zero-based) of deepest element in the tree.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CSparseLeafBinaryTree`1.Clone">
            <summary>
            Create a shallow copy of this binary tree
            </summary>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CSparseLeafBinaryTree`1.GetEnumerator">
            <summary>
            Get an enumeration of all elements in this binary tree in no particular order
            </summary>
            <returns>An IEnumerable of all items in this binary tree"/></returns>
        </member>
        <member name="M:Morpheus.CSparseLeafBinaryTree`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get an enumeration of all elements in this binary tree in no particular order
            </summary>
            <returns>An IEnumerable of all items in this binary tree"/></returns>
        </member>
        <member name="M:Morpheus.CSparseLeafBinaryTree`1.GetFillLevels">
            <summary>
            Return an IList of counts representing the number of elements found at each
            level of the tree
            </summary>
            <returns>
            An IList of counts representing the number of elements found at each level of
            the tree
            </returns>
        </member>
        <member name="T:Morpheus.CVector">
            <summary>
            Basic 2-d vector functionality
            </summary>
        </member>
        <member name="F:Morpheus.CVector.X">
            <summary>
            The 'X' coordinate
            </summary>
        </member>
        <member name="F:Morpheus.CVector.Y">
            <summary>
            The 'Y' coordinate
            </summary>
        </member>
        <member name="M:Morpheus.CVector.#ctor">
            <summary>
            Construct a (0,0) vector
            </summary>
        </member>
        <member name="M:Morpheus.CVector.#ctor(System.Double,System.Double)">
            <summary>
            Construct a vector with set X,Y
            </summary>
            <param name="_x">The 'X' coordinate</param>
            <param name="_y">The 'Y' coordinate</param>
        </member>
        <member name="M:Morpheus.CVector.#ctor(Morpheus.CVector)">
            <summary>
            Copy constructor from another 2d vector
            </summary>
            <param name="_other">The 2d vector to copy</param>
        </member>
        <member name="M:Morpheus.CVector.AreSame(Morpheus.CVector)">
            <summary>
            Is another vector the "same" as this vector? "Same" implies "really close", as opposed to "double==double"
            </summary>
            <param name="_other">The vector to compare to this one</param>
            <returns>TRUE if the X,Y values are "close"</returns>
        </member>
        <member name="P:Morpheus.CVector.LengthSquared">
            <summary>
            The Square of the Length of this vector- Also the dot-product of this vector and itself
            </summary>
        </member>
        <member name="P:Morpheus.CVector.Length">
            <summary>
            The Length of this vector (same as "Magnitude"). If Set, this vector's unit vector will be mulitplied by the new Length measure
            </summary>
        </member>
        <member name="P:Morpheus.CVector.Magnitude">
            <summary>
            The Magnitude of this vector (same as "Length")
            </summary>
        </member>
        <member name="M:Morpheus.CVector.DistanceSquared(Morpheus.CVector)">
            <summary>
            The square of the distance between this vector and another vector (assumed to be point vectors)
            </summary>
            <param name="_other">The other vector</param>
            <returns>The distance squared between this and another vector</returns>
        </member>
        <member name="M:Morpheus.CVector.Distance(Morpheus.CVector)">
            <summary>
            The distance between this vector and another vector (assumed to be point vectors)
            </summary>
            <param name="_other">The other vector</param>
            <returns>The distance between this and another vector</returns>
        </member>
        <member name="M:Morpheus.CVector.op_Addition(Morpheus.CVector,Morpheus.CVector)">
            <summary>
            Add two vectors together and get a new CVector
            </summary>
            <param name="_1">The left operand</param>
            <param name="_2">The right operand</param>
            <returns>A new CVector resulting from the sum of two vectors</returns>
        </member>
        <member name="M:Morpheus.CVector.op_Subtraction(Morpheus.CVector,Morpheus.CVector)">
            <summary>
            Subtract two vectors together and get a new CVector
            </summary>
            <param name="_1">The left operand</param>
            <param name="_2">The right operand</param>
            <returns>A new CVector resulting from subtracting a second vector from a first vector</returns>
        </member>
        <member name="M:Morpheus.CVector.op_Multiply(Morpheus.CVector,System.Double)">
            <summary>
            Multiply a vector by a scalar
            </summary>
            <param name="_vector">The vector operand</param>
            <param name="_scale">The scalar operand</param>
            <returns>A new vector containing the operand multiplied by the scalar value</returns>
        </member>
        <member name="M:Morpheus.CVector.op_Division(Morpheus.CVector,System.Double)">
            <summary>
            Divide a vector by a scalar
            </summary>
            <param name="_vector">The vector operand</param>
            <param name="_scale">The scalar operand</param>
            <returns>A new vector containing the operand divided by the scalar value</returns>
        </member>
        <member name="M:Morpheus.CVector.op_UnaryNegation(Morpheus.CVector)">
            <summary>
            Negate a vector
            </summary>
            <param name="_vector">The vector to negate</param>
            <returns>A new vector consisting of the negated vector</returns>
        </member>
        <member name="M:Morpheus.CVector.ToUnitVector">
            <summary>
            Create a new CVector that contains the unit vector for this vector
            </summary>
            <returns>A new unit vector</returns>
        </member>
        <member name="M:Morpheus.CVector.Add(Morpheus.CVector)">
            <summary>
            Add a vector to this vector, modifying this vector
            </summary>
            <param name="_other">The vector to add</param>
        </member>
        <member name="M:Morpheus.CVector.Subtract(Morpheus.CVector)">
            <summary>
            Subtract a vector from this vector, modifying this vector
            </summary>
            <param name="_other">The vector to subtract</param>
        </member>
        <member name="M:Morpheus.CVector.Multiply(System.Double)">
            <summary>
            Multiply this vector by a scalar value, modifying this vector
            </summary>
            <param name="_scale">The number to multiply this vector by</param>
        </member>
        <member name="M:Morpheus.CVector.Divide(System.Double)">
            <summary>
            Divide this vector by a scalar value, modifying this vector
            </summary>
            <param name="_scale">The number to divide this vector by</param>
        </member>
        <member name="M:Morpheus.CVector.Negate">
            <summary>
            Negate this vector
            </summary>
        </member>
        <member name="M:Morpheus.CVector.Normalize">
            <summary>
            Turn this vector into a unit vector
            </summary>
        </member>
        <member name="M:Morpheus.CVector.Dot(Morpheus.CVector)">
            <summary>
            Calculate the dot-product of this vector and another vector
            </summary>
            <param name="_other">The other vector</param>
            <returns>The dot-product, a scalar value</returns>
        </member>
        <member name="M:Morpheus.CVector.NormalizedDot(Morpheus.CVector)">
            <summary>
            Calculate the dot-product of this vector and another vector- Normalize both vectors first
            </summary>
            <param name="_other">The other vector</param>
            <returns>The dot-product, a scalar value</returns>
        </member>
        <member name="M:Morpheus.CVector.AreParallel(Morpheus.CVector)">
            <summary>
            Determine if this and another vector are parallel
            </summary>
            <param name="_other">The other vector</param>
            <returns>TRUE if the vectors are parallel</returns>
        </member>
        <member name="M:Morpheus.CVector.AreParallelOppositeDir(Morpheus.CVector)">
            <summary>
            Determine if this and another vector are parallel but pointing in opposite directions
            </summary>
            <param name="_other">The other vector</param>
            <returns>TRUE if the vectors are parallel but in opposite directions</returns>
        </member>
        <member name="M:Morpheus.CVector.AreParallelSameDir(Morpheus.CVector)">
            <summary>
            Determine if this and another vector are parallel and pointing in the same direction
            </summary>
            <param name="_other">The other vector</param>
            <returns>TRUE if the vectors are parallel and in the same direction</returns>
        </member>
        <member name="M:Morpheus.CVector.AreOrthogonal(Morpheus.CVector)">
            <summary>
            Determine if this and another vector are orthogonal- perpendicular
            </summary>
            <param name="_other">The other vector</param>
            <returns>TRUE if the vectors are orthogonal</returns>
        </member>
        <member name="M:Morpheus.CVector.AreObtuse(Morpheus.CVector)">
            <summary>
            Determine if this and another vector form obtuse angles with each other
            </summary>
            <param name="_other">The other vector</param>
            <returns>TRUE if the vectors are obtuse</returns>
        </member>
        <member name="M:Morpheus.CVector.AreAcute(Morpheus.CVector)">
            <summary>
            Determine if this and another vector form acute angles with each other
            </summary>
            <param name="_other">The other vector</param>
            <returns>TRUE if the vectors are acute</returns>
        </member>
        <member name="M:Morpheus.CVector.VectorFromRadians(System.Double)">
            <summary>
            Create a unit vector from an angle specified in radians
            </summary>
            <param name="_radians">The angle to create the unit vector from</param>
            <returns>A new CVector (unit) created from the angle specified</returns>
        </member>
        <member name="M:Morpheus.CVector.FromRadians(System.Double)">
            <summary>
            Make this CVector a unit vector from an angle specified in radians
            </summary>
            <param name="_radians">The angle to create the unit vector from</param>
        </member>
        <member name="M:Morpheus.CVector.ToRadians">
            <summary>
            Turn this vector (assumed to be based at (0,0)) into an angle measure.
            </summary>
            <returns>The radians (-PI to PI) for this vector</returns>
        </member>
        <member name="M:Morpheus.CVector.Intercept(System.Double,Morpheus.CVector,Morpheus.CVector,Morpheus.CVector@,System.Double@)">
            <summary>
            Determine if this (point) vector travelling at a specific speed can intersect a second (point) vector travelling at a given linear velocity
            </summary>
            <param name="_mySpeed">The speed at which this point can travel</param>
            <param name="_otherPosition">The position of the target point</param>
            <param name="_otherVelocity">The velocity of the target point</param>
            <param name="_interceptPosition">If interception is possible, the point of interception</param>
            <param name="_interceptTime">If interception is possible, the time of interception</param>
            <returns>The velocity vector that this point should use in order to intercept, or NULL if interception is not possible</returns>
        </member>
        <member name="M:Morpheus.CVector.ToString">
            <summary>
            Turn this vector into a string
            </summary>
            <returns>Turn this vector into a string</returns>
        </member>
        <member name="T:Morpheus.IMultiDimensionalPoint">
            <summary>
            If an object is to be stored in a KD Tree, it must be able to identify itself as a vector of coordinates. The object 
            either needs to implement this interface or the application needs to provide a "selector". If a selector
            is provided, it will override the object's implementation of IMultiDimensionalPoint.
            </summary>
            <remarks>
            Implementation of this interface should only be used for non-performance-sensitive applications. The KD tree performs
            significantly better when lambdas are provided for both the Selector and the DistanceFunction. 
            </remarks>
        </member>
        <member name="M:Morpheus.IMultiDimensionalPoint.GetAxisCount">
            <summary>
            Get the number of axes that the point is described in
            </summary>
            <returns>The number of axes that the point is described in</returns>
        </member>
        <member name="M:Morpheus.IMultiDimensionalPoint.GetAxisCoordinate(System.Int32)">
            <summary>
            For a given axis, return the coordinate for that axis
            </summary>
            <param name="_axis">The axis to look at</param>
            <returns>The coordinate for the point and that axis</returns>
        </member>
        <member name="M:Morpheus.IMultiDimensionalPoint.GetDistance(Morpheus.IMultiDimensionalPoint)">
            <summary>
            Return a scalar distance between this point and some other point
            </summary>
            <param name="_other">The other point</param>
            <returns>The scalar distance between the two points</returns>
        </member>
        <member name="T:Morpheus.SVector2d">
            <summary>
            An immutable 2d vector class implemented as a value-type and featuring a fluent API
            </summary>
        </member>
        <member name="F:Morpheus.SVector2d.NotAVector">
            <summary>
            Something that can be used to denote a value-type that is invalid. A reference
            type may use NULL, but a value type has to express this differently.
            </summary>
        </member>
        <member name="F:Morpheus.SVector2d.Zero">
            <summary>
            A zero-valued vector.
            </summary>
        </member>
        <member name="F:Morpheus.SVector2d.X">
            <summary>
            The 'X' coordinate
            </summary>
        </member>
        <member name="F:Morpheus.SVector2d.Y">
            <summary>
            The 'Y' coordinate
            </summary>
        </member>
        <member name="M:Morpheus.SVector2d.#ctor(System.Double,System.Double)">
            <summary>
            Construct a vector with set X,Y
            </summary>
            <param name="_x">The 'X' coordinate</param>
            <param name="_y">The 'Y' coordinate</param>
        </member>
        <member name="M:Morpheus.SVector2d.AreSame(Morpheus.SVector2d)">
            <summary>
            Is another vector the "same" as this vector? "Same" implies "really close", as
            opposed to "double==double"
            </summary>
            <param name="_other">The vector to compare to this one</param>
            <returns>TRUE if the X,Y values are "close"</returns>
        </member>
        <member name="P:Morpheus.SVector2d.IsAVector">
            <summary>
            This is a vector when both X and Y are not NaN and they are both not Infinity
            </summary>
        </member>
        <member name="P:Morpheus.SVector2d.IsZero">
            <summary>
            Return true when both X and Y are zero
            </summary>
        </member>
        <member name="P:Morpheus.SVector2d.LengthSquared">
            <summary>
            The Square of the Length of this vector- Also the dot-product of this vector and
            itself
            </summary>
        </member>
        <member name="P:Morpheus.SVector2d.Length">
            <summary>
            The Length of this vector (same as "Magnitude").
            </summary>
        </member>
        <member name="M:Morpheus.SVector2d.DistanceSquared(Morpheus.SVector2d)">
            <summary>
            The square of the distance between this vector and another vector (assumed to be
            point vectors)
            </summary>
            <param name="_other">The other vector</param>
            <returns>The distance squared between this and another vector</returns>
        </member>
        <member name="M:Morpheus.SVector2d.Distance(Morpheus.SVector2d)">
            <summary>
            The distance between this vector and another vector
            </summary>
            <param name="_other">The other vector</param>
            <returns>The distance between this and another vector</returns>
        </member>
        <member name="M:Morpheus.SVector2d.Dot(Morpheus.SVector2d)">
            <summary>
            Calculate the dot-product of this vector and another vector
            </summary>
            <param name="_other">The other vector</param>
            <returns>The dot-product, a scalar value</returns>
        </member>
        <member name="M:Morpheus.SVector2d.op_Addition(Morpheus.SVector2d,Morpheus.SVector2d)">
            <summary>
            Add two vectors together and get a new SVector2d
            </summary>
            <param name="_1">The left operand</param>
            <param name="_2">The right operand</param>
            <returns>A new SVector2d resulting from the sum of two vectors</returns>
        </member>
        <member name="M:Morpheus.SVector2d.AddTo(Morpheus.SVector2d)">
            <summary>
            Return a vector equal to this vector plus another vector
            </summary>
            <param name="_other">The vector to add to this one</param>
            <returns>A vector representing the sum of two vectors</returns>
        </member>
        <member name="M:Morpheus.SVector2d.op_Subtraction(Morpheus.SVector2d,Morpheus.SVector2d)">
            <summary>
            Subtract two vectors together and get a new SVector2d
            </summary>
            <param name="_1">The left operand</param>
            <param name="_2">The right operand</param>
            <returns>
            A new SVector2d resulting from subtracting a second vector from a first vector
            </returns>
        </member>
        <member name="M:Morpheus.SVector2d.PointTo(Morpheus.SVector2d)">
            <summary>
            Return a vector equal to another vector minus this vector
            </summary>
            <param name="_other">The vector to subtract this vector from</param>
            <returns>
            A vector pointing from "this" (a position vector) to another position vector.
            </returns>
        </member>
        <member name="M:Morpheus.SVector2d.op_Multiply(Morpheus.SVector2d,System.Double)">
            <summary>
            Multiply a vector by a scalar
            </summary>
            <param name="_vector">The vector operand</param>
            <param name="_scale">The scalar operand</param>
            <returns>
            A new vector containing the operand multiplied by the scalar value
            </returns>
        </member>
        <member name="M:Morpheus.SVector2d.ScaleBy(System.Double)">
            <summary>
            Scale this vector's magnitude by some amount.
            </summary>
            <param name="_scaleAmount">
            The amount to multiply this vector's X and Y values by, returning a new vector
            containing the result.
            </param>
            <returns>
            A new vector containing this vector's X and Y values multiplied by the scale
            amount
            </returns>
        </member>
        <member name="M:Morpheus.SVector2d.op_Division(Morpheus.SVector2d,System.Double)">
            <summary>
            Divide a vector by a scalar
            </summary>
            <param name="_vector">The vector operand</param>
            <param name="_scale">The scalar operand</param>
            <returns>
            A new vector containing the operand divided by the scalar value
            </returns>
        </member>
        <member name="M:Morpheus.SVector2d.op_UnaryNegation(Morpheus.SVector2d)">
            <summary>
            Negate a vector
            </summary>
            <param name="_vector">The vector to negate</param>
            <returns>A new vector consisting of the negated vector</returns>
        </member>
        <member name="M:Morpheus.SVector2d.Negate">
            <summary>
            Return a new vector which is this vector with both X and Y negated (multiplied
            by -1)
            </summary>
            <returns>
            A new vector which is this vector with both X and Y negated (multiplied by -1)
            </returns>
        </member>
        <member name="M:Morpheus.SVector2d.WithNewX(System.Double)">
            <summary>
            Return a new SVector2d that has a new X value and this vector's Y value.
            </summary>
            <param name="_newX">The new X value</param>
            <returns>
            A new SVector2d that has a new X value and this vector's Y value.
            </returns>
        </member>
        <member name="M:Morpheus.SVector2d.WithNewY(System.Double)">
            <summary>
            Return a new SVector2d that has a new Y value and this vector's X value.
            </summary>
            <param name="_newY">The new Y value</param>
            <returns>
            A new SVector2d that has a new Y value and this vector's X value.
            </returns>
        </member>
        <member name="M:Morpheus.SVector2d.WithNewLength(System.Double)">
            <summary>
            Change the Length (Magnitude) of this vector while keeping its direction the
            same
            </summary>
            <param name="_newLength">The new length</param>
            <returns>
            A new vector whose length is equal to the requested length, but whose direction
            hasn't changed.
            </returns>
        </member>
        <member name="M:Morpheus.SVector2d.WithNewDirection(System.Double)">
            <summary>
            Change the direction of the vector without changing its length/magnitude. If the
            length is currently zero, this will become a unit vector with the specified
            direction.
            </summary>
            <param name="_radians">The new direction for the vector</param>
            <returns>
            A new vector with Length equal to this vector, but direction equal to the
            radians. Alternately, this will return a unit vector if the currect vector is zero.
            </returns>
        </member>
        <member name="M:Morpheus.SVector2d.AsUnitVector">
            <summary>
            Create a new SVector2d that contains the unit vector for this vector
            </summary>
            <returns>A new unit vector</returns>
        </member>
        <member name="M:Morpheus.SVector2d.NormalizedDot(Morpheus.SVector2d)">
            <summary>
            Calculate the dot-product of this vector and another vector. This is also equal
            to the cosine of the angle between the two vectors.
            </summary>
            <param name="_other">The other vector</param>
            <returns>The normalized dot-product, a scalar value</returns>
        </member>
        <member name="M:Morpheus.SVector2d.CosineOfAngleBetween(Morpheus.SVector2d)">
            <summary>
            Calculate the dot-product of this vector and another vector. This is also equal
            to the cosine of the angle between the two vectors.
            </summary>
            <param name="_other">The other vector</param>
            <returns>The normalized dot-product, a scalar value</returns>
        </member>
        <member name="M:Morpheus.SVector2d.AreParallel(Morpheus.SVector2d)">
            <summary>
            Determine if this and another vector are parallel
            </summary>
            <param name="_other">The other vector</param>
            <returns>TRUE if the vectors are parallel</returns>
        </member>
        <member name="M:Morpheus.SVector2d.AreParallelOppositeDir(Morpheus.SVector2d)">
            <summary>
            Determine if this and another vector are parallel but pointing in opposite
            directions
            </summary>
            <param name="_other">The other vector</param>
            <returns>TRUE if the vectors are parallel but in opposite directions</returns>
        </member>
        <member name="M:Morpheus.SVector2d.AreParallelSameDir(Morpheus.SVector2d)">
            <summary>
            Determine if this and another vector are parallel and pointing in the same
            direction
            </summary>
            <param name="_other">The other vector</param>
            <returns>TRUE if the vectors are parallel and in the same direction</returns>
        </member>
        <member name="M:Morpheus.SVector2d.AreOrthogonal(Morpheus.SVector2d)">
            <summary>
            Determine if this and another vector are orthogonal- perpendicular
            </summary>
            <param name="_other">The other vector</param>
            <returns>TRUE if the vectors are orthogonal</returns>
        </member>
        <member name="M:Morpheus.SVector2d.AreObtuse(Morpheus.SVector2d)">
            <summary>
            Determine if this and another vector form obtuse angles with each other
            </summary>
            <param name="_other">The other vector</param>
            <returns>TRUE if the vectors are obtuse</returns>
        </member>
        <member name="M:Morpheus.SVector2d.AreAcute(Morpheus.SVector2d)">
            <summary>
            Determine if this and another vector form acute angles with each other
            </summary>
            <param name="_other">The other vector</param>
            <returns>TRUE if the vectors are acute</returns>
        </member>
        <member name="M:Morpheus.SVector2d.ClockDirection(Morpheus.SVector2d)">
            <summary>
            Determine which "clock direction" (e.g. clockwise or counter-clockwise) the
            other vector is from this vector, assuming both are "rooted" at (0,0)
            </summary>
            <remarks>
            This is basically the calculation for the determinant of the two vectors.
            </remarks>
            <param name="_other">The other vector</param>
            <returns>-1: Clockwise, 1: CounterClockwise, 0: Colinear</returns>
        </member>
        <member name="M:Morpheus.SVector2d.VectorFromRadians(System.Double)">
            <summary>
            Create a unit vector from an angle specified in radians
            </summary>
            <param name="_radians">The angle to create the unit vector from</param>
            <returns>A new SVector2d (unit) created from the angle specified</returns>
        </member>
        <member name="M:Morpheus.SVector2d.ToRadians">
            <summary>
            Turn this vector (assumed to be based at (0,0)) into an angle measure.
            </summary>
            <returns>The radians (-PI to PI) for this vector</returns>
        </member>
        <member name="M:Morpheus.SVector2d.Intercept(Morpheus.SVector2d,System.Double,Morpheus.SVector2d,Morpheus.SVector2d,Morpheus.SVector2d@,System.Double@)">
            <summary>
            Determine if this (point) vector travelling at a specific speed can intersect a
            second (point) vector travelling at a given linear velocity 
            </summary>
            <param name="_myPosition">The position of "me"</param>
            <param name="_mySpeed">The speed at which this point can travel</param>
            <param name="_otherPosition">The position of the target point</param>
            <param name="_otherVelocity">The velocity of the target point</param>
            <param name="_interceptPosition">
            If interception is possible, the point of interception
            </param>
            <param name="_interceptTime">
            If interception is possible, the time of interception
            </param>
            <returns>
            The velocity vector that this point should use in order to intercept, or
            <see cref="F:Morpheus.SVector2d.NotAVector"/> if interception is not possible
            </returns>
        </member>
        <member name="M:Morpheus.SVector2d.ToString">
            <summary>
            Turn this vector into a string
            </summary>
            <returns>Turn this vector into a string</returns>
        </member>
        <member name="T:Morpheus.AEventHandler">
            <summary>
            By placing this attribute on a class, that class can be automatically searched for
            event handlers. By placing this on a method, that method can be found using
            reflection and registered as an event handler for a specified event type.
            </summary>
        </member>
        <member name="F:Morpheus.AEventHandler.EventType">
            <summary>
            The Type of the event to be handled by the event handler. Must "agree" with the
            first parameter of the method, if there is one. If present, this Type is what is
            registered for with the Dispatcher, not the Type of the first method parameter.
            </summary>
        </member>
        <member name="F:Morpheus.AEventHandler.Value">
            <summary>
            When set to a non-null value, only events that are equal to this value will be
            dispatched to the handler. This is a <see cref="M:System.Object.Equals(System.Object,System.Object)"/>
            comparison, not a reference equality test.
            </summary>
        </member>
        <member name="F:Morpheus.AEventHandler.DispatchMode">
            <summary>
            How the event should be dispatched (inline, batch, threadpool). If set to
            <see cref="F:Morpheus.EDispatchMode.NotAssigned"/> , other defaults are used.
            </summary>
        </member>
        <member name="F:Morpheus.AEventHandler.Description">
            <summary>
            A description of the handler. Maybe used for diagnostics
            </summary>
        </member>
        <member name="T:Morpheus.CEventDispatcher">
            <summary>
            This class will handle the dispatch of "events" to registered handlers. "Events" are
            merely objects of any type.
            
            There is NO guarantee of execution of events. A power-lost state, premature disposal
            of this object, or any number of other edge cases can cause events not to get
            executed. However, this class will never knowingly and/or purposefully discard an
            event.
            </summary>
            <remarks>
            Features: * Handler Execution Context- Application may select inline, threadpool or
            batched execution of event handlers. * Handler Discovery- The dispatcher class can
            use reflection to search the loaded assemblies for event handlers, using a
            combination of attributes and method signatures to find message handlers. *
            Mix-and-Match- This class can handle any combination of the above mentioned features
            
            The handler registration process has the option (not obligation) to specifiy which
            dispatch mode (inline, batch, threadpool) to use. This election (at registration
            time) has the highest priority. When not set explicitly at registration time, the
            parameter specified in the Post method call will be used. If no mode is explicitly
            set in the Post method call parameters, then the mode specified by the
            <see cref="P:Morpheus.CEventDispatcher.DefaultDispatchMode"/> property of the Dispatcher will be used.
            
            In most if not all cases, long running event handlers should be registered for the
            ThreadPool dispatch mode. This makes sure that the "main thread" (game thread,
            apartment thread, etc) is not affected significantly. However, this may not be
            possible if the event handler must share the same thread as a UI thread, as is the
            case with WinForms, Unity, etc. In these cases, batching may help, but can still
            delay program execution for poorly written or long-running event handlers.
            
            It is perfectly acceptable to register an event handler that must perform a
            round-trip to an internet server on a threadpool thread. Async completion of that
            Internet-based IO is still preferred (there are only a set number of possible
            simultaneously executing threadpool threads). Another option for threadpool
            registration is an event that must perform disk IO.
            
            Exception Handling: The Dispatcher operates under the assumption that event handling
            is not critical, and should not be depended on for altering control flow of the
            application. To this effect, exceptions thrown within an event handler have a single
            chance to be "handled" by the application. By registering a Handler for the
            CEventException event, the application can look at the Event, the Handler and the
            Exception to try to recover and/or fix the issue. However, any further exception
            thrown within the handler for the CEventException will be dropped unceremoniously.
            In other words- Exceptions in Event Handlers will be Posted as a CEventException
            UNLESS the Event itself was already a CEventException, in which case its lost.
            </remarks>
        </member>
        <member name="P:Morpheus.CEventDispatcher.SyncObject">
            <summary>
            The sync object for the dispatcher
            </summary>
        </member>
        <member name="F:Morpheus.CEventDispatcher.m_handlersForTypes">
            <summary>
            The main database of how events are to be dispatched
            </summary>
        </member>
        <member name="P:Morpheus.CEventDispatcher.DefaultDispatchMode">
            <summary>
            When nothing has been explicitly specified, use this dispatch mode for all event
            dispatching.
            </summary>
        </member>
        <member name="F:Morpheus.CEventDispatcher.m_batch">
            <summary>
            A queue of event+handler objects that is to be executed by the next Batch
            Execution operation
            </summary>
        </member>
        <member name="F:Morpheus.CEventDispatcher.m_inlineQueue">
            <summary>
            A queue for inline handler executions. This is a field (instead of using
            automatic storage) because there's no reason to GC this after every Post
            operation.
            </summary>
        </member>
        <member name="F:Morpheus.CEventDispatcher.m_outstandingThreadpoolItems">
            <summary>
            The number of event+handler entries that are outstanding in the ThreadPool
            </summary>
        </member>
        <member name="P:Morpheus.CEventDispatcher.EventExecutionCount">
            <summary>
            The number of events that have been executed by the dispatcher in any of the
            modes
            </summary>
        </member>
        <member name="M:Morpheus.CEventDispatcher.ResetExecutionCount">
            <summary>
            Set the EventExecutionCount to zero
            </summary>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CEventDispatcher.IncrementEventCount">
            <summary>
            Internal method to update the number of events executed. Should really only be
            called by the CEventHandler class.
            </summary>
        </member>
        <member name="M:Morpheus.CEventDispatcher.IncrementThreadpoolItems">
            <summary>
            Private method used by threadpool execution to signal that an item has
            completed.
            </summary>
        </member>
        <member name="M:Morpheus.CEventDispatcher.DecrementThreadpoolItems">
            <summary>
            Internal method used by threadpool execution to signal that an item has
            completed.
            </summary>
        </member>
        <member name="M:Morpheus.CEventDispatcher.HasPendingEvents">
            <summary>
            Returns TRUE if there are outstanding events to be handled by either the
            threadpool or the batch.
            </summary>
        </member>
        <member name="M:Morpheus.CEventDispatcher.RegisterHandler``1(System.Action{``0,Morpheus.CEventHandler},Morpheus.EDispatchMode)">
            <summary>
            Register a handler for a given event type. The handler will be in the form of a
            lambda or delegate.
            </summary>
            <typeparam name="TEvent">The Type of event to handle</typeparam>
            <param name="_handler">The delegate/lambda to be called with the event.</param>
            <param name="_dispatchMode">
            The DispatchMode for events of this Type. This value, if set, will override all
            other mode selections.
            </param>
            <returns>Returns the handler object for this event and handler</returns>
        </member>
        <member name="M:Morpheus.CEventDispatcher.RegisterHandler``1(System.Action{``0},Morpheus.EDispatchMode)">
            <summary>
            Register a handler for a given event type. The handler will be in the form of a
            lambda or delegate.
            </summary>
            <typeparam name="TEvent">The Type of event to handle</typeparam>
            <param name="_handler">The delegate/lambda to be called with the event.</param>
            <param name="_dispatchMode">
            The DispatchMode for events of this Type. This value, if set, will override all
            other mode selections.
            </param>
            <returns>Returns the handler object for this event and handler</returns>
        </member>
        <member name="M:Morpheus.CEventDispatcher.RegisterHandler``1(System.Action,Morpheus.EDispatchMode)">
            <summary>
            Register a handler for a given event type. The handler will be in the form of a
            lambda or delegate that takes no parameters.
            </summary>
            <typeparam name="TEvent">The Type of event to handle</typeparam>
            <param name="_handler">The handler, which takes zero parameters</param>
            <param name="_dispatchMode">
            The DispatchMode for events of this Type. This value, if set, will override all
            other mode selections.
            </param>
            <returns>Returns the handler object for this event and handler</returns>
        </member>
        <member name="M:Morpheus.CEventDispatcher.RegisterHandler``2(System.Action{``0,``1},Morpheus.EDispatchMode)">
            <summary>
            Register a handler for a given event type. The handler will be in the form of a
            lambda or delegate.
            </summary>
            <typeparam name="TEvent">The Type of event to handle</typeparam>
            <typeparam name="TDispatcher">The exact Type of the Dispatcher</typeparam>
            <param name="_handler">The delegate/lambda to be called with the event.</param>
            <param name="_dispatchMode">
            The DispatchMode for events of this Type. This value, if set, will override all
            other mode selections.
            </param>
            <returns>Returns the handler object for this event and handler</returns>
        </member>
        <member name="M:Morpheus.CEventDispatcher.RegisterHandler(System.Object,System.Action{Morpheus.CEventHandler},Morpheus.EDispatchMode)">
            <summary>
            Register a handler for an event of a specific value, as opposed to an event of a
            particular type.
            </summary>
            <remarks>
            When registering for a specific value, the dispatcher assumes that the handler
            knows about the value its expecting. Therefore, there's no override to pass the
            "event value" into the handler. If its important for the handler know the actual
            event value, the override to use would be the one for Action(CEventHandler), as
            the <see cref="P:Morpheus.CEventHandler.SpecificValueFilter"/> will contain the exact value
            of the event used to trigger the handler. It will also contain the
            <see cref="T:Morpheus.CEventDispatcher"/> reference, but not the convenience of a strongly
            typed Dispatcher.
            </remarks>
            <param name="_specificValue">The specific value to handle</param>
            <param name="_handler">
            The handler, accepting a TDispatcher (a subclass of
            <see cref="T:Morpheus.CEventDispatcher"/> ) as the only parameter
            </param>
            <param name="_dispatchMode">
            The DispatchMode for events of this Type. This value, if set, will override all
            other mode selections.
            </param>
            <returns>Returns the handler object for this event and handler</returns>
        </member>
        <member name="M:Morpheus.CEventDispatcher.RegisterHandler``1(System.Object,System.Action{``0},Morpheus.EDispatchMode)">
            <summary>
            Register a handler for an event of a specific value, as opposed to an event of a
            particular type.
            </summary>
            <remarks>
            When registering for a specific value, the dispatcher assumes that the handler
            knows about the value its expecting. Therefore, there's no override to pass the
            "event value" into the handler. If its important for the handler know the actual
            event value, the override to use would be the one for Action(CEventHandler), as
            the <see cref="P:Morpheus.CEventHandler.SpecificValueFilter"/> will contain the exact value
            of the event used to trigger the handler. It will also contain the
            <see cref="T:Morpheus.CEventDispatcher"/> reference, but not the convenience of a strongly
            typed Dispatcher.
            </remarks>
            <typeparam name="TDispatcher">
            The exact Type of the dispatcher object sent to the handler
            </typeparam>
            <param name="_specificValue">The specific value to handle</param>
            <param name="_handler">
            The handler, accepting a TDispatcher (a subclass of
            <see cref="T:Morpheus.CEventDispatcher"/> ) as the only parameter
            </param>
            <param name="_dispatchMode">
            The DispatchMode for events of this Type. This value, if set, will override all
            other mode selections.
            </param>
            <returns>Returns the handler object for this event and handler</returns>
        </member>
        <member name="M:Morpheus.CEventDispatcher.RegisterHandler(System.Object,System.Action,Morpheus.EDispatchMode)">
            <summary>
            Register a handler for an event of a specific value, as opposed to an event of a
            particular type.
            </summary>
            <remarks>
            When registering for a specific value, the dispatcher assumes that the handler
            knows about the value its expecting. Therefore, there's no override to pass the
            "event value" into the handler. If its important for the handler know the actual
            event value, the override to use would be the one for Action(CEventHandler), as
            the <see cref="P:Morpheus.CEventHandler.SpecificValueFilter"/> will contain the exact value
            of the event used to trigger the handler. It will also contain the
            <see cref="T:Morpheus.CEventDispatcher"/> reference, but not the convenience of a strongly
            typed Dispatcher.
            </remarks>
            <param name="_specificValue">The specific value to handle</param>
            <param name="_handler">
            The handler, accepting no parameters for this version of the method
            </param>
            <param name="_dispatchMode">
            The DispatchMode for events of this Type. This value, if set, will override all
            other mode selections.
            </param>
            <returns>Returns the handler object for this event and handler</returns>
        </member>
        <member name="M:Morpheus.CEventDispatcher.DeregisterHandler(Morpheus.CEventHandler)">
            <summary>
            Given a <see cref="T:Morpheus.CEventHandler"/> , remove it from the list of handlers.
            </summary>
            <param name="_handler">The handler to remove</param>
            <returns>TRUE if the handler was removed, FALSE if not</returns>
        </member>
        <member name="M:Morpheus.CEventDispatcher.DeregisterHandlerObject(System.Object)">
            <summary>
            Given an object presumably registered using CEventHandlerDiscovery, remove all
            handlers associated with that object.
            </summary>
            <param name="_object">The object whose methods need to be deregistered</param>
            <returns>TRUE if any handlers were removed, FALSE if not</returns>
        </member>
        <member name="M:Morpheus.CEventDispatcher.AddHandlerToDatabase(System.Type,Morpheus.CEventHandler)">
            <summary>
            Add a handler for a given type to the handler database in a threadsafe manner
            </summary>
            <param name="_type">The Type of events to hande with this handler</param>
            <param name="_handler">The Handler to give events of type _type to</param>
        </member>
        <member name="M:Morpheus.CEventDispatcher.Post(System.Object,Morpheus.EDispatchMode)">
            <summary>
            Post a specific event.
            </summary>
            <param name="_event">The Event to dispatch</param>
            <param name="_dispatchMode">
            The thread method which to dispatch the events. If the handler(s) have
            explicitly set a dispatch thread, then that will override this parameter.
            </param>
        </member>
        <member name="M:Morpheus.CEventDispatcher.QueueHandlersForType(System.Type,System.Object,Morpheus.EDispatchMode)">
            <summary>
            Given an Event and a System.Type, figure out how all handlers for that Type need
            to be queued for execution.
            </summary>
            <param name="_type">The Type to look for</param>
            <param name="_event">The Event to handle</param>
            <param name="_dispatchMode">The method used for dispatching handlers</param>
        </member>
        <member name="M:Morpheus.CEventDispatcher.GetEventExecutionInstance(System.Object,Morpheus.CEventHandler)">
            <summary>
            Allow a derived class to return a different kind of EventExecutionInstance, so
            long as its base class is still <see cref="T:Morpheus.CEventExecutionInstance"/>
            </summary>
            <param name="_event">The Event that needs to be executed</param>
            <param name="_handler">The Handler for the event</param>
            <returns>
            A new object that can be used to encapsulate the need to execute an event on a
            handler
            </returns>
        </member>
        <member name="M:Morpheus.CEventDispatcher.QueueForThreadpool(Morpheus.CEventExecutionInstance)">
            <summary>
            Given an event and a handler, queue a new UserWorkItem on the ThreadPool for the
            app domain.
            </summary>
            <param name="_eei">The event execution instance for the event</param>
        </member>
        <member name="M:Morpheus.CEventDispatcher.ExecuteInlineQueue">
            <summary>
            Execute all handlers in the "inline" queue. This queue is an internal structure
            to this class, so this method should never be called from outside this class
            (more specifically, the Post method)
            </summary>
        </member>
        <member name="M:Morpheus.CEventDispatcher.ExecuteBatch(System.Int32)">
            <summary>
            Execute all handlers that are in the batch, so long as the timeout hasn't
            occurred.
            </summary>
            <remarks>
            The purpose of the timeout is to somewhat limit how long processing is dedicated
            to handling events. Envisioned is the scenario where a game loop wants to
            dedicate a certain number of milliseconds per frame to event handling.
            
            All handlers are handled "atomically" with regard to the timeout. No handler
            will be interrupted mid-execution. The timeout determines solely if ANOTHER
            handler can be called within this method invocation.
            
            The timeout should not give the impression that the application can have
            long-running event handlers with no repurcussions. For instance, if an event
            handler takes 5 seconds to execute, no possible value of _timeout will prevent
            that 5 seconds from being consumed by the handler.
            </remarks>
            <param name="_timeout">
            An optional timeout parameter, specified in milliseconds. If 0 (zero) is
            specified, exactly one batch item will be executed. If -1 is specified, all
            outstanding items in the Batch will be executed, even if more are added while
            this method is executing.
            </param>
            <returns>
            The number of event handlers that were executed by this method invocation
            </returns>
        </member>
        <member name="M:Morpheus.CEventDispatcher.TrySafeDequeue(System.Collections.Generic.Queue{Morpheus.CEventExecutionInstance})">
            <summary>
            Dequeue an item from the Batch queue, if one exists. The operation needs to be
            threadsafe.
            </summary>
            <returns>The next item in the batch, or NULL if the batch is empty</returns>
        </member>
        <member name="M:Morpheus.CEventDispatcher.GetAllHandlers">
            <summary>
            Get an enumeration of all handlers known by the dispatcher.
            </summary>
            <returns>
            A list (snapshot) of all handlers that the dispatcher had registered when this
            method was called.
            </returns>
        </member>
        <member name="T:Morpheus.CEventException">
            <summary>
            An exception was thrown by an event handler. Post that exception as an event for possible application handling
            </summary>
        </member>
        <member name="P:Morpheus.CEventException.Event">
            <summary>
            The Event object that was being handled
            </summary>
        </member>
        <member name="P:Morpheus.CEventException.Handler">
            <summary>
            The handler instance that was handing the event
            </summary>
        </member>
        <member name="P:Morpheus.CEventException.Exception">
            <summary>
            The exception that was thrown by the handler
            </summary>
        </member>
        <member name="M:Morpheus.CEventException.ToString">
            <summary>
            Try to provide a description of the event.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Morpheus.CEventExecutionInstance">
            <summary>
            This class should contain all information about the execution of one event handler
            for one event. It handles all statistics (performance counters), exception handling,
            etc.
            </summary>
        </member>
        <member name="P:Morpheus.CEventExecutionInstance.TimeQueued">
            <summary>
            The time that the event execution instance was created / queued
            </summary>
        </member>
        <member name="P:Morpheus.CEventExecutionInstance.TimeExecutionStarted">
            <summary>
            The time that the event execution was started
            </summary>
        </member>
        <member name="P:Morpheus.CEventExecutionInstance.TimeExecutionEnded">
            <summary>
            The time that the event execution was completed
            </summary>
        </member>
        <member name="F:Morpheus.CEventExecutionInstance.Handler">
            <summary>
            The Handler for the event
            </summary>
        </member>
        <member name="F:Morpheus.CEventExecutionInstance.Event">
            <summary>
            The Event to be handled
            </summary>
        </member>
        <member name="M:Morpheus.CEventExecutionInstance.#ctor(Morpheus.CEventHandler,System.Object)">
            <summary>
            Construct with the handler and the event
            </summary>
            <param name="_handler">The handler object to be used for this event</param>
            <param name="_event">The event to be handled</param>
        </member>
        <member name="M:Morpheus.CEventExecutionInstance.HandleEvent">
            <summary>
            This is the mechanism by which all events should be handled, as it takes care of
            accounting and exception handling. The "CEventHandler.HandleEvent" method should
            never be called except by this routine.
            
            If this routine is overridden in a derived class, it is strongly suggested that
            it should call base.HandleEvent() to gain the functionality from this method.
            </summary>
        </member>
        <member name="T:Morpheus.CEventHandler">
            <summary>
            This class encapsulates information about an event handler. These handlers are specified by the application.
            Typically, these will be either a lambda/delegate or a method discovered through attributes and signature convention.
            This class also takes care of statistics (performance counters) for event handling.
            Each instance of this class corresponds to exactly one method-event pair. There is a one-to-many relationship between
            the handler and the event, in that an event may be associated with zero or more handlers, but a handler will always be
            associated with exactly one event.
            </summary>
        </member>
        <member name="P:Morpheus.CEventHandler.EventType">
            <summary>
            The <see cref="T:System.Type"/> of the event to handle.
            </summary>
        </member>
        <member name="P:Morpheus.CEventHandler.Dispatcher">
            <summary>
            The <see cref="T:Morpheus.CEventDispatcher"/> that this handler is associated with
            </summary>
        </member>
        <member name="P:Morpheus.CEventHandler.DispatchMode">
            <summary>
            The DispatchMode for this handler. May be EDispatchMode.NotAssigned.
            </summary>
        </member>
        <member name="P:Morpheus.CEventHandler.SpecificValueFilter">
            <summary>
            Only call the handler when the event matches this specific value. If NULL, do not use specific value checking.
            </summary>
        </member>
        <member name="F:Morpheus.CEventHandler.Description">
            <summary>
            Can be set by the application to describe the handler- Can be any string value.
            </summary>
        </member>
        <member name="M:Morpheus.CEventHandler.#ctor(System.Type,Morpheus.CEventDispatcher,Morpheus.EDispatchMode)">
            <summary>
            Construct the handler information
            </summary>
            <param name="_eventType">The Type to handle</param>
            <param name="_dispatcher">The Dispatcher that created this handler</param>
            <param name="_dispatchMode">The DispatchMode for this event- This value, if set, will override all other mode settings.</param>
        </member>
        <member name="M:Morpheus.CEventHandler.HandleEvent(System.Object)">
            <summary>
            Handle the event. This method should never be called except from within <see cref="T:Morpheus.CEventExecutionInstance"/>
            </summary>
            <param name="_event">The event to handle</param>
        </member>
        <member name="T:Morpheus.CEventHandlerDiscovery">
            <summary>
            Helper class that uses Reflection to find methods suitable for Event Dispatch using the
            <see cref="T:Morpheus.CEventDispatcher"/> .
            </summary>
            <remarks>
            An event handler that deals with Types can be any method that takes zero, one or two
            parameters, as follows:
            
            0 params: The AEventHandler MUST specifiy the EventType for the handler. Nothing will be
            sent to the handler when the event is handled.
            
            1 param: The handler will receive one parameter, which is the event itself. No other
            context will be sent to the handler.
            
            2 params: The first param is the event. The second param is either a CEventHandler
            context or a CEventDispatcher (or subclass) context. In this case, the discovery will
            figure out what to send the handler, including figuring out if a subclass of the
            CEventDispatcher is appropriate. This allows the application to inherit
            CEventDispatcher, place application-specific information in the subclass, then have that
            context-full dispatcher sent to static functions (or instance functions, but arguably
            less useful)
            
            An event handler that deals with a specific Value can only receive one parameter. This
            is either a <see cref="T:Morpheus.CEventHandler"/> or something that can be cast to a
            <see cref="T:Morpheus.CEventDispatcher"/> . The event's value will not be sent as a parameter
            because that method can discover that value via the CEventHandler object, if it really
            needs it.
            </remarks>
        </member>
        <member name="F:Morpheus.CEventHandlerDiscovery.m_dispatcher">
            <summary>
            The dispatcher uesd with this discovery object
            </summary>
        </member>
        <member name="M:Morpheus.CEventHandlerDiscovery.#ctor(Morpheus.CEventDispatcher)">
            <summary>
            Must be constructed with a Dispatcher to use as target for handler registration
            </summary>
            <param name="_dispatcher">
            The dispatcher that will be used to register (and de-register) handlers
            </param>
        </member>
        <member name="F:Morpheus.CEventHandlerDiscovery.DispatchMode">
            <summary>
            Set this before calling RegisterHandlers to have all handlers registered using this
            dispatch mode IFF the <see cref="T:Morpheus.AEventHandler"/> attribute doesn't contain a
            different EDispatchMode
            </summary>
        </member>
        <member name="M:Morpheus.CEventHandlerDiscovery.RegisterHandlers">
            <summary>
            Register all event handlers for the calling assembly by looking for the
            AEventHandler attribute on a class and also on a method. This only works with static
            methods.
            </summary>
            <remarks>
            This method first looks for a class that has the <see cref="T:Morpheus.AEventHandler"/>
            attribute. This signals that there may be methods within this class that also
            contain event handlers. The class (Type) is then searched for methods that have the
            <see cref="T:Morpheus.AEventHandler"/> attribute.
            </remarks>
            <returns>A list of Event Handlers that were found</returns>
        </member>
        <member name="M:Morpheus.CEventHandlerDiscovery.RegisterHandlers(System.Reflection.Assembly)">
            <summary>
            Register all event handlers in the specified assembly by looking for the
            AEventHandler attribute on a class and also on a method. This only works with static
            methods.
            </summary>
            <remarks>
            This method first looks for a class that has the <see cref="T:Morpheus.AEventHandler"/>
            attribute. This signals that there may be methods within this class that also
            contain event handlers. The class (Type) is then searched for methods that have the
            <see cref="T:Morpheus.AEventHandler"/> attribute.
            </remarks>
            <param name="_assembly">
            The assembly to search for the AEventHandler attribute
            </param>
            <returns>A list of Event Handlers that were found</returns>
        </member>
        <member name="M:Morpheus.CEventHandlerDiscovery.RegisterHandlers(System.Type)">
            <summary>
            Register all event handlers in the specified Type by looking for the AEventHandler
            attribute on all static methods.
            </summary>
            <remarks>
            This method first looks for a method that has the <see cref="T:Morpheus.AEventHandler"/>
            attribute. When it finds one, it registers that static method as a handler for
            events matching the Type of the first parameter.
            </remarks>
            <param name="_type">The Type to search for the AEventHandler attribute</param>
            <returns>A list of Event Handlers that were found</returns>
        </member>
        <member name="M:Morpheus.CEventHandlerDiscovery.RegisterInstanceHandlers(System.Object)">
            <summary>
            Register all event handlers in the specified object by looking for the AEventHandler
            attribute on all instance methods.
            </summary>
            <remarks>
            This method first looks for an instance method that has the
            <see cref="T:Morpheus.AEventHandler"/> attribute. When it finds one, it registers that method
            as a handler for events matching the Type of the first parameter.
            </remarks>
            <param name="_instanceHandlers">
            An object that should have instance methods with the AEventHandler attribute
            </param>
            <returns>A list of Event Handlers that were found</returns>
        </member>
        <member name="M:Morpheus.CEventHandlerDiscovery.RegisterHandlers(System.Type,System.Object)">
            <summary>
            Register all event handlers in the specified Type by looking for the AEventHandler
            attribute on all methods. Static methods will be searched when _object is null.
            </summary>
            <remarks>
            This method first looks for a method that has the <see cref="T:Morpheus.AEventHandler"/>
            attribute. When it finds one, it registers that static method as a handler for
            events matching the Type of the first parameter.
            </remarks>
            <param name="_type">The Type to search for the AEventHandler attribute</param>
            <param name="_object">
            The object to reference when invoking the MethodInfo object
            </param>
            <returns>A list of Event Handlers that were found</returns>
        </member>
        <member name="M:Morpheus.CEventHandlerDiscovery.RegisterHandler(System.Reflection.MethodInfo,Morpheus.AEventHandler,System.Object)">
            <summary>
            Given a method and an AEventHandler attribute, figure out how to create a handler
            out of the method.
            </summary>
            <param name="_methodInfo">
            The <see cref="T:System.Reflection.MethodInfo"/> information for the method
            </param>
            <param name="_attribute">
            The AEventHandler attribute that may contain information about how to handle events
            </param>
            <param name="_object">
            The object (context) to use with the MethodInfo invocation, or NULL if its a static
            method
            </param>
            <returns>
            The CEventHandler object for the new handler. This is registered with the Dispatcher
            before its returned.
            </returns>
        </member>
        <member name="T:Morpheus.EventDispatcher.CEventHandler_LambdaDispatcherOnly`1">
            <summary>
            A specific-value handler that receives a type-correct <see cref="T:Morpheus.CEventDispatcher"/>
            parameter. The Type of the event is inferred from the _specficValue parameter.
            </summary>
            <remarks>
            If the handler needs to receive the actual event (because maybe its assigned to
            different values), it needs to use <see cref="T:Morpheus.EventDispatcher.CEventHandler_LambdaHandlerOnly"/> .
            The <see cref="T:Morpheus.CEventHandler"/> object sent to that handler will contain the value
            that triggered the handler's execution.
            </remarks>
            <typeparam name="TDispatcher">
            The specific Type of the dispatcher to send as a parameter.
            </typeparam>
        </member>
        <member name="T:Morpheus.EventDispatcher.CEventHandler_LambdaEventDispatcher`2">
            <summary>
            An event handler specified by a Lambda function. The handler must accept a
            <see cref="T:Morpheus.CEventDispatcher"/> as the second parameter
            </summary>
        </member>
        <member name="T:Morpheus.EventDispatcher.CEventHandler_LambdaEventHandler`1">
            <summary>
            An event handler specified by a Lambda function. The handler must accept a <see cref="T:Morpheus.CEventHandler"/>
            as the second parameter
            </summary>
        </member>
        <member name="T:Morpheus.EventDispatcher.CEventHandler_LambdaEventOnly`1">
            <summary>
            An event handler specified by a Lambda function. The handler must accept only the Event as the first parameter
            </summary>
        </member>
        <member name="T:Morpheus.EventDispatcher.CEventHandler_LambdaHandlerOnly">
            <summary>
            Handle the case where the lambda event handler receives a CEventHandler only
            </summary>
        </member>
        <member name="T:Morpheus.EventDispatcher.CEventHandler_LambdaNoParams`1">
            <summary>
            An event handler specified by a Lambda function. This version works to filter events by event type. The handler accepts zero parameters.
            </summary>
        </member>
        <member name="T:Morpheus.EventDispatcher.CEventHandler_LambdaNoParams">
            <summary>
            An event handler specified by a Lambda function. This version works to filter events by specific value. The handler accepts zero parameters.
            </summary>
        </member>
        <member name="T:Morpheus.EventDispatcher.CEventHandler_Reflection">
            <summary>
            This class will handle an event that was registered using CEventHandlerDiscovery. It
            is not strongly typed to the event that is to be handled.
            
            This class will allow the association of a handler that accepts a subclass of the
            specified event as its first (and possibly only) parameter.
            </summary>
        </member>
        <member name="P:Morpheus.EventDispatcher.CEventHandler_Reflection.Object">
            <summary>
            The object that provides context to non-static methods
            </summary>
        </member>
        <member name="M:Morpheus.EventDispatcher.CEventHandler_Reflection.#ctor(Morpheus.CEventDispatcher,Morpheus.EDispatchMode)">
            <summary>
            Create a Reflection-based handler given the minimum requirements. Use other
            methods to finish populating this object
            </summary>
            <param name="_dispatcher">
            The Dispatcher that this handler is associated with
            </param>
            <param name="_dispatchMode">The EDispatchMode for this handler</param>
        </member>
        <member name="M:Morpheus.EventDispatcher.CEventHandler_Reflection.ProcessMethodInfo(System.Reflection.MethodInfo,Morpheus.AEventHandler,System.Object)">
            <summary>
            Set up this object correctly for a given <see cref="T:System.Reflection.MethodInfo"/>
            </summary>
            <param name="_methodInfo"></param>
            <param name="_attribute"></param>
            <param name="_object"></param>
        </member>
        <member name="M:Morpheus.EventDispatcher.CEventHandler_Reflection.SetEventType">
            <summary>
            Setting the EventType can be non-trivial when both the AEventHandler.EventType
            and AEventHandler.Value are set. If Value is not set, then simply take EventType
            from the attribute. This may still be NULL if the method signature itself must
            be used to figure out the EventType
            </summary>
        </member>
        <member name="M:Morpheus.EventDispatcher.CEventHandler_Reflection.HandleEvent(System.Object)">
            <summary>
            Called when the actual handler needs to be called. Will build the parameter
            array to suit.
            </summary>
            <param name="_event"></param>
        </member>
        <member name="T:Morpheus.EDispatchMode">
            <summary>
            Tells the dispatcher how (on which thread and/or when) to execute handlers for events.
            </summary>
        </member>
        <member name="F:Morpheus.EDispatchMode.NotAssigned">
            <summary>
            Used in combination with hints and/or defaults to specify handling when nothing explicit has been set
            </summary>
        </member>
        <member name="F:Morpheus.EDispatchMode.Inline">
            <summary>
            Inlined dispatch occurs within the Post method of the dispatcher, in the same thread as the caller of Post
            </summary>
        </member>
        <member name="F:Morpheus.EDispatchMode.Threadpool">
            <summary>
            Threadpool dispatch occurs on the threadpool. The UserWorkItem is immediately queued from within the Post method. 
            The handler itself is guaranteed not to execute on the same thread as the caller.
            </summary>
        </member>
        <member name="F:Morpheus.EDispatchMode.Batched">
            <summary>
            Batched dispatch occurs on whichever thread calls the ExecuteBatch method of the dispatcher. The Post method 
            merely queues batched events up for execution in ExecuteBatch. The events are handled in a FIFO manner.
            </summary>
        </member>
        <member name="T:Morpheus.XReflectionArgumentException">
            <summary>
            This is the type of exception thrown by the <see cref="N:System.Reflection"/>-based Event Handler Discovery
            </summary>
        </member>
        <member name="F:Morpheus.XReflectionArgumentException.MethodInfo">
            <summary>
            The <see cref="F:Morpheus.XReflectionArgumentException.MethodInfo"/> object that was being analysed when the error was found
            </summary>
        </member>
        <member name="M:Morpheus.XReflectionArgumentException.#ctor(System.Reflection.MethodInfo,System.String,System.Object[])">
            <summary>
            Construct with a MethodInfo object and a formatted string
            </summary>
            <param name="_methodInfo">The MethodInfo object causing the exception</param>
            <param name="_formatString">Format string, suitable for <see cref="M:System.String.Format(System.String,System.Object)"/></param>
            <param name="_params"></param>
        </member>
        <member name="P:Morpheus.XReflectionArgumentException.Message">
            <summary>
            Make sure the MethodInfo.Name is in the output string
            </summary>
        </member>
        <member name="T:Morpheus.ForEachExtensions">
            <summary>
            Collection of extension methods for the <see cref="T:System.Collections.Generic.IEnumerable`1"/> classes
            </summary>
        </member>
        <member name="M:Morpheus.ForEachExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
             <summary>
             An Extension to <see cref="T:System.Collections.Generic.IEnumerable`1"/> to allow "some arbitrary operation" to
             be performed on each element of an enumeration.
             </summary>
             <typeparam name="T">
             The implied <see cref="T:System.Type"/> of the elements in the enumeration
             </typeparam>
             <param name="_set">The enumeration of items</param>
             <param name="_operation">
             The operation to be performed on each item of the enumeration
             </param>
             <remarks>
             <code>
             var col = new int[] { 1, 3, 5, 7 };
            
             int sum1 = 0;
             col.ForEach(_number => sum1 += _number );
            
             int sum2 = col.Sum();
             Assert.AreEqual(sum1, sum2);
             </code>
             </remarks>
        </member>
        <member name="M:Morpheus.ForEachExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Action{``0})">
             <summary>
             An Extension to <see cref="T:System.Collections.Generic.IEnumerable`1"/> to allow "some arbitrary operation" to
             be performed on each element of the set IF AND ONLY IF the element passes the
             filtering criteria
             </summary>
             <typeparam name="T">
             The <see cref="T:System.Type"/> of the elements in the enumeration
             </typeparam>
             <param name="_set">The set of items of type T</param>
             <param name="_filter">
             The filter that determines which elements the operation is performed on
             </param>
             <param name="_operation">
             The operation to be performed on each item in the set
             </param>
             <remarks>
             <code>
             var col = new int[] { 1, 2, 3, 4, 5, 6 };
            
             int sum1 = 0;
             col.ForEach(_number => (_number &amp; 1) == 0, _number => sum1 += _number );
            
                 Assert.AreEqual( 12, sum1 );
             </code>
             </remarks>
        </member>
        <member name="M:Morpheus.ForEachExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            An Extension to <see cref="T:System.Collections.Generic.IEnumerable`1"/> to allow "some arbitrary operation" to
            be performed on each element of an enumeration, passing both the item and its index
            to the operation.
            </summary>
            <typeparam name="T">
            The implied <see cref="T:System.Type"/> of the elements in the enumeration
            </typeparam>
            <param name="_items">The enumeration of items</param>
            <param name="_operationWithIndex">
            The index of the item within the enumeration, zero-based
            </param>
            <remarks>
            <code>
            var col = new int[] { 1, 2, 3, 4, 5, 6 };
            
            col.ForEach((_item, _index) =>
            {
                Assert.AreEqual(_index + 1, _item, $"At Index {_index}" );
            } );
            </code>
            </remarks>
        </member>
        <member name="M:Morpheus.ForEachExtensions.ForEach(System.Collections.IEnumerable,System.Action{System.Object})">
             <summary>
             An Extension to IEnumerable to allow "some arbitrary operation" to be performed on
             each element of the set.
             </summary>
             <param name="_set">The set of items of any type</param>
             <param name="_operation">
             The operation to be performed on each item in the set
             </param>
             <remarks>
             <code>
             var stuff = new object[] { "hello", 42, DateTime.Now };
            
             stuff.ForEach(_obj =>
             {
                 switch (_obj)
                 {
                 case string _:
                     Assert.AreEqual(stuff[0], _obj);
                     break;
                 case int _:
                     Assert.AreEqual(stuff[1], _obj);
                     break;
                 case DateTime _:
                     Assert.AreEqual(stuff[2], _obj);
                     break;
                 default:
                     Assert.Fail( "No Matching Object Type" );
                     break;
                 }
             } );
             </code>
             </remarks>
        </member>
        <member name="T:Morpheus.IEnumerableExtensions">
            <summary>
            It is the application writer's responsibility to decide whether to use one of these
            extension methods or to write the loop herself. There is a chance that using these
            extensions on enumerations can impact performance over writing these loops yourself.
            
            In summary- If you're really worried about performance on LARGE, tight loops that are
            not IO-or-UI-bound in any way, these extensions MAY not be right for you. However, if
            I/O and/or User Input is involved, any performance penalty for using these extensions
            will almost always be negligible in comparison.
            </summary>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.Shuffled``1(System.Collections.Generic.IEnumerable{``0},System.Random)">
            <summary>
            Return a version of the enumeration with all values re-arranged randomly.
            </summary>
            <typeparam name="T">Arbitrary datatype</typeparam>
            <param name="_items">The collection to shuffle</param>
            <param name="_rng">The random number generator to use</param>
            <returns>The collection with all elements randomly re-ordered</returns>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.JoinAsString(System.Collections.IEnumerable,System.String,System.Func{System.Object,System.String})">
            <summary>
            Like <see cref="M:System.String.Join(System.String,System.Object[])"/> , but uses an enumeration instead
            of an array
            </summary>
            <param name="_collection">The collection of objects that you wish to join</param>
            <param name="_joinString">
            The character(s) placed between elements from _collection
            </param>
            <param name="_stringizer">
            A function that will turn each individual object into a string. Leave NULL to use
            the <see cref="M:System.Object.ToString"/> method.
            </param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.FirstIndexOf``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Return the index of the first element in the collection for which the _selector
            returns TRUE.
            </summary>
            <typeparam name="T">The Type of each element in the population</typeparam>
            <param name="_collection">The population of data</param>
            <param name="_selector">
            Application returns TRUE for an element that should be returned.
            </param>
            <returns>
            The index (ordinal position) of the first element in the collection for which the
            selector returned TRUE, or -1 if no element caused the selector to return TRUE
            </returns>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.Sample``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double},System.Boolean)">
            <summary>
            Retrieve an item from an enumeration based on a weighted "sampling" of all objects
            in the enumeration.
            </summary>
            <typeparam name="TObject">The type of object being sampled</typeparam>
            <param name="_data">The enumeration of objects being sampled</param>
            <param name="_selector">
            The selector which returns the "Value" for an object in the enumeration- MUST YIELD
            POSITIVE VALUES
            </param>
            <param name="_inverse">
            When TRUE, weight the smallest valued objects the most
            </param>
            <returns>An object from the collection selected based on the _selector</returns>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.Sample``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double},System.Double,System.Boolean)">
            <summary>
            Retrieve an item from an enumeration based on a weighted "sampling" of all objects
            in the enumeration.
            </summary>
            <typeparam name="TObject">The type of object being sampled</typeparam>
            <param name="_data">The enumeration of objects being sampled</param>
            <param name="_selector">
            The selector which returns the "Value" for an object in the enumeration- MUST YIELD
            POSITIVE VALUES
            </param>
            <param name="_selection">
            The selection- a double between 0 and 1 (as if from Random.NextDouble())
            </param>
            <param name="_inverse">
            When TRUE, weight the smallest valued objects the most
            </param>
            <returns>An object from the collection selected based on the _selector</returns>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.SelectRandom``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Select a random element from the collection
            </summary>
            <typeparam name="T">The type of the elements in the enumeration</typeparam>
            <param name="_collection">The elements that could be selected</param>
            <returns>A random element in the enumeration</returns>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.SelectRandom``1(System.Collections.Generic.IEnumerable{``0},System.Random)">
            <summary>
            Select a random element from the collection
            </summary>
            <typeparam name="T">The type of the elements in the enumeration</typeparam>
            <param name="_collection">The elements that could be selected</param>
            <param name="_rng">A <see cref="T:System.Random"/> object used to select an item</param>
            <returns>A random element in the enumeration</returns>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.AllAfter``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Return all elements after a specified element in an enumeration
            </summary>
            <typeparam name="T">The type of the elements in the enumeration</typeparam>
            <param name="_collection">The elements to enumerate over</param>
            <param name="_item">The item to find, then return all items after</param>
            <returns>All items after the specified item in the enumeration</returns>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.NotOfType``1(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Return all items in the enumeration that are NOT of a specific type
            </summary>
            <typeparam name="T">The type that we DON'T want</typeparam>
            <param name="_items">The collection of items</param>
            <returns>
            All items in the collection that CANNOT be cast into the specified type
            </returns>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.OfTypeExactly``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Return all items in an enumeration that are exactly the type specified- does not
            include items derived from the type specified
            </summary>
            <typeparam name="T">The Type of items expected from the enumeration</typeparam>
            <param name="_collection">The collection of items</param>
            <returns>
            Only those items in the enumeration where GetType() returns the type specifed.
            </returns>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.OfTypeExactly``1(System.Collections.Generic.IEnumerable{``0},System.Type)">
            <summary>
            Return all items in an enumeration that are exactly the type specified- does not
            include items derived from the type specified
            </summary>
            <typeparam name="T">The Type of items expected from the enumeration</typeparam>
            <param name="_collection">The collection of items</param>
            <param name="_type">The Type of items expected from the enumeration</param>
            <returns>
            Only those items in the enumeration where GetType() returns the type specifed.
            </returns>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.OfType``1(System.Collections.Generic.IEnumerable{``0},System.Type)">
            <summary>
            Return all items in an enumeration that are of the type specified- does include
            items derived from the type specified
            </summary>
            <typeparam name="T">The Type of items expected from the enumeration</typeparam>
            <param name="_collection">The collection of items</param>
            <param name="_type">The Type of items expected from the enumeration</param>
            <returns>
            Only those items in the enumeration where GetType() returns the type specifed.
            </returns>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.Contains``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Determine if a condition is met for ANY item in the enumeration
            </summary>
            <typeparam name="T">The Type of items in the enumeration</typeparam>
            <param name="_items">The items to test for the condition</param>
            <param name="_condition">The boolean condition to be tested</param>
            <returns>TRUE if the condition is true for any item in the enumeration</returns>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Simply returns TRUE if the collection is empty, FALSE if it has anything in it.
            </summary>
            <typeparam name="T">
            Some arbitrary type for the elements of the collection
            </typeparam>
            <param name="_items">The collection of elements</param>
            <returns>TRUE if the collection is empty, FALSE if it has anything in it</returns>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.OneOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            If the enumeration has exactly one element in it, then return that one element.
            Otherwise return NULL. This is similar to SingleOrDefault except that this will NOT
            throw an exception if there are more than one element in the enumeration.
            </summary>
            <typeparam name="T">The Type of the elements of the enumeration</typeparam>
            <param name="_items">The enumeration</param>
            <returns>
            NULL unless there is exactly one element in the enumeration, in which case it will
            return that singular element
            </returns>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.Smallest``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
            <summary>
            Return the smallest element of the enumeration based on the selector function given
            </summary>
            <typeparam name="T">The Type of items in the enumeration</typeparam>
            <param name="_items">The items in the list to search</param>
            <param name="_selector">
            The function that determines which "field" of an element is checked for smallness
            </param>
            <returns>The smallest element in the enumeration</returns>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.Smallest``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.IComparable})">
            <summary>
            Return the smallest element of the enumeration based on the selector function given
            </summary>
            <typeparam name="T">The Type of items in the enumeration</typeparam>
            <param name="_items">The items in the list to search</param>
            <param name="_selector">
            The function that determines which "field" of an element is checked for smallness
            </param>
            <returns>The smallest element in the enumeration</returns>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.Largest``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
            <summary>
            Return the largest element of the enumeration based on the selector function given
            </summary>
            <typeparam name="T">The Type of items in the enumeration</typeparam>
            <param name="_items">The items in the list to search</param>
            <param name="_selector">
            The function that determines which "field" of an element is checked for largeness
            </param>
            <returns>The largest element in the enumeration</returns>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.Largest``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.IComparable})">
            <summary>
            Return the largest element of the enumeration based on the selector function given
            </summary>
            <typeparam name="T">The Type of items in the enumeration</typeparam>
            <param name="_items">The items in the list to search</param>
            <param name="_selector">
            The function that determines which "field" of an element is checked for largeness
            </param>
            <returns>The largest element in the enumeration</returns>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.LoopIndefinitely``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Provide an infinite number of items by "re-playing" the items in the specified
            collection over and over again.
            </summary>
            <typeparam name="T">The Type of items in the enumeration</typeparam>
            <param name="_items">The items to loop through indefinitely</param>
            <returns>A never ending enumeration of items from _items</returns>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.GetOrAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>
            Check to see if a Dictionary contains an item for a given key. If it does, simply
            return that item. If it doesn't, create a new item and add it to the dictionary,
            returning the new item.
            </summary>
            <typeparam name="Tkey">The Type of the Keys in the Dictionary</typeparam>
            <typeparam name="Tval">The Type of the Values in the Dictionary</typeparam>
            <param name="_dictionary">The Dictionary</param>
            <param name="_key">The Key to look for</param>
            <param name="_generator">
            If this is not NULL, this method will use this function to generate a new item when
            one does not already exist.
            </param>
            <returns>
            A new Item for the Key- Either the one present in the Dictionary prior to calling
            this method, or a new Value if one didn't exist prior to calling this method.
            </returns>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.SelectIgnoreExceptions``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Like "Select", but if the selector throws an exception, that particular input
            element is simply ignored (nothing returned in the output enumeration). This is used
            when you expect that some of the transformations performed on the input elements may
            throw exceptions and checking for those potential exceptions is difficult or
            unwieldy.
            </summary>
            <typeparam name="T">The Type of the objects in the input collection.</typeparam>
            <typeparam name="U">The Type of the transformed objects/items</typeparam>
            <param name="_collection">The collection to enumerate</param>
            <param name="_selector">
            The transformation of input elements to output elements
            </param>
            <returns>
            An enumeration of the transformed values when that transformation didn't cause an
            exception to be thrown
            </returns>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.Collate``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Action{``0,``1})">
            <summary>
            Iterate through two collections in parallel, returning the element from each
            collection at the same ordinal position within the collection. This is called
            Collating when applied to the print (paper) industry
            </summary>
            <remarks>
            For sets A and B, this operation produces the following:
            <code>
            A = { 7, 12, 39 }
            B = { "cat", "dog", "pig" }
            * = { (7,"cat"), (12,"dog"), (39,"pig") }
            </code>
            </remarks>
            <typeparam name="T1">
            The <see cref="T:System.Type"/> of the elements of the first collection
            </typeparam>
            <typeparam name="T2">
            The <see cref="T:System.Type"/> of the elemnets in the second collection
            </typeparam>
            <param name="_collection">
            The first collection, the elements of which shall appear in the first parameter to
            the <see cref="T:System.Action"/>
            </param>
            <param name="_otherCollection">
            The second collection, the elements of which shall appear in the second parameter to
            the <see cref="T:System.Action"/>
            </param>
            <param name="_operation">
            The operation that should be performed on each pair of elements from the collections
            </param>
        </member>
        <member name="M:Morpheus.IEnumerableExtensions.Collate``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Iterate through two collections in parallel, returning the element from each
            collection at the same ordinal position within the collection. This is called
            Collating when applied to the print (paper) industry
            </summary>
            <typeparam name="T1">
            The <see cref="T:System.Type"/> of the elements of the first collection
            </typeparam>
            <typeparam name="T2">
            The <see cref="T:System.Type"/> of the elements in the second collection
            </typeparam>
            <param name="_collection">
            The first collection, the elements of which shall appear in the first item in the
            returned <see cref="T:System.Tuple"/> s
            </param>
            <param name="_otherCollection">
            The second collection, the elements of which shall appear in the second item in the
            returned <see cref="T:System.Tuple"/> s
            </param>
            <returns>Tuples containing the collated items from each collection</returns>
        </member>
        <member name="T:Morpheus.MathRelatedExtensions">
            <summary>
            Some extension methods that operate on numbers.
            </summary>
        </member>
        <member name="T:Morpheus.MathRelatedExtensions.CIntStats">
            <summary>
            Simple Statistics for data of type Int32
            </summary>
        </member>
        <member name="F:Morpheus.MathRelatedExtensions.CIntStats.Minimum">
            <summary>
            The smallest value found
            </summary>
        </member>
        <member name="F:Morpheus.MathRelatedExtensions.CIntStats.Average">
            <summary>
            The average of all values (not an integer)
            </summary>
        </member>
        <member name="F:Morpheus.MathRelatedExtensions.CIntStats.Maximum">
            <summary>
            The largest value found
            </summary>
        </member>
        <member name="F:Morpheus.MathRelatedExtensions.CIntStats.Count">
            <summary>
            The number of values considered
            </summary>
        </member>
        <member name="F:Morpheus.MathRelatedExtensions.CIntStats.Sum">
            <summary>
            The sum of all values
            </summary>
        </member>
        <member name="P:Morpheus.MathRelatedExtensions.CIntStats.Range">
            <summary>
            The range of values- Basically the difference between Maximum and Minimum
            </summary>
        </member>
        <member name="T:Morpheus.MathRelatedExtensions.CDoubleStats">
            <summary>
            Simple Statistics for data of type Double
            </summary>
        </member>
        <member name="F:Morpheus.MathRelatedExtensions.CDoubleStats.Minimum">
            <summary>
            The smallest value found
            </summary>
        </member>
        <member name="F:Morpheus.MathRelatedExtensions.CDoubleStats.Average">
            <summary>
            The average of all values (not an integer)
            </summary>
        </member>
        <member name="F:Morpheus.MathRelatedExtensions.CDoubleStats.Maximum">
            <summary>
            The largest value found
            </summary>
        </member>
        <member name="F:Morpheus.MathRelatedExtensions.CDoubleStats.Count">
            <summary>
            The number of values considered
            </summary>
        </member>
        <member name="F:Morpheus.MathRelatedExtensions.CDoubleStats.Sum">
            <summary>
            The sum of all values
            </summary>
        </member>
        <member name="P:Morpheus.MathRelatedExtensions.CDoubleStats.Range">
            <summary>
            The range of values- Basically the difference between Maximum and Minimum
            </summary>
        </member>
        <member name="T:Morpheus.MathRelatedExtensions.CDateStats">
            <summary>
            Simple Statistics for data of type DateTime
            </summary>
        </member>
        <member name="F:Morpheus.MathRelatedExtensions.CDateStats.Earliest">
            <summary>
            The Earliest date found in the enumeration
            </summary>
        </member>
        <member name="F:Morpheus.MathRelatedExtensions.CDateStats.Latest">
            <summary>
            The Latest date found in the enumeration
            </summary>
        </member>
        <member name="F:Morpheus.MathRelatedExtensions.CDateStats.Count">
            <summary>
            The number of dates considered
            </summary>
        </member>
        <member name="P:Morpheus.MathRelatedExtensions.CDateStats.Range">
            <summary>
            The difference between the <see cref="F:Morpheus.MathRelatedExtensions.CDateStats.Latest"/> and <see cref="F:Morpheus.MathRelatedExtensions.CDateStats.Earliest"/> dates
            </summary>
        </member>
        <member name="M:Morpheus.MathRelatedExtensions.StandardDeviation(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Return the standard deviation (not the sample standard deviation) of an enumeration
            of doubles. The generalized form, using selectors to convert from your data to a
            double, are found below.
            </summary>
            <param name="_population">The data to get the standard deviation for</param>
            <returns>The standard deviation for the collection of double values</returns>
        </member>
        <member name="M:Morpheus.MathRelatedExtensions.StandardDeviation(System.Collections.Generic.IEnumerable{System.Double},System.Double)">
            <summary>
            Return the standard deviation (not the sample standard deviation) of an enumeration
            of doubles. The generalized form, using selectors to convert from your data to a
            double, are found below. This version assumes that you already know the average of
            the population of data.
            </summary>
            <param name="_population">The data to get the standard deviation for</param>
            <param name="_preComputedAverage">
            The average of the data, calculated from outside this method
            </param>
            <returns>The standard deviation for the collection of double values</returns>
        </member>
        <member name="M:Morpheus.MathRelatedExtensions.StandardDeviation``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
            <summary>
            Return the standard deviation (not the sample standard deviation) of an enumeration
            of doubles.
            </summary>
            <typeparam name="T">The Type of each element in the population</typeparam>
            <param name="_population">The population of data</param>
            <param name="_selector">
            Transform each element of the population into a "double" value
            </param>
            <returns>The standard deviation of the population</returns>
        </member>
        <member name="M:Morpheus.MathRelatedExtensions.StandardDeviation``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double},System.Double)">
            <summary>
            Return the standard deviation (not the sample standard deviation) of an enumeration
            of doubles. This version assumes that you already know the average of the population
            of data.
            </summary>
            <typeparam name="T">The Type of each element in the population</typeparam>
            <param name="_population">The population of data</param>
            <param name="_selector">
            Transform each element of the population into a "double" value
            </param>
            <param name="_preComputedAverage">
            The average of the population, computed prior to calling this routine
            </param>
            <returns>The standard deviation of the population</returns>
        </member>
        <member name="M:Morpheus.MathRelatedExtensions.GetStats(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Return a set of stats (Min, Max, Avg, Total, Count) on a collection of numbers.
            </summary>
            <param name="_data">The data to analyse</param>
            <returns>The stats on the data</returns>
        </member>
        <member name="M:Morpheus.MathRelatedExtensions.GetStats``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
            <summary>
            Return a set of stats (Min, Max, Avg, Total, Count) on a collection of numbers.
            </summary>
            <typeparam name="T">The Type of the data in the collection</typeparam>
            <param name="_data">The data to analyse</param>
            <param name="_selector">The selctor to get an INT from the data</param>
            <returns>The stats on the data</returns>
        </member>
        <member name="M:Morpheus.MathRelatedExtensions.GetStats(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Return a set of stats (Min, Max, Avg, Total, Count) on a collection of numbers.
            </summary>
            <param name="_data">The data to analyse</param>
            <returns>The stats on the data</returns>
        </member>
        <member name="M:Morpheus.MathRelatedExtensions.GetStats``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
            <summary>
            Return a set of stats (Min, Max, Avg, Total, Count) on a collection of numbers.
            </summary>
            <typeparam name="T">The Type of the data in the collection</typeparam>
            <param name="_data">The data to analyse</param>
            <param name="_selector">The selctor to get an INT from the data</param>
            <returns>The stats on the data</returns>
        </member>
        <member name="M:Morpheus.MathRelatedExtensions.GetStats(System.Collections.Generic.IEnumerable{System.DateTime})">
            <summary>
            Return a set of stats (Earliest, Latest, Range, Count) on a collection of dates.
            </summary>
            <param name="_data">The data to analyse</param>
            <returns>The stats on the data</returns>
        </member>
        <member name="M:Morpheus.MathRelatedExtensions.GetStats``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.DateTime})">
            <summary>
            Return a set of stats (Earliest, Latest, Range, Count) on a collection of dates.
            </summary>
            <typeparam name="T">The Type of the data in the collection</typeparam>
            <param name="_data">The data to analyse</param>
            <param name="_selector">The selctor to get a DateTime from the data</param>
            <returns>The stats on the data</returns>
        </member>
        <member name="M:Morpheus.MathRelatedExtensions.AboveAverage``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
            <summary>
            Return all items in an enumeration that are "above average", where a selector is
            used to determine what is used to define "average"
            </summary>
            <typeparam name="T">The Type of items in the enumeration</typeparam>
            <param name="_items">The items in the list to search</param>
            <param name="_selector">
            The function that determines which "field" of an element is used to determine
            "average"
            </param>
            <returns>
            All items in the enumeration that are strictly larger than the average
            </returns>
        </member>
        <member name="M:Morpheus.MathRelatedExtensions.BelowAverage``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
            <summary>
            Return all items in an enumeration that are "below average", where a selector is
            used to determine what is used to define "average"
            </summary>
            <typeparam name="T">The Type of items in the enumeration</typeparam>
            <param name="_items">The items in the list to search</param>
            <param name="_selector">
            The function that determines which "field" of an element is used to determine
            "average"
            </param>
            <returns>
            All items in the enumeration that are strictly smaller than the average
            </returns>
        </member>
        <member name="T:Morpheus.IEnumerable_typed_Extensions">
            <summary>
            A bunch of extensions for <see cref="T:System.Collections.Generic.IEnumerable`1"/> objects.
            </summary>
        </member>
        <member name="M:Morpheus.IEnumerable_typed_Extensions.LastItem``1(``0[])">
            <summary>
            Return the last item in a strongly typed array.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the array</typeparam>
            <param name="_array">The array whose last item is to be returned</param>
            <returns>The last item in the array</returns>
            <exception cref="T:System.ArgumentNullException">
            If used as a static function with a null collection
            </exception>
            <exception cref="T:System.IndexOutOfRangeException">
            Thrown if the array has zero length.
            </exception>
            <remarks>
            <code>
            var arr = new int[] { 1, 2, 3 };
            var x = arr.LastItem();
            Assert.AreEqual(arr[2], x);
            </code>
            </remarks>
        </member>
        <member name="M:Morpheus.IEnumerable_typed_Extensions.LastItem``1(System.Collections.Generic.List{``0})">
            <summary>
            Return the last element of a strongly typed list.
            </summary>
            <typeparam name="T">The type of elements in the list</typeparam>
            <param name="_list">The list to get the last element of</param>
            <returns>The last element in the list.</returns>
            <exception cref="T:System.ArgumentNullException">
            If used as a static function with a null collection
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if the List is empty
            </exception>
        </member>
        <member name="M:Morpheus.IEnumerable_typed_Extensions.RemoveLastItem``1(System.Collections.Generic.List{``0})">
            <summary>
            Simply remove the last item from a List. Throws an exception if the list is empty.
            </summary>
            <typeparam name="T">The type of elements in the list</typeparam>
            <param name="_list">The list to remove the last element of</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if the List is empty
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If used as a static function with a null collection
            </exception>
        </member>
        <member name="M:Morpheus.IEnumerable_typed_Extensions.RemoveFirstItem``1(System.Collections.Generic.List{``0})">
            <summary>
            Simply remove the first item from a List. Throws an exception if the list is empty.
            </summary>
            <typeparam name="T">The type of elements in the list</typeparam>
            <param name="_list">The list to remove the first element of</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if the List is empty
            </exception>
            <exception cref="T:System.ArgumentNullException">
            If used as a static function with a null collection
            </exception>
        </member>
        <member name="M:Morpheus.IEnumerable_typed_Extensions.RemoveRange``1(System.Collections.Generic.List{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Remove all items from a list that are contained in an enumeration
            </summary>
            <typeparam name="T">The Type of list</typeparam>
            <param name="_list">The list to remove from</param>
            <param name="_toRemove">The items to remove</param>
            <returns>The number of items removed from the list</returns>
            <exception cref="T:System.ArgumentNullException">
            If used as a static function with a null collection
            </exception>
        </member>
        <member name="M:Morpheus.IEnumerable_typed_Extensions.Set``1(System.Collections.Generic.IList{``0},System.Int32,``0)">
            <summary>
            List helper to Set the value at any index in the list to something. Will "grow" the
            list if its currently too small to handle the index specified.
            </summary>
            <typeparam name="T">The type of the elements in the list</typeparam>
            <param name="_list">The list to set a value in</param>
            <param name="_index">The index of the value- may be larger than list.Count</param>
            <param name="_value">The value to put into the list</param>
            <exception cref="T:System.ArgumentNullException">
            If used as a static function with a null collection
            </exception>
        </member>
        <member name="M:Morpheus.IEnumerable_typed_Extensions.Shuffle``1(System.Collections.Generic.IList{``0},System.Random)">
            <summary>
            Shuffle all elements in an IList to a random ordering
            </summary>
            <typeparam name="T">The type of the elements in the list</typeparam>
            <param name="_list">The list of things to shuffle</param>
            <param name="_rng">The random number generator to use</param>
            <exception cref="T:System.ArgumentNullException">
            If used as a static function with a null collection
            </exception>
        </member>
        <member name="M:Morpheus.IEnumerable_typed_Extensions.SwapElements``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Swap two elements in any IList collection
            </summary>
            <typeparam name="T">The type of the elements in the list</typeparam>
            <param name="_list">The list that we're swapping elements in</param>
            <param name="_index1">The index of the first element to swap</param>
            <param name="_index2">The index of the second element to swap</param>
            <exception cref="T:System.ArgumentNullException">
            If used as a static function with a null collection
            </exception>
        </member>
        <member name="T:Morpheus.MiscellaneousExtensions">
            <summary>
            Some extension methods for collections of weird things.
            </summary>
        </member>
        <member name="M:Morpheus.MiscellaneousExtensions.JoinAll(System.Collections.Generic.IEnumerable{System.Threading.Thread})">
            <summary>
            Given an enumeration of threads, "Join" each thread before returning.
            </summary>
            <param name="_threads">An enumeration of threads</param>
        </member>
        <member name="T:Morpheus.CReflection">
            <summary>
            Helper class with <see cref="N:System.Reflection"/> based operations
            </summary>
        </member>
        <member name="M:Morpheus.CReflection.BetterGetType(System.String)">
            <summary>
            Helper method to try to resolve a type name.
            </summary>
            <remarks>
            Will try to overcome the inherent limitation of Type.GetType that only looks in
            mscorlib and in the current assembly. This will be addressed by iterating through
            all loaded assemblies if Type.GetType does not return anything.
            </remarks>
            <param name="_name">The name to resolve</param>
            <returns>
            The type associated with the name if it exists, or NULL if no type can be found.
            </returns>
        </member>
        <member name="M:Morpheus.CReflection.BetterGetType(System.String,System.Boolean)">
            <summary>
            Helper method to try to resolve a type name using a combination of a "cache" of
            already-found names and the search through all assemblies for a matching type name
            </summary>
            <remarks>
            Because of the order in which assemblies get loaded, the "foreach" loop in
            <see cref="M:Morpheus.CReflection.BetterGetType(System.String)"/> usually loops through all the system (microsoft)
            assemblies before it gets to your assemblies. As such, this cache was implemented to
            "remember" if you've passed in any given type name and to look that name up
            immediately before trying to loop through all of the loaded assemblies. This is not
            the default behavior because its possible, when doing a lot of "custom" assembly
            loading, the application may rely on a new search every time (this argument may be
            fallacious).
            </remarks>
            <param name="_name">
            The "full name" of the class, WITHOUT ASSEMBLY QUALIFICATION
            </param>
            <param name="_useCacheOfTypes">
            When TRUE, use the cache before looping through all assemblies to find the type
            </param>
            <returns>
            The type associated with the name if it exists, or NULL if no type can be found.
            </returns>
        </member>
        <member name="M:Morpheus.CReflection.GetTypesWithAttribute``1(System.Func{``0,System.Boolean})">
            <summary>
            Get all loaded types that have a specified attribute and that attribute matches a
            filter condition
            </summary>
            <typeparam name="T">The Type of the attribute that is required</typeparam>
            <param name="_filter">
            The filter to use on the attributes before a Type is returned. If null, then no
            filter is applied and all found attributes are returned.
            </param>
            <returns>
            All Types in all loaded assemblies that have the specified attribute that conform to
            the spefified filter
            </returns>
        </member>
        <member name="M:Morpheus.CReflection.GetStaticFunctionsWithAttribute``1(System.Boolean)">
            <summary>
            Search all-or-current assembly for all public static functions that are decorated
            with a given attribute.
            </summary>
            <typeparam name="T">The Type of the Attribute to search for</typeparam>
            <param name="_allLoadedAssemblies">
            TRUE- Look in all loaded assemblies, FALSE- Look only in the caller's assembly
            </param>
            <returns>
            A Dictionary with <see cref="T:System.Reflection.MethodInfo"/> objects as keys and Attributes (of type
            T) as values.
            </returns>
        </member>
        <member name="M:Morpheus.CReflection.HasAttribute(System.Reflection.MemberInfo,System.Type)">
            <summary>
            Find out if a particular member has a specific attribute. Don't use this method if
            you need the actual attribute objects- use the GetCustomAttributes method of the
            member, as usual.
            </summary>
            <param name="_member">The member to check</param>
            <param name="_attribute">The Attribute that you're looking for</param>
            <returns>TRUE if the attribute exists on the member, FALSE if not.</returns>
        </member>
        <member name="M:Morpheus.CReflection.HasAttribute``1(System.Reflection.MemberInfo)">
            <summary>
            Find out if a particular member has a specific attribute. Don't use this method if
            you need the actual attribute objects- use the GetCustomAttributes method of the
            member, as usual.
            </summary>
            <typeparam name="TAttrType">The Attribute that you're looking for</typeparam>
            <param name="_member">The member to check</param>
            <returns>TRUE if the attribute exists on the member, FALSE if not</returns>
        </member>
        <member name="M:Morpheus.CReflection.GetSingleAttribute``1(System.Reflection.MemberInfo)">
            <summary>
            Return an attribute associated with a member, or null if no such attribute exists on
            the member. Returns the "first" attribute if multiple attributes exist.
            </summary>
            <typeparam name="TAttrType">The Type of the attribute to find</typeparam>
            <param name="_member">The member to look for attributes on</param>
            <returns>
            NULL if the attribute isn't associated with the member, or the first attribute found
            on the member if one is.
            </returns>
        </member>
        <member name="M:Morpheus.CReflection.CreateWithConstructor(System.Type,System.Object[])">
            <summary>
            Create a new instance of an object using the constructor parameters specified.
            </summary>
            <param name="_type">The Type of the object to create</param>
            <param name="_params">
            The parameters to pass to the constructor. NULL implies the default constructor
            </param>
            <returns>
            An object of the type specified constructed using the parameters specified
            </returns>
        </member>
        <member name="M:Morpheus.CReflection.CreatePopulatedArray``1(System.Int32,System.Object[])">
            <summary>
            A Helper function that will not only allocate an array of type T, but it will also
            construct objects for each element in the array using whatever parameters for the
            constructor were specified by the caller. The same rules for constructor parameters
            apply here as do for <see cref="M:Morpheus.CReflection.CreateWithConstructor(System.Type,System.Object[])"/>
            </summary>
            <typeparam name="T">
            The Type of objects in the array to create- All objects are of this type, so this
            can't be an interface or abstract type
            </typeparam>
            <param name="_size">
            The number of elements in the array- All of these elements will be constructed
            </param>
            <param name="_constructorParams">
            A list of parameters which are to be passed to the constructors for all objects in
            the array
            </param>
            <returns>
            A new array of type T containing objects of type T constructed using the specified
            constructor parameters
            </returns>
        </member>
        <member name="M:Morpheus.CReflection.CreatePopulatedArray``1(System.Int32,System.Func{``0})">
            <summary>
            A Helper function that will not only allocate an array of type T, but it will also
            construct objects for each element in the array using whatever constructor function
            provided by the caller
            </summary>
            <typeparam name="T">
            The Type of objects in the array to create- All objects are of this type, so this
            can't be an interface or abstract type
            </typeparam>
            <param name="_size">
            The number of elements in the array- All of these elements will be constructed
            </param>
            <param name="_creator">The function used to create new objects of type T</param>
            <returns>
            A new array of type T containing objects of type T constructed using the specified
            creation function
            </returns>
        </member>
        <member name="M:Morpheus.CReflection.CreatePopulatedArray``1(System.Int32,System.Func{System.Int32,``0})">
            <summary>
            A Helper function that will not only allocate an array of type T, but it will also
            construct objects for each element in the array using whatever constructor function
            provided by the caller
            </summary>
            <typeparam name="T">
            The Type of objects in the array to create- All objects are of this type, so this
            can't be an interface or abstract type
            </typeparam>
            <param name="_size">
            The number of elements in the array- All of these elements will be constructed
            </param>
            <param name="_creator">
            The function used to create new objects of type T. The index of the element to be
            created is passed to this function.
            </param>
            <returns>
            A new array of type T containing objects of type T constructed using the specified
            creation function
            </returns>
        </member>
        <member name="M:Morpheus.CReflection.ImplementsInterface(System.Type,System.Type)">
            <summary>
            Determines if a Type inherits a specific Interface. This handles generic interfaces
            correctly, in that passing in typeof( <see cref="T:System.Collections.Generic.IEnumerable`1"/> ) will check the
            Type against any specific versions of <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <param name="_type">The Type to check for the interface.</param>
            <param name="_interfaceType">The Type of the Interface to look for</param>
            <returns>TRUE if the Type has the specified interface in its heirarchy.</returns>
        </member>
        <member name="M:Morpheus.CReflection.GetAllFields(System.Type)">
            <summary>
            This method will retrieve all fields in the Type's hierarchy, including private
            fields found in a superclass that would otherwise be hidden when using the
            GetFields() method (even with BindingFlags.FlattenHierarchy). This will return
            public and non-public instance fields, but not any static fields.
            </summary>
            <param name="_type">The Type to return all fields for</param>
            <returns>
            An enumeration of all fields of a Type, including private fields on superclasses
            </returns>
        </member>
        <member name="M:Morpheus.CReflection.GetTypesInInheritanceChain(System.Type,System.Boolean,System.Boolean)">
            <summary>
            Return an enumeration of the provided Type plus all types considered "BaseTypes"
            (SuperClasses) of that Type. The returned values will be most-derived to
            least-derived, with "this type" being the first returned value (if requested) and
            typeof(object) being the last returned value (if requested)
            </summary>
            <param name="_type">
            The Type that this function will return the inheritance chain for
            </param>
            <param name="_includeThisType">
            If TRUE, then _type will be returned first. If FALSE, then _type.BaseType will be
            return first
            </param>
            <param name="_includeSystemObject">
            If TRUE, then typeof(System.Object) will be returned as the last element. If FALSE,
            then the Type derived directly from System.Object is returned last.
            </param>
            <returns>
            An enumeration of Types in a Type's inheritance chain, in order of the most-derived
            to the least-derived Types.
            </returns>
        </member>
        <member name="M:Morpheus.CReflection.GetMemberInfo(System.Linq.Expressions.Expression)">
            <summary>
            Gets MemberInfo even if the referenced member is a primitive value nested inside a
            UnaryExpression which is a Convert operation.
            </summary>
            <param name="_body">
            The Expression Body which is evaluated as a Member expression
            </param>
            <returns>
            A FieldInfo or PropertyInfo representing the member described in the expression.
            </returns>
        </member>
        <member name="M:Morpheus.CReflection.GetFieldInfo(System.Linq.Expressions.Expression)">
            <summary>
            Wrapper around GetMemberInfo that assures a Field is returned
            </summary>
            <param name="_body">The expression identifying a field</param>
            <returns>A FieldInfo object for the identified field</returns>
        </member>
        <member name="M:Morpheus.CReflection.GetPropertyInfo(System.Linq.Expressions.Expression)">
            <summary>
            Wrapper around GetMemberInfo that assures a Property is returned
            </summary>
            <param name="_body">The expression identifying a property</param>
            <returns>A PropertyInfo object for the identified property</returns>
        </member>
        <member name="M:Morpheus.CReflection.GetMemberInfo``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Get a MemberInfo object for an expression. Allows the expression to be constructed
            as a parameter to this method.
            </summary>
            <typeparam name="T">
            The Type of the object declaring the interesting field or property
            </typeparam>
            <param name="_expr">An expression identifying a member on type T</param>
            <returns>A MemberInfo object for the identified member</returns>
        </member>
        <member name="M:Morpheus.CReflection.GetFieldInfo``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Get a FieldInfo object for an expression. Allows the expression to be constructed as
            a parameter to this method.
            </summary>
            <typeparam name="T">
            The Type of the object declaring the interesting field
            </typeparam>
            <param name="_expr">An expression identifying a field on type T</param>
            <returns>A FieldInfo object for the identified field</returns>
        </member>
        <member name="M:Morpheus.CReflection.GetPropertyInfo``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Get a PropertyInfo object for an expression. Allows the expression to be constructed
            as a parameter to this method.
            </summary>
            <typeparam name="T">
            The Type of the object declaring the interesting property
            </typeparam>
            <param name="_expr">An expression identifying a property on type T</param>
            <returns>A PropertyInfo object for the identified property</returns>
        </member>
        <member name="M:Morpheus.CReflection.GetPropertyInfo(System.Reflection.MethodBase)">
            <summary>
            Given what's assumed to be an individual getter or setter method for a property,
            figure out what the actual <see cref="T:System.Reflection.PropertyInfo"/> object is for the property
            that the accessor belongs to
            </summary>
            <param name="_method">The actual get or set method to analyse</param>
            <returns>
            NULL if the parameter is not a get or set method, or the <see cref="T:System.Reflection.PropertyInfo"/>
            object if it is.
            </returns>
        </member>
        <member name="M:Morpheus.CReflection.SetMemberValue(System.Object,System.String,System.Object,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Set the value of a property or field on an object using the name of the member
            </summary>
            <param name="_object">The object containing the member to set</param>
            <param name="_memberName">The name of the member to set</param>
            <param name="_value">The value to assign to the member</param>
            <param name="_includeFields">If TRUE, then fields will be searched</param>
            <param name="_includeProperties">If TRUE, then properties will be searched</param>
            <param name="_includePrivate">
            If TRUE, then access modifiers (public/private/etc) will be ignored.
            </param>
            <returns>
            TRUE if the value was set, FALSE if there was no member with the specified name.
            </returns>
        </member>
        <member name="T:Morpheus.CReflection.MemberNotFound">
            <summary>
            A meta-class (sentinel) for describing a specific type of situation
            </summary>
        </member>
        <member name="P:Morpheus.CReflection.MEMBER_NOT_FOUND">
            <summary>
            The sentinel value used to denote that a member is not found
            </summary>
        </member>
        <member name="M:Morpheus.CReflection.GetMemberValue(System.Object,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Get the value of a property or field on an object using the name of the member
            </summary>
            <param name="_object">The object containing the member to get</param>
            <param name="_memberName">The name of the member to get</param>
            <param name="_includeFields">If TRUE, then fields will be searched</param>
            <param name="_includeProperties">If TRUE, then properties will be searched</param>
            <param name="_includePrivate">
            If TRUE, then access modifiers (public/private/etc) will be ignored.
            </param>
            <returns>
            The value of the member specified, or <see cref="P:Morpheus.CReflection.MEMBER_NOT_FOUND"/> if there was no
            member on the object
            </returns>
        </member>
        <member name="T:Morpheus.ConsoleLogSink">
            <summary>
            Because Console is part of .NET, this helper has been implemented to output Morpheus log
            info to the console
            </summary>
        </member>
        <member name="M:Morpheus.ConsoleLogSink.Debug(System.String)">
            <summary>
            Log the most detailed message.
            </summary>
            <param name="_message">The message to log.</param>
            <returns>
            The message, as it was actually logged. If multiple log sinks are present, then this
            value may represent any of the configured logger's return value.
            </returns>
        </member>
        <member name="M:Morpheus.ConsoleLogSink.Info(System.String)">
            <summary>
            Log an informational message.
            </summary>
            <param name="_message">The message to log.</param>
            <returns>
            The message, as it was actually logged. If multiple log sinks are present, then this
            value may represent any of the configured logger's return value.
            </returns>
        </member>
        <member name="M:Morpheus.ConsoleLogSink.Warn(System.String)">
            <summary>
            Log a warning message.
            </summary>
            <param name="_message">The message to log.</param>
            <returns>
            The message, as it was actually logged. If multiple log sinks are present, then this
            value may represent any of the configured logger's return value.
            </returns>
        </member>
        <member name="M:Morpheus.ConsoleLogSink.Error(System.String)">
            <summary>
            Log an error message.
            </summary>
            <param name="_message">The message to log.</param>
            <returns>
            The message, as it was actually logged. If multiple log sinks are present, then this
            value may represent any of the configured logger's return value.
            </returns>
        </member>
        <member name="T:Morpheus.ELogLevel">
            <summary>
            Use to describe the severity of each log level
            </summary>
        </member>
        <member name="F:Morpheus.ELogLevel.Unset">
            <summary>
            Not zero, but explicitly Unset
            </summary>
        </member>
        <member name="F:Morpheus.ELogLevel.Nothing">
            <summary>
            Has been set, but to nothing recognizable
            </summary>
        </member>
        <member name="F:Morpheus.ELogLevel.Debug">
            <summary>
            Debug is the most verbose level of logging and may almost certainly affect
            performance.
            </summary>
        </member>
        <member name="F:Morpheus.ELogLevel.Info">
            <summary>
            Full logging. The application should take care to assure that anything logged to
            Info will not affect performance on target systems.
            </summary>
        </member>
        <member name="F:Morpheus.ELogLevel.Warn">
            <summary>
            Warning implies that something went wrong, but Morpheus was able to deal with it
            properly. The fact that it happened should generally mean the message is worthy of
            forensic analysis.
            </summary>
        </member>
        <member name="F:Morpheus.ELogLevel.Error">
            <summary>
            An Error Occurred. The program may or may not terminate. An exception may or may not
            have been thrown. If the program does not terminate, at least one function Morpheus
            was supposed to perform didn't get performed.
            </summary>
        </member>
        <member name="T:Morpheus.ILogSink">
            <summary>
            Implement by application to receive log messages from Morpheus
            </summary>
        </member>
        <member name="M:Morpheus.ILogSink.Debug(System.String)">
            <summary>
            Log the most detailed message. This level of logging may affect the performance of
            the application.
            </summary>
            <param name="_message">The message to log.</param>
            <returns>
            The message, as it was actually logged. If multiple log sinks are present, then this
            value may represent any of the configured logger's return value.
            </returns>
        </member>
        <member name="M:Morpheus.ILogSink.Info(System.String)">
            <summary>
            Log an informational message.
            </summary>
            <param name="_message">The message to log.</param>
            <returns>
            The message, as it was actually logged. If multiple log sinks are present, then this
            value may represent any of the configured logger's return value.
            </returns>
        </member>
        <member name="M:Morpheus.ILogSink.Warn(System.String)">
            <summary>
            Log a warning message.
            </summary>
            <param name="_message">The message to log.</param>
            <returns>
            The message, as it was actually logged. If multiple log sinks are present, then this
            value may represent any of the configured logger's return value.
            </returns>
        </member>
        <member name="M:Morpheus.ILogSink.Error(System.String)">
            <summary>
            Log an error message.
            </summary>
            <param name="_message">The message to log.</param>
            <returns>
            The message, as it was actually logged. If multiple log sinks are present, then this
            value may represent any of the configured logger's return value.
            </returns>
        </member>
        <member name="T:Morpheus.MorpheusLog">
            <summary>
            Class for handling all Morpheus logging.
            
            <para> This is in no way meant to be a replacement for a logging framework, such as
            Log4Net. </para>
            
            <para> By writing an <see cref="T:Morpheus.ILogSink"/> implementation, the application can
            re-direct Morpheus logs to anywhere, including both <see cref="P:System.Console.Out"/> or just to
            the bit bucket. </para>
            
            <para> The application is NOT MEANT TO LOG TO THIS! Again, this is for Morpheus logging
            to get into the application, not the other way. </para>
            </summary>
        </member>
        <member name="P:Morpheus.MorpheusLog.Logger">
            <summary>
            The logger that will handle all output requests
            </summary>
        </member>
        <member name="M:Morpheus.MorpheusLog.Delete">
            <summary>
            Remove the logger. Allows null-conditional operator to bypass all logging string
            formatting.
            </summary>
        </member>
        <member name="M:Morpheus.MorpheusLog.Create(Morpheus.ILogSink,Morpheus.ELogLevel)">
            <summary>
            Create a new logger with a specified Sink and a specified Minimum Log Level. Both
            may be null.
            </summary>
            <param name="_sink"></param>
            <param name="_level"></param>
        </member>
        <member name="M:Morpheus.MorpheusLog.UseConsole(Morpheus.ELogLevel)">
            <summary>
            Shortcut to use the Console to output data
            </summary>
            <param name="_level"></param>
        </member>
        <member name="P:Morpheus.MorpheusLog.Enabled">
            <summary>
            Long-hand way of avoiding a null-conditional.
            </summary>
        </member>
        <member name="T:Morpheus.MorpheusLog.LogFunction">
            <summary>
            This class will output a string to a ILogSink provided by the application. Sinks are
            provided for NULL and Console output. Levels are provided to allow the application
            to cull low-level messaging.
            </summary>
        </member>
        <member name="M:Morpheus.MorpheusLog.LogFunction.#ctor(Morpheus.ILogSink,Morpheus.ELogLevel)">
            <summary>
            Create a new LogFunction with
            </summary>
            <param name="_sink"></param>
            <param name="_level"></param>
        </member>
        <member name="P:Morpheus.MorpheusLog.LogFunction.Level">
            <summary>
            The lowest level logs to actually send to the sink. When UnSet, everything will
            always be logged.
            </summary>
        </member>
        <member name="P:Morpheus.MorpheusLog.LogFunction.Sink">
            <summary>
            May be set by the application to provide a destination for logs. In not set,
            then logging will not happen.
            </summary>
        </member>
        <member name="M:Morpheus.MorpheusLog.LogFunction.Output(Morpheus.ELogLevel,System.Func{System.String,System.String},System.String)">
            <summary>
            Internal helper to do the dispatching of messages
            </summary>
            <param name="_minLevel"></param>
            <param name="_outFunc"></param>
            <param name="_message"></param>
            <returns>The string that was output</returns>
        </member>
        <member name="M:Morpheus.MorpheusLog.LogFunction.Debug(System.String)">
            <summary>
            Send message to the <see cref="P:Morpheus.MorpheusLog.LogFunction.Sink"/> 's method Debug
            </summary>
            <param name="_message">
            The message to send. Various sinks may add to this message.
            </param>
            <returns>The actual message that was logged by the sink.</returns>
        </member>
        <member name="M:Morpheus.MorpheusLog.LogFunction.Info(System.String)">
            <summary>
            Send message to the <see cref="P:Morpheus.MorpheusLog.LogFunction.Sink"/> 's method Info
            </summary>
            <param name="_message">
            The message to send. Various sinks may add to this message.
            </param>
            <returns>The actual message that was logged by the sink.</returns>
        </member>
        <member name="M:Morpheus.MorpheusLog.LogFunction.Warn(System.String)">
            <summary>
            Send message to the <see cref="P:Morpheus.MorpheusLog.LogFunction.Sink"/> 's method Warn
            </summary>
            <param name="_message">
            The message to send. Various sinks may add to this message.
            </param>
            <returns>The actual message that was logged by the sink.</returns>
        </member>
        <member name="M:Morpheus.MorpheusLog.LogFunction.Error(System.String)">
            <summary>
            Send message to the <see cref="P:Morpheus.MorpheusLog.LogFunction.Sink"/> 's method Error
            </summary>
            <param name="_message">
            The message to send. Various sinks may add to this message.
            </param>
            <returns>The actual message that was logged by the sink.</returns>
        </member>
        <member name="T:Morpheus.NullLogSink">
            <summary>
            Ignores all log output.
            </summary>
        </member>
        <member name="M:Morpheus.NullLogSink.Debug(System.String)">
            <summary>
            Log the most detailed message.
            </summary>
            <param name="_message">The message to log.</param>
            <returns>
            The message, as it was actually logged. If multiple log sinks are present, then this
            value may represent any of the configured logger's return value.
            </returns>
        </member>
        <member name="M:Morpheus.NullLogSink.Info(System.String)">
            <summary>
            Log an informational message.
            </summary>
            <param name="_message">The message to log.</param>
            <returns>
            The message, as it was actually logged. If multiple log sinks are present, then this
            value may represent any of the configured logger's return value.
            </returns>
        </member>
        <member name="M:Morpheus.NullLogSink.Warn(System.String)">
            <summary>
            Log a warning message.
            </summary>
            <param name="_message">The message to log.</param>
            <returns>
            The message, as it was actually logged. If multiple log sinks are present, then this
            value may represent any of the configured logger's return value.
            </returns>
        </member>
        <member name="M:Morpheus.NullLogSink.Error(System.String)">
            <summary>
            Log an error message.
            </summary>
            <param name="_message">The message to log.</param>
            <returns>
            The message, as it was actually logged. If multiple log sinks are present, then this
            value may represent any of the configured logger's return value.
            </returns>
        </member>
        <member name="T:Morpheus.PerformanceTests.TestBase">
            <summary>
            Harness for the tests.
            </summary>
            <remarks>
            <para> Tests are initialized on the main thread, but run on their own thread. </para>
            
            <para> All immutable test setup should be done in the constructor. This should be data
            stored in this specific (presumably) base-class object (e.g. TestName, Order, etc). No
            test-specific data should be set in the constructor. </para>
            
            <para> All setup to configure the object for the test should be done in "Initialize()".
            This should include any setting of test-specific properties/fields. </para>
            
            <para> Any cleanup should be done in the CleanUp() override. </para>
            
            <para> Please see the class <see cref="T:Morpheus.PerformanceTests.TestRunner"/> for examples. </para>
            </remarks>
        </member>
        <member name="P:Morpheus.PerformanceTests.TestBase.TestName">
            <summary>
            Should be set by the constructor to match the name of this test, for output and
            descriptive purposes
            </summary>
        </member>
        <member name="P:Morpheus.PerformanceTests.TestBase.OkToRun">
            <summary>
            Is the test OK to run. Derived classes set this to FALSE when the test shouldn't
            run. This tells the framework whether or not to run a test, not whether or not the
            test is completed or should stop running.
            </summary>
        </member>
        <member name="P:Morpheus.PerformanceTests.TestBase.RunOrder">
            <summary>
            The RunOrder is used to sort all tests found in a DLL.
            </summary>
        </member>
        <member name="P:Morpheus.PerformanceTests.TestBase.Context">
            <summary>
            App defined context that may be assigned at will to this test
            </summary>
        </member>
        <member name="F:Morpheus.PerformanceTests.TestBase.Iterations">
            <summary>
            The number of iterations that the test has run. Should be modified by using
            Interlocked.Increment(ref Iterations).
            </summary>
        </member>
        <member name="F:Morpheus.PerformanceTests.TestBase.StopRunning">
            <summary>
            The framework will set this to TRUE when the test is supposed to terminate.
            </summary>
        </member>
        <member name="F:Morpheus.PerformanceTests.TestBase.Exception">
            <summary>
            If an exception is thrown while accessing this harness, it will be stored here as
            well as passed into the OnException event
            </summary>
        </member>
        <member name="P:Morpheus.PerformanceTests.TestBase.StartTime">
            <summary>
            The time that the test started running
            </summary>
        </member>
        <member name="P:Morpheus.PerformanceTests.TestBase.ExpectedEndTime">
            <summary>
            When the test was started, this is when the test was expected to end
            </summary>
        </member>
        <member name="P:Morpheus.PerformanceTests.TestBase.EndTime">
            <summary>
            Due to overheads and imprecision, this is when the test actually ended.
            </summary>
        </member>
        <member name="M:Morpheus.PerformanceTests.TestBase.Initialize">
            <summary>
            This is called by the framework before the test starts. The test should establish
            any test-specific data here. Doing so helps with Exception processing, as exceptions
            thrown in constructors when Activator.CreateInstance is used is harder to debug.
            </summary>
            <remarks>
            Constructor- Stuff that really should be impervious to exception throwing.
            Initialize- All Test-specific initialization, including anything that may throw
            exceptions. Cleanup- Any cleanup that should happen outside the timing of the tests.
            Do NOT clean up in RunTests()!
            </remarks>
        </member>
        <member name="M:Morpheus.PerformanceTests.TestBase.RunTest">
            <summary>
            Called by the framework.
            </summary>
            <remarks>
            This routine should contain loops or other constructs. Each iteration of the loop
            should increment the "Iterations" field by calling Interlocked.Increment(ref
            Iterations). This is the lowest overhead oepration I can think of to record an
            iteration of the test.
            
            The test should stop looping when it notices the "StopRunning" bool is TRUE
            
            The contents of this method should be copy-pasted to form the basis of application
            tests in order to make sure those tests are as close to "baseline" as possible
            </remarks>
        </member>
        <member name="M:Morpheus.PerformanceTests.TestBase.CleanUp">
            <summary>
            Called by the framework to make sure all parts of the test that are not to be
            included in timing are cleaned up or finalized. This routine's run-time IS NOT
            MEASURED.
            </summary>
        </member>
        <member name="T:Morpheus.PerformanceTests.TestRunner">
             <summary>
             The TestRunner class is a framework for running performance tests over very fast
             operations. It is focused on operations whose time is measured in microseconds or
             nanoseconds.
             </summary>
             <remarks>
             <para> The bare minimal baseline test looks like this: </para>
             <code>
             public class TestBaseline : TestBase
             {
                 public TestBaseline()
                 {
                     OkToRun = true;
                     TestName = "Baseline Test- No Operation within loop"; // not required, but a good idea
                 }
             
                 public override void RunTest()
                 {
                     while (!StopRunning)
                     {
                         System.Threading.Interlocked.Increment( ref Iterations );
                     }
                 }
             };
             </code>
             <para> This is the format of a user-defined test. </para>
             <code>
             public class TestRandom : TestBase
             {
                 Random rng;
             
                 public TestRandom()
                 {
                     OkToRun = false;
                     TestName = "Test Random x1";
                     rng = new Random();
                 }
             
                 public override void RunTest()
                 {
                     while (!StopRunning)
                     {
                         var x = rng.Next();
                         var y = rng.NextDouble();
                         var z = x * y;
             
                         System.Threading.Interlocked.Increment( ref Iterations );
                     }
                 }
             }
             </code>
             <para> Instantiating the runner and running it using the Console.Out test harness is as
             simple as this: </para>
             <code>
             var tester = new TestRunner( new TestBase[] { new TestBaseline(), new TestRandom() } );
             var harness = new TextWriterTestHarness( tester, Console.Out ); // Console.Out is optional
            
             harness.RunTests( SECONDS_TO_RUN, MS_BETWEEN_UPDATES );
             </code>
             <para> The following shortcut will run ALL tests found in the calling
             <see cref="T:System.Reflection.Assembly"/> : </para>
             <code>
             var tester = new TestRunner(); // no params => All subclasses of TestBase in calling assembly
             var harness = new TextWriterTestHarness( tester ); // Auto-Console-Out
            
             harness.RunTests( SECONDS_TO_RUN, MS_BETWEEN_UPDATES );
             </code>
             </remarks>
        </member>
        <member name="E:Morpheus.PerformanceTests.TestRunner.OnTestStart">
            <summary>
            Fired when a test is about to start
            </summary>
        </member>
        <member name="E:Morpheus.PerformanceTests.TestRunner.OnTestComplete">
            <summary>
            Fired after a test has been completed.
            </summary>
        </member>
        <member name="E:Morpheus.PerformanceTests.TestRunner.OnException">
            <summary>
            Fired when an exception has occurred in any of the app-defined event handlers
            </summary>
        </member>
        <member name="P:Morpheus.PerformanceTests.TestRunner.Tests">
            <summary>
            The tests that will be or were run.
            </summary>
        </member>
        <member name="M:Morpheus.PerformanceTests.TestRunner.#ctor(System.Reflection.Assembly)">
            <summary>
            Run all tests found in the specified Assembly, or optionally in the calling Assembly
            (pass NULL)
            </summary>
            <param name="_assembly">
            The assembly to search for classes deriving from TestBase, or NULL to search the
            calling assembly
            </param>
        </member>
        <member name="M:Morpheus.PerformanceTests.TestRunner.#ctor(System.Collections.Generic.IEnumerable{Morpheus.PerformanceTests.TestBase})">
            <summary>
            Use a pre-set enumeration of tests to run
            </summary>
            <param name="_tests">The tests to run</param>
        </member>
        <member name="M:Morpheus.PerformanceTests.TestRunner.RunTests(System.Double)">
            <summary>
            Run all of the tests configured for this runner in the constructor
            </summary>
            <param name="_secondsToRun">How long the tests should be run for</param>
        </member>
        <member name="M:Morpheus.PerformanceTests.TestRunner.RunTest(Morpheus.PerformanceTests.TestBase,System.Double)">
            <summary>
            Run a specific test, regardless of its OkToRun flag
            </summary>
            <param name="_test">
            The test to run, regardless of its <see cref="P:Morpheus.PerformanceTests.TestBase.OkToRun"/> flag
            </param>
            <param name="_secondsToRun">How long the tests should be run for</param>
        </member>
        <member name="M:Morpheus.PerformanceTests.TestRunner.DiscoverTests(System.Reflection.Assembly)">
            <summary>
            Helper to discover all tests found in the specified <see cref="T:System.Reflection.Assembly"/> .
            </summary>
            <param name="_assembly">
            The <see cref="T:System.Reflection.Assembly"/> to search for classes that are subclasses of
            <see cref="T:Morpheus.PerformanceTests.TestBase"/> . If NULL, then this will search the calling Assembly.
            </param>
            <returns>
            An enumeration of all <see cref="T:System.Type"/> s that are subclasses of
            <see cref="T:Morpheus.PerformanceTests.TestBase"/> .
            </returns>
        </member>
        <member name="T:Morpheus.PerformanceTests.TestStatus">
            <summary>
            This class holds the statistics for the performance tests.
            </summary>
            <remarks>Please see the class <see cref="T:Morpheus.PerformanceTests.TestRunner"/> for examples.</remarks>
        </member>
        <member name="F:Morpheus.PerformanceTests.TestStatus.Test">
            <summary>
            The <see cref="T:Morpheus.PerformanceTests.TestBase"/> used for this performance data
            </summary>
        </member>
        <member name="F:Morpheus.PerformanceTests.TestStatus.Now">
            <summary>
            The time that these statistics were created.
            </summary>
        </member>
        <member name="F:Morpheus.PerformanceTests.TestStatus.StartTime">
            <summary>
            When the test started
            </summary>
        </member>
        <member name="F:Morpheus.PerformanceTests.TestStatus.ExpectedEndTime">
            <summary>
            An approximation of when the test will end. Calculated at the beginning of the test
            with the expected duration of the test.
            </summary>
        </member>
        <member name="F:Morpheus.PerformanceTests.TestStatus.EndTime">
            <summary>
            When the test actually ended
            </summary>
        </member>
        <member name="F:Morpheus.PerformanceTests.TestStatus.Iterations">
            <summary>
            The number of loop iterations which occurred for the test.
            </summary>
        </member>
        <member name="F:Morpheus.PerformanceTests.TestStatus.IsDone">
            <summary>
            Set when the loop exits and the test is done.
            </summary>
        </member>
        <member name="F:Morpheus.PerformanceTests.TestStatus.RunTime">
            <summary>
            The amount of time that the test ran for
            </summary>
        </member>
        <member name="F:Morpheus.PerformanceTests.TestStatus.RunTimeInSeconds">
            <summary>
            The amount of time that the test ran for, in seconds
            </summary>
        </member>
        <member name="F:Morpheus.PerformanceTests.TestStatus.SecondsPerIteration">
            <summary>
            The number of seconds for each iteration of the loop.
            </summary>
        </member>
        <member name="F:Morpheus.PerformanceTests.TestStatus.CompletionRatio">
            <summary>
            
            </summary>
        </member>
        <member name="M:Morpheus.PerformanceTests.TestStatus.#ctor(Morpheus.PerformanceTests.TestBase)">
            <summary>
            Construct from a <see cref="T:Morpheus.PerformanceTests.TestBase"/> object
            </summary>
            <param name="_test"></param>
        </member>
        <member name="M:Morpheus.PerformanceTests.TestStatus.ToString">
            <summary>
            Conver to a string
            </summary>
            <returns>String version of these data</returns>
        </member>
        <member name="T:Morpheus.PerformanceTests.TextWriterTestHarness">
            <summary>
            A harness for running performance tests in a basically single-threaded environment.
            </summary>
            <remarks>Please see the class <see cref="T:Morpheus.PerformanceTests.TestRunner"/> for examples.</remarks>
        </member>
        <member name="M:Morpheus.PerformanceTests.TextWriterTestHarness.#ctor(Morpheus.PerformanceTests.TestRunner,System.IO.TextWriter)">
            <summary>
            Construct this harness with a <see cref="T:Morpheus.PerformanceTests.TestRunner"/> and something to route the
            output to.
            </summary>
            <param name="_testRunner">The <see cref="T:Morpheus.PerformanceTests.TestRunner"/> to run</param>
            <param name="_output">
            The output stream. If null, <see cref="P:System.Console.Out"/> will be used.
            </param>
        </member>
        <member name="M:Morpheus.PerformanceTests.TextWriterTestHarness.RunTests(System.Double,System.Int32)">
            <summary>
            Run the tests in the configured <see cref="T:Morpheus.PerformanceTests.TestRunner"/> .
            </summary>
            <param name="_secondsToRun">How long to run tests for</param>
            <param name="_msBetweenNotifications">
            The number of milliseconds between notifications to the application
            </param>
        </member>
        <member name="M:Morpheus.PerformanceTests.TextWriterTestHarness.ReportProgress(System.Object)">
            <summary>
            Helper function to report the progress to the output stream.
            </summary>
            <param name="_param"></param>
        </member>
        <member name="T:Morpheus.AXPath">
            <summary>
            Placing this attribute on a type's member will allow the code to assign an XPath expression that shall be used to find this member's value with an XML document.
            This should be used with <see cref="T:Morpheus.Xml2Object"/>.
            </summary>
        </member>
        <member name="P:Morpheus.AXPath.XPath">
            <summary>
            This is the XPath expression used to find the attributed member's value
            </summary>
        </member>
        <member name="M:Morpheus.AXPath.#ctor(System.String)">
            <summary>
            Construct with the XPath expression used to find the attributed member's value.
            </summary>
            <param name="_xpath">The XPath expression used to find the attributed member's value</param>
        </member>
        <member name="T:Morpheus.CFieldCopier">
            <summary>
            This class provides a mechanism for a field-by-field copy from one object to another. This class will attempt to copy all
            fields in an object, regardless of public/private status. Check out CObjectCopier for a copier that obeys public/private
            conventions AND handles fields + properties.
            </summary>
        </member>
        <member name="M:Morpheus.CFieldCopier.GetFieldLookup(System.Type)">
            <summary>
            Find the dictionary of fields for a given type, including subtypes. Find all public and private instance fields, but no
            static fields
            </summary>
            <param name="_type">The Type to find the data for</param>
            <returns>A dictionary of field-names to fields for a given Type</returns>
        </member>
        <member name="M:Morpheus.CFieldCopier.CopyFields(System.Object,System.Object)">
            <summary>
            Copy, field-for-field, data from one object to another. Any missing fields on either side are ignored. 
            </summary>
            <param name="_destination">The object that will receive the data</param>
            <param name="_source">The object that will provide the data</param>
        </member>
        <member name="M:Morpheus.CFieldCopier.Clone``1(System.Object)">
            <summary>
            A generic Clone operation that will do a field-by-field copy of the source object. This will create an
            object of the specified type, even if that type is different (a base class of) the source object. 
            This is a SHALLOW COPY.
            </summary>
            <typeparam name="TObject">The type of the object to clone</typeparam>
            <param name="_source">The object containing the "source" data.</param>
            <returns>an object of the type specified by the generic parameter</returns>
        </member>
        <member name="M:Morpheus.CFieldCopier.Clone(System.Object)">
            <summary>
            Clone an object into a new object. This is a SHALLOW COPY.
            </summary>
            <param name="_source">the object that is to be cloned</param>
            <returns>A clone of the specified object.</returns>
        </member>
        <member name="T:Morpheus.CObjectCopier">
            <summary>
            This class provides a mechanism for a member-by-member copy of one object to another.
            This is a "shallow copy" of all public fields and properties from one object to another,
            regardless of the Type of the source + destination objects.
            </summary>
        </member>
        <member name="M:Morpheus.CObjectCopier.GetMemberLookup(System.Type)">
            <summary>
            Find the dictionary of members for a given type, including subtypes. Find all public
            fields and public properties.
            </summary>
            <param name="_type">The Type to find the data for</param>
            <returns>A dictionary of member-names to members for a given Type</returns>
        </member>
        <member name="M:Morpheus.CObjectCopier.CopyValues(System.Object,System.Object)">
            <summary>
            Copy, member-by-member, data from one object to another. Any missing members on
            either side are ignored.
            </summary>
            <param name="_destination">The object that will receive the data</param>
            <param name="_source">The object that will provide the data</param>
        </member>
        <member name="T:Morpheus.CProperty`1">
             <summary>
             This class can be used to replace a property's backing field. It provides PropertyChanged notifications for the property.
             </summary>
             <remarks>
             There is a typical usage model for using CProperty. The following code within a class will set up properties as notifiable properties:
             <code>
            public class CTestObjectWithProperties
            {
                private CProperty&lt;int> m_age = new CProperty&lt;int>();
                public int Age
                {
                    get { return m_age.Value; }
                    set { m_age.Value = value; }
                }
                private CProperty&lt;string> m_name = new CProperty&lt;string>( "Default Values Are Fine" );
                public string Name
                {
                    get { return m_name.Value; }
                    set { m_name.Value = value; }
                }
                private CProperty&lt;EDispatchMode> m_mode = new CProperty&lt;EDispatchMode>();
                public EDispatchMode Mode
                {
                    get { return m_mode.Value; }
                    set { m_mode.Value = value; }
                }
            }
             </code>
             </remarks>
             <typeparam name="T">The Type of the property</typeparam>
        </member>
        <member name="F:Morpheus.CProperty`1.m_value">
            <summary>
            Store the value of the property
            </summary>
        </member>
        <member name="M:Morpheus.CProperty`1.#ctor">
            <summary>
            Default constructor does nothing
            </summary>
        </member>
        <member name="M:Morpheus.CProperty`1.#ctor(`0)">
            <summary>
            Constructor with an initializer for the value
            </summary>
            <param name="_value">The initializer for the value</param>
        </member>
        <member name="P:Morpheus.CProperty`1.Value">
            <summary>
            The Value that the CProperty supports.
            Getting the value is straight-forward.
            Setting the value checks to see if the value has changed, and if it has, invokes the plumbing for handling Property Changed events.
            </summary>
        </member>
        <member name="M:Morpheus.CProperty`1.ToString">
            <summary>
            Turn the property value into a string.
            </summary>
            <returns>The string form of the value</returns>
        </member>
        <member name="M:Morpheus.CProperty`1.op_Implicit(Morpheus.CProperty{`0})~`0">
            <summary>
            Allows an object of this class to be implicitly cast into an object of the Type that this object controls.
            </summary>
            <param name="_property">The CProperty that is to be converted</param>
            <returns>An object of type T, basically the .Value for the object.</returns>
        </member>
        <member name="M:Morpheus.CProperty`1.op_Implicit(`0)~Morpheus.CProperty{`0}">
            <summary>
            Given an object of type T, create a new CProperty wrapper for that object
            </summary>
            <param name="_value">The value to wrap in a CProperty object</param>
            <returns>A new CProperty wrapper for the object</returns>
        </member>
        <member name="M:Morpheus.CProperty`1.Serialize(Morpheus.CSerializer,System.Xml.XmlNode)">
            <summary>
            Serialize the value wrapped by this object. This class should remove itself from any mention in serialization/deserialization
            </summary>
            <param name="_serializer">The serializer working on this object</param>
            <param name="_node">The node which will contain the serialized data</param>
            <returns>TRUE always, as this should be the entire serialization process for this object</returns>
        </member>
        <member name="M:Morpheus.CProperty`1.Deserialize(Morpheus.CDeserializer,System.Xml.XmlElement,Morpheus.CWorkingObject)">
            <summary>
            Deserialize XML into the value wrapped by this CProperty. The XML should contain no mention of the CProperty class.
            </summary>
            <param name="_node">The node containing the XML serialization of the Value</param>
            <param name="_object">The working object which will receive the new CProperty after the XML has been deserialied into the Value</param>
            <param name="_framework">The deserializer working on this object</param>
            <returns>TRUE always, as this should be the entire deserialization process for this object</returns>
        </member>
        <member name="T:Morpheus.CPropertyBase">
            <summary>
            This is the base class for CProperty. It contains the guts required for hooking up notifications.
            </summary>
        </member>
        <member name="T:Morpheus.CPropertyBase.DPropertyChange">
            <summary>
            This is the delegate that notifications must match. 
            </summary>
            <param name="_object">The object containing the property that's changing</param>
            <param name="_propertyName">The name of the property (CFixM_ is applied)</param>
            <param name="_previousValue">The value of the property before changing</param>
            <param name="_newValue">The new value to be assigned to the property</param>
        </member>
        <member name="M:Morpheus.CPropertyBase.RegisterChangeHandler(System.Object,Morpheus.CPropertyBase.DPropertyChange)">
            <summary>
            Called to register change notification handlers with the object. This method will register the change handler with ALL
            CProperty fields in the object.
            </summary>
            <param name="_object">The object containing presumably 1 or more CProperty fields</param>
            <param name="_changeHandler">The handler to be registered with each CProperty field in the object</param>
        </member>
        <member name="M:Morpheus.CPropertyBase.RemoveChangeHandler(System.Object,Morpheus.CPropertyBase.DPropertyChange)">
            <summary>
            Called to remove change notification handlers from the object.
            </summary>
            <param name="_object">The object containing presumably 1 or more CProperty fields</param>
            <param name="_changeHandler">The handler to be removed from each CProperty field in the object</param>
        </member>
        <member name="M:Morpheus.CPropertyBase.GetCPropertiesOnObject(System.Object)">
            <summary>
            For a given object, return a CPropertyBase for each CProperty found on that object's Type
            </summary>
            <param name="_object">The object to search</param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CPropertyBase.SignalPropertyChanged(System.Object,System.Object)">
            <summary>
            Called by CPropery (which inherits from this) to signal a value change
            </summary>
            <param name="_previous">The previous value for the property</param>
            <param name="_new">The value that the property WILL have</param>
        </member>
        <member name="T:Morpheus.MethodProxy">
            <summary>
            This class allows extremely fast invocation for a method in a class identified by a
            <see cref="P:Morpheus.MethodProxy.MethodInfo"/> object.
            </summary>
            <remarks>
            Using this class's <see cref="M:Morpheus.MethodProxy.CreateInvoker(System.Reflection.MethodInfo)"/> method for a slightly more
            performant version of the proxy.
            </remarks>
        </member>
        <member name="P:Morpheus.MethodProxy.MethodInfo">
            <summary>
            The MethodInfo used to create this object
            </summary>
        </member>
        <member name="F:Morpheus.MethodProxy.m_invoker">
            <summary>
            A general lambda form for invoking any method
            </summary>
        </member>
        <member name="M:Morpheus.MethodProxy.#ctor(System.Reflection.MethodInfo)">
            <summary>
            Create a new proxy for a method identified by a <see cref="P:Morpheus.MethodProxy.MethodInfo"/> object.
            </summary>
            <param name="_methodInfo">
            The <see cref="T:System.Reflection.FieldInfo"/> object used to construct this proxy
            </param>
        </member>
        <member name="M:Morpheus.MethodProxy.Invoke(System.Object,System.Object[])">
            <summary>
            Invoke the method via this proxy on an instance object with the supplied parameters.
            </summary>
            <param name="_instanceObject">
            The instance object (the "this") that the method will be invoked on.
            </param>
            <param name="_params">
            The parameters that are to be passed to the method, as an array
            </param>
            <returns>The value that was returned from the method.</returns>
        </member>
        <member name="M:Morpheus.MethodProxy.CreateInvoker(System.Reflection.MethodInfo)">
            <summary>
            Given a <see cref="P:Morpheus.MethodProxy.MethodInfo"/> object, create a generalized Invoker that can
            provide faster Invocation than Reflection will.
            </summary>
            <param name="_methodInfo">
            The <see cref="P:Morpheus.MethodProxy.MethodInfo"/> object representing the method to invoke.
            </param>
            <returns>
            A generalized delegate representing the proxy to the supplied
            <see cref="P:Morpheus.MethodProxy.MethodInfo"/>
            </returns>
            <remarks>
            Using the return value from this static function directly provides a more performant
            invocation of the method.
            </remarks>
        </member>
        <member name="T:Morpheus.ParseStringToObjects">
            <summary>
            This class is designed to take as input a string containing many lines of data and a
            Regular Expression containing named groups/captures. The Regex is used to create records
            out of the data, where each field in each record is named. The names found in the REGEX
            captures are looked for as members on the Type specified when parsing. For each record,
            a new object of the specified Type is created, and its members are populated from the
            named captures found in the Regex.
            </summary>
        </member>
        <member name="E:Morpheus.ParseStringToObjects.OnParseException">
            <summary>
            Called every time the utility could not parse a value into a field/property.
            </summary>
        </member>
        <member name="M:Morpheus.ParseStringToObjects.#ctor(System.Text.RegularExpressions.Regex)">
            <summary>
            Construct with a pre-formed REGEX
            </summary>
            <param name="_regex"></param>
        </member>
        <member name="M:Morpheus.ParseStringToObjects.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Construct with the parameters that would be used to create a new REGEX object
            </summary>
            <param name="_pattern"></param>
            <param name="_options"></param>
        </member>
        <member name="M:Morpheus.ParseStringToObjects.ParseToObjects``1(System.String)">
            <summary>
            Given a string, and using the REGEX specified at construction, break the string down
            into records (Matches) and then populate objects of the specified Type using member
            names found it the named captures.
            </summary>
            <typeparam name="T">The Type of the Returned records</typeparam>
            <param name="_stringData">The string containing the records of data</param>
            <returns>
            An enumeration of type T containing the successfully parsed records from the string
            </returns>
        </member>
        <member name="M:Morpheus.ParseStringToObjects.GetValueSetter``1(System.String,System.Type@)">
            <summary>
            Internal- Can be used to cache "setter" functions.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_name"></param>
            <param name="_memberType"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.ParseStringToObjects.Parse``1(System.Text.RegularExpressions.Regex,System.String)">
            <summary>
            Parse a string into an enumeration of strongly-typed records
            </summary>
            <typeparam name="T">The Type of the Returned records</typeparam>
            <param name="_stringData">The string containing the records of data</param>
            <param name="_regex">The Regex used to parse / validate the records</param>
            <returns>
            An enumeration of type T containing the successfully parsed records from the string
            </returns>
        </member>
        <member name="M:Morpheus.ParseStringToObjects.Parse``1(System.String,System.Text.RegularExpressions.RegexOptions,System.String)">
            <summary>
            Parse a string into an enumeration of strongly-typed records
            </summary>
            <typeparam name="T">The Type of the Returned records</typeparam>
            <param name="_stringData">The string containing the records of data</param>
            <param name="_regex">The Regex used to parse / validate the records</param>
            <param name="_regexOptions">The options used to create the Regex object</param>
            <returns>
            An enumeration of type T containing the successfully parsed records from the string
            </returns>
        </member>
        <member name="T:Morpheus.PropertyOrFieldProxy">
            <summary>
            This class allows extremely fast access to both Fields and Properties on an arbitrary
            object. This provides both GET and SET operations on the members.
            </summary>
            <remarks>
            Using this class's <see cref="M:Morpheus.PropertyOrFieldProxy.CreateAccessors(System.Reflection.MemberInfo)"/> method directly will result
            in slightly faster access times to the field or property than using an instantiated
            object of this class.
            </remarks>
        </member>
        <member name="P:Morpheus.PropertyOrFieldProxy.MemberInfo">
            <summary>
            The <see cref="P:Morpheus.PropertyOrFieldProxy.MemberInfo"/> used to create this object
            </summary>
        </member>
        <member name="P:Morpheus.PropertyOrFieldProxy.FieldInfo">
            <summary>
            The <see cref="P:Morpheus.PropertyOrFieldProxy.MemberInfo"/> used to create this object, as a
            <see cref="P:Morpheus.PropertyOrFieldProxy.FieldInfo"/>
            </summary>
        </member>
        <member name="P:Morpheus.PropertyOrFieldProxy.PropertyInfo">
            <summary>
            The <see cref="P:Morpheus.PropertyOrFieldProxy.MemberInfo"/> used to create this object, as a
            <see cref="P:Morpheus.PropertyOrFieldProxy.PropertyInfo"/>
            </summary>
        </member>
        <member name="F:Morpheus.PropertyOrFieldProxy.m_getter">
            <summary>
            The delegate for getting the value of the member
            </summary>
        </member>
        <member name="F:Morpheus.PropertyOrFieldProxy.m_setter">
            <summary>
            The delegate for setting the value of the member
            </summary>
        </member>
        <member name="M:Morpheus.PropertyOrFieldProxy.#ctor">
            <summary>
            Allow subclass to set things up for itself
            </summary>
        </member>
        <member name="M:Morpheus.PropertyOrFieldProxy.#ctor(System.Reflection.FieldInfo)">
            <summary>
            Create a new proxy for a field identified by a <see cref="P:Morpheus.PropertyOrFieldProxy.FieldInfo"/> object.
            </summary>
            <param name="_fieldInfo">
            The <see cref="P:Morpheus.PropertyOrFieldProxy.FieldInfo"/> object used to construct this proxy
            </param>
        </member>
        <member name="M:Morpheus.PropertyOrFieldProxy.#ctor(System.Reflection.PropertyInfo)">
            <summary>
            Create a new proxy for a property identified by a <see cref="P:Morpheus.PropertyOrFieldProxy.PropertyInfo"/> object.
            </summary>
            <param name="_propertyInfo">
            The <see cref="P:Morpheus.PropertyOrFieldProxy.PropertyInfo"/> object used to construct this proxy
            </param>
        </member>
        <member name="M:Morpheus.PropertyOrFieldProxy.Init(System.Reflection.MemberInfo)">
            <summary>
            Initialize using either MemberInfo
            </summary>
            <param name="_member"></param>
        </member>
        <member name="M:Morpheus.PropertyOrFieldProxy.Get(System.Object)">
             <summary>
             Retrieve the value of the field or property from the supplied object.
             </summary>
             <param name="_instanceObject">
             The instance object (the "this") used to retrieve the field or property value from
             </param>
             <returns>
             The value of the field or property on the _instanceObject provided
             </returns>
             <remarks>
             <code>
            class Data
            {
                public int fieldPrimitive;
                public string fieldObject;
                public double propertyPrimitive { get; set; }
                public Data propertyObject { get; set; }
            }
            
            
            [TestMethod]
            public void TestFieldPrimitiveGet()
            {
                var d = new Data { fieldPrimitive = 7 };
                var fi = typeof( Data ).GetField( "fieldPrimitive" );
                var proxy = new PropertyOrFieldProxy( fi );
                var gotten = proxy.Get( d );
            
                Assert.AreEqual( d.fieldPrimitive, gotten );
            }
            
            
            [TestMethod]
            public void TestFieldObjectGet()
            {
                var d = new Data { fieldObject = "Hi" };
                var fi = typeof( Data ).GetField( "fieldObject" );
                var proxy = new PropertyOrFieldProxy( fi );
                var gotten = proxy.Get( d );
            
                Assert.AreEqual( d.fieldObject, gotten, "Got wrong value" );
            }
             </code>
             </remarks>
        </member>
        <member name="M:Morpheus.PropertyOrFieldProxy.Set(System.Object,System.Object)">
             <summary>
             Set the value of a field or property on a supplied instance object.
             </summary>
             <param name="_instanceObject">
             The instance object (the "this") that will have a field/property set to a new value
             </param>
             <param name="_value">
             The new value for the field/property on the supplied _instanceObject
             </param>
             <remarks>
             <code>
            class Data
            {
                public int fieldPrimitive;
                public string fieldObject;
                public double propertyPrimitive { get; set; }
                public Data propertyObject { get; set; }
            }
            
            
            
            [TestMethod]
            public void TestFieldPrimitiveSet()
            {
                int newVal = 69;
            
                var d = new Data { fieldPrimitive = 7 };
                var fi = typeof( Data ).GetField( "fieldPrimitive" );
                var proxy = new PropertyOrFieldProxy( fi );
                proxy.Set( d, newVal );
            
                Assert.AreEqual( newVal, d.fieldPrimitive );
            }
            
            
            [TestMethod]
            public void TestFieldObjectSet()
            {
                string newVal = "Bye";
            
                var d = new Data { fieldObject = "Hi" };
                var fi = typeof( Data ).GetField( "fieldObject" );
                var proxy = new PropertyOrFieldProxy( fi );
                proxy.Set( d, newVal );
            
                Assert.AreEqual( newVal, d.fieldObject );
            }
             </code>
             </remarks>
        </member>
        <member name="M:Morpheus.PropertyOrFieldProxy.CreateAccessors(System.Reflection.MemberInfo)">
             <summary>
             Helper to create the Getter and Setter functions.
             </summary>
             <param name="_member">The <see cref="P:Morpheus.PropertyOrFieldProxy.MemberInfo"/> for the proxy</param>
             <returns>A Getter and a Setter lambda for the _member.</returns>
             
             <remarks>
             <code>
            class Data
            {
                public int fieldPrimitive;
                public string fieldObject;
                public double propertyPrimitive { get; set; }
                public Data propertyObject { get; set; }
            }
            
            
            
            [TestMethod]
            public void TestCreateAccessors()
            {
                string newVal = "Bye";
            
                var d = new Data { fieldObject = "Hi" };
                var fi = typeof( Data ).GetField( "fieldObject" );
                (var getter, var setter) = PropertyOrFieldProxy.CreateAccessors( fi );
            
                var gotten = getter( d );
                Assert.AreEqual( "Hi", gotten );
            
                setter( d, newVal );
                Assert.AreEqual( newVal, d.fieldObject );
            }
            </code>
             <para> <i> NOTE: Using this static method's return value does improve performance
             over instantiating a class of this type. </i> </para>
             </remarks>
        </member>
        <member name="T:Morpheus.PropertyOrFieldProxy`1">
             <summary>
             Helper, mainly for testing, as these classes are not really useful if you know the code
             structure at compile time.
             </summary>
             <typeparam name="T">The Type of object to apply proxies to</typeparam>
             <remarks>
             <code>
            class Data
            {
                public int fieldPrimitive;
                public string fieldObject;
                public double propertyPrimitive { get; set; }
                public Data propertyObject { get; set; }
            }
            
            
            [TestMethod]
            public void TestPropertyHelper()
            {
                var d = new Data { propertyPrimitive = Math.E };
                var proxy = new PropertyOrFieldProxy&lt;Data>( _x => _x.propertyPrimitive );
                var gotten = proxy.Get( d );
                Assert.AreEqual( d.propertyPrimitive, gotten );
            }
             </code>
             </remarks>
        </member>
        <member name="M:Morpheus.PropertyOrFieldProxy`1.#ctor(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
             <summary>
             Helper constructor taking an Expression which must identify the member to proxy for
             </summary>
             <param name="_memberExpression">
             The <see cref="T:System.Linq.Expressions.Expression"/> identifying the field or property
             </param>
             <remarks>
             <code>
            class Data
            {
                public int fieldPrimitive;
                public string fieldObject;
                public double propertyPrimitive { get; set; }
                public Data propertyObject { get; set; }
            }
            
            
            [TestMethod]
            public void TestPropertyHelper()
            {
                var d = new Data { propertyPrimitive = Math.E };
                var proxy = new PropertyOrFieldProxy&lt;Data>( _x => _x.propertyPrimitive );
                var gotten = proxy.Get( d );
                Assert.AreEqual( d.propertyPrimitive, gotten );
            }
             </code>
             </remarks>
        </member>
        <member name="T:Morpheus.Xml2Object">
             <summary>
             This class is a base class. It allows an application to override this class providing
             decorated properties that correspond to specific nodes in an XML document, assumed to
             reside on disk.
             </summary>
             <remarks> These attributes work very nicely in conjunction with the DataGridView control
             and the <see cref="T:Morpheus.CSortableBindingList`1"/> class.
             <code>
             TODO: Expend this example to include explanation of the /x: namespace shenanigans.
             
            [AXPath( "/x:Project/x:PropertyGroup[not(@Condition)]/x:AssemblyName" )]
            public string AssemblyName
            {
                get => GetNodeText( MethodBase.GetCurrentMethod() );
                set => SetNodeText( MethodBase.GetCurrentMethod(), value );
            }
            
            [AXPath( "/x:Project/x:PropertyGroup[not(@Condition)]/x:RootNamespace" )]
            public string RootNamespace
            {
                get => GetNodeText( MethodBase.GetCurrentMethod() );
                set => SetNodeText( MethodBase.GetCurrentMethod(), value );
            }
             </code></remarks>
        </member>
        <member name="F:Morpheus.Xml2Object.m_doc">
            <summary>
            The XML Document that contains the whole DOM for the data
            </summary>
        </member>
        <member name="F:Morpheus.Xml2Object.m_nsmgr">
            <summary>
            Namespace manager. Namespaces are absolutely critical with XPath.
            </summary>
        </member>
        <member name="F:Morpheus.Xml2Object.m_filename">
            <summary>
            The filename
            </summary>
        </member>
        <member name="P:Morpheus.Xml2Object.IsDirty">
            <summary>
            TRUE when the data has changed.
            </summary>
            <returns>TRUE when the data has changed.</returns>
        </member>
        <member name="P:Morpheus.Xml2Object.IsQuestionable">
            <summary>
            TRUE when there's something fishy with the data
            
            TODO: When? What? How?
            </summary>
        </member>
        <member name="P:Morpheus.Xml2Object.IsReadOnly">
            <summary>
            When
            </summary>
        </member>
        <member name="P:Morpheus.Xml2Object.Filename">
            <summary>
            
            </summary>
        </member>
        <member name="P:Morpheus.Xml2Object.Namespace">
            <summary>
            
            </summary>
        </member>
        <member name="T:Morpheus.Xml2Object.NodeInfo">
            <summary>
            Tuple for linking an XPath string to an <see cref="T:System.Xml.XmlNode"/> .
            </summary>
        </member>
        <member name="P:Morpheus.Xml2Object.NodeInfo.Xpath">
            <summary>
            The XPath string
            </summary>
        </member>
        <member name="P:Morpheus.Xml2Object.NodeInfo.Node">
            <summary>
            The Xml node
            </summary>
        </member>
        <member name="M:Morpheus.Xml2Object.#ctor(System.String)">
            <summary>
            Construct with the name of the XML file and the Namespace string. This class will
            provide access to namespace-qualified nodes via the "x:" alias.
            </summary>
            <param name="_filename">The filename containing the XML</param>
        </member>
        <member name="M:Morpheus.Xml2Object.UndoChanges">
            <summary>
            Throw away this XmlDocument and replace it with what is on disk.
            </summary>
        </member>
        <member name="M:Morpheus.Xml2Object.SaveToFile">
            <summary>
            Write the current XmlDocument to disk (the same filename that was used to read the
            file)
            </summary>
        </member>
        <member name="M:Morpheus.Xml2Object.ReReadReadOnly">
            <summary>
            Re-check the ReadOnly flag. Likely important for Perforce integration.
            </summary>
        </member>
        <member name="M:Morpheus.Xml2Object.LoadXmlDocument">
            <summary>
            Load an XML document from a file
            </summary>
        </member>
        <member name="M:Morpheus.Xml2Object.ClearNodeCache(System.Boolean)">
            <summary>
            Should be called by the subclass whenever the STRUCTURE (not the "InnerText" values)
            of the <see cref="T:System.Xml.XmlDocument"/> change.
            </summary>
            <param name="_makeDirty">Make this "dirty" at the same time</param>
        </member>
        <member name="M:Morpheus.Xml2Object.GetNode(System.Reflection.MethodBase,System.String@)">
            <summary>
            Get an <see cref="T:System.Xml.XmlNode"/> using the decoration <see cref="T:Morpheus.AXPath"/> on the
            <see cref="T:System.Reflection.MethodBase"/> . Returns the XPath string from the AXPath decoration.
            </summary>
            <remarks>
            This method DOES NOT catch exceptions. If the application references a non-existent
            node in the document, it will try to create it. If it can't, then an exception is
            probably going to be thrown.
            </remarks>
            <param name="_methodBase"></param>
            <param name="_xpath"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.Xml2Object.GetNodeText(System.Reflection.MethodBase)">
            <summary>
            Get node text for
            </summary>
            <param name="_methodBase"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.Xml2Object.SetNodeText(System.Reflection.MethodBase,System.String)">
            <summary>
            Set node text
            </summary>
            <param name="_methodBase"></param>
            <param name="_text"></param>
        </member>
        <member name="M:Morpheus.Xml2Object.RemoveNode(System.String)">
            <summary>
            
            </summary>
            <param name="_xpath"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.Xml2Object.AssureNode(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="_root"></param>
            <param name="_elementName"></param>
            <param name="_innerText"></param>
        </member>
        <member name="T:Morpheus.ADoNotSerialize">
            <summary>
            This attribute instructs the Serializer to NEVER serialize the field or the class that this
            is applied to. For fields, this may simply mean that a field has no persisting meaning or 
            is very volatile. 
            
            For classes, this prevents the framework from serializing the class (maybe due to sensitive 
            data, or whatever). This will override the <see cref="T:Morpheus.AExplicitlySerialize"/> attribute
            placed on fields in the class- use that same attribute on the class if that's the behavior
            desired.
            
            Further, when used on a class, this will prevent any implicit serialization of that class.
            Again, if you want to use implicit serialization, use the <see cref="T:Morpheus.AExplicitlySerialize"/>
            attribute.
            </summary>
        </member>
        <member name="T:Morpheus.AExplicitlySerialize">
            <summary>
            This attribute instructs the Serializer to ALWAYS serialize the field -or- to only 
            serialize fields of a class that have this attribute on them.
            </summary>
            <remarks>
            This attribute will signal the fields that DO get serialized.
            
            When this attribute is used on a class, then the framework will only serialize fields 
            from that class that have this attribute on them.
            </remarks>
        </member>
        <member name="T:Morpheus.AImplicitDeserializer">
            <summary>
            This attribute must only be used on a constructor of a class, or on a static method of the class that is meant
            to construct the object using an XmlElement. The constructor must take one or three parameters. The first (and 
            required) parameter is an XmlElement or an XmlNode that will represent the serialized version of the object. 
            The second and third (optional) parameters will be the <see cref="T:Morpheus.CWorkingObject"/> and <see cref="T:Morpheus.CDeserializer"/> 
            objects that are controlling the deserialization.
            
            The return type must be either void or bool. If it is bool, then a TRUE value implies that the object was completely
            deserialized, FALSE implies that more work needs to be done by the framework
            </summary>
        </member>
        <member name="T:Morpheus.AImplicitSerializer">
            <summary>
            This attribute must only be used on a non-static method of a class that is meant to turn
            the object into an Xml fragment.
            </summary>
            <remarks>
            The method must take either one or two parameters. The first (and required) parameter is
            an XmlElement or an XmlNode that represents the document fragment into which this object
            will be serialized. The second (and optional) parameter will be the
            <see cref="T:Morpheus.Serialization.CFramework"/> object that is controlling the serialization.
            </remarks>
        </member>
        <member name="T:Morpheus.ASerializedName">
            <summary>
            Use this attribute to rename a field for purposes of serialization. This is a very 
            specific form of renaming, as opposed to the bulk-renaming accomplished with 
            IFieldRenamer.
            </summary>
            <remarks>
            This attribute will override any class-specific <see cref="T:Morpheus.IFieldRenamer"/> uses, 
            which are set up using the <see cref="T:Morpheus.AUseFieldRenamer"/> attribute. 
            
            This attribute WILL NOT override "global" renamers, as these are assumed to be useful 
            based on run-time configuration and need to deal with things like this. However, the 
            name given by this attribute to a field WILL be the name sent to the global renamer.
            </remarks>
        </member>
        <member name="M:Morpheus.ASerializedName.#ctor(System.String)">
            <summary>
            This attribute must be constructed using a string representing the new name
            </summary>
            <param name="_newName"></param>
        </member>
        <member name="P:Morpheus.ASerializedName.NewName">
            <summary>
            The field is to be known by this name when it is serialized, or it is to be populated from 
            the Xml node named this when it is deserialized
            </summary>
        </member>
        <member name="T:Morpheus.AUseEntitySemantics">
            <summary>
            This attribute tells the serialization framework to use EntitySemantics when serializing
            objects of this class. See documentation in <see cref="T:Morpheus.Serialization.CEntityTypeData"/>
            for more information about EntitySemantics.
            </summary>
        </member>
        <member name="F:Morpheus.AUseEntitySemantics.DefaultPreferredCollectionType">
            <summary>
            Exposed for all to see the preferred collection type
            </summary>
        </member>
        <member name="F:Morpheus.AUseEntitySemantics.PreferredCollectionType">
            <summary>
            Use this generic type when deserializing Entities that have collection properties
            that are of type ICollection{T}
            </summary>
        </member>
        <member name="M:Morpheus.AUseEntitySemantics.#ctor">
            <summary>
            Default constructor uses List{} for the preferred collection
            </summary>
        </member>
        <member name="M:Morpheus.AUseEntitySemantics.#ctor(System.Type)">
            <summary>
            Construct with a preferred entity type. Should be like "List{}" (no Type specified
            within the angle-brackets)
            </summary>
            <param name="_preferredEntityType">
            Should be like "List{}" (no Type specified within the angle-brackets)
            </param>
        </member>
        <member name="T:Morpheus.AUseFieldRenamer">
            <summary>
            This attribute allows a class to designate a specific field renamer to use on all 
            fields in the class.
            </summary>
        </member>
        <member name="P:Morpheus.AUseFieldRenamer.RenamerType">
            <summary>
            Expose the Type to the framework
            </summary>
        </member>
        <member name="P:Morpheus.AUseFieldRenamer.DynamicRenaming">
            <summary>
            When this is TRUE, the Type specified may change the way it transforms names during run-time, thus
            requiring the framework to call the renamer each and every time a field is asked for its name. When
            its FALSE, the renamer will ALWAYS rename fields using the same algorithm, thus allowing the framework
            to call it a single time and then store the results for future uses (and as a byproduct, it can release
            the reference to the instantiated object)
            </summary>
        </member>
        <member name="M:Morpheus.AUseFieldRenamer.#ctor(System.Type)">
            <summary>
            This attribute must be constructed using the Type which implements an IFieldRenamer
            </summary>
            <param name="_typeImplementingIFieldRenamer">The System.Type of the object that 
            can rename the fields in this class.</param>
        </member>
        <member name="T:Morpheus.CArrayDeserializationHelper">
            <summary>
            This class is support for deserializing arrays. This is a complex process when one wants to be "flexible" about handling array
            deserialization.
            </summary>
            <remarks>
            This class is responsible for keeping track of the array and the elements of the array. It is not responsible for any analysis
            of the XML itself.
            
            After construction, this class allows the deserializer a mechanism to add information to the array without needing to keep track
            of information such as "current index", while at the same time allowing the application the ability to "adjust" the current index
            if needed.
            </remarks>
        </member>
        <member name="P:Morpheus.CArrayDeserializationHelper.Array">
            <summary>
            Access to the underlying array resulting from the object's operation
            </summary>
        </member>
        <member name="P:Morpheus.CArrayDeserializationHelper.ElementType">
            <summary>
            The expected Type of each element in the array
            </summary>
        </member>
        <member name="M:Morpheus.CArrayDeserializationHelper.#ctor(System.Array)">
            <summary>
            Construct using an "existing object", or a "working object" presumably taken from a surrogate
            </summary>
            <param name="_array"></param>
        </member>
        <member name="M:Morpheus.CArrayDeserializationHelper.#ctor(System.Type,System.Int32[],System.Int32[])">
            <summary>
            Construct an array from information presumably found in the XML
            </summary>
            <param name="_elementType"></param>
            <param name="_lengths"></param>
            <param name="_lowerBounds"></param>
        </member>
        <member name="M:Morpheus.CArrayDeserializationHelper.ResetIndicies">
            <summary>
            Set the current indicies to equal the lower-bound for each dimension
            </summary>
        </member>
        <member name="M:Morpheus.CArrayDeserializationHelper.SetIndicies(System.Int32[])">
            <summary>
            Used to set the "Current indicies" by the application, most likely when the XML has an explicit 'Index' attribute
            </summary>
            <param name="_newIndicies">The indicies to set the currentIndex array to.</param>
        </member>
        <member name="M:Morpheus.CArrayDeserializationHelper.GetHighestIndex(System.Int32)">
            <summary>
            Return the highest allowable index for the given dimension. Valid Indicies are between m_lowerBound and GetHighestIndex, INCLUSIVE
            </summary>
            <param name="_dimension">The dimension of the index to check for</param>
            <returns>The highest valid index for that dimension, INCLUSIVE</returns>
        </member>
        <member name="M:Morpheus.CArrayDeserializationHelper.IncrementIndicies">
            <summary>
            This routine will increment the indicies by one. The return value denotes whether or not this was successful.
            </summary>
            <returns>TRUE if the indicies were incremented, FALSE if they weren't due to the array being "full" (all indicies at their max)</returns>
        </member>
        <member name="M:Morpheus.CArrayDeserializationHelper.Add(System.Object)">
            <summary>
            Add an object to the array. Increment the indicies after the item is added.
            </summary>
            <param name="_objectToAdd">The object being added to the array</param>
            <returns>TRUE if the array has more space in it, FALSE if it doesn't.</returns>
        </member>
        <member name="T:Morpheus.Serialization.CArraySerializationHelper">
            <summary>
            Helper class to contain the "State" data for a recursive algorithm used to serialize
            a multi-dimensional array of objects
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CArraySerializationHelper.#ctor(System.Array,System.Xml.XmlElement,Morpheus.CSerializer)">
            <summary>
            Construct the recursive serializer with basic information about its environment
            </summary>
            <param name="_array">The array that its going to serialize</param>
            <param name="_xmlToAddTo">The XML node that the array data is to be added to</param>
            <param name="_serializer">The serializer that will handle serialization of array elements</param>
        </member>
        <member name="M:Morpheus.Serialization.CArraySerializationHelper.EstablishSimpleElementProcessing">
            <summary>
            "Simple Arrays" are arrays of primitives or strings. These arrays can be turned into strings containing
            comma-separated values. Doing so greatly reduces the resulting dataset, but is less "friendly" to XML processing.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CArraySerializationHelper.GenerateAttributeInfo">
            <summary>
            Generate lower-bounds and length arrays from the configuration data of the Array. Add this information
            as attribute information on the Xml that we're serializing to.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CArraySerializationHelper.Serialize">
            <summary>
            Serialize the array using the data that this instance was constructed with.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CArraySerializationHelper.HandleSimpleElements">
            <summary>
            If there was a simple-element serialization, then add the results to the XML as this was not done during
            serialization for performance reasons.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CArraySerializationHelper.AddArrayDimensionToXml(System.Int32)">
            <summary>
            The recursive method that uses a current "Rank" parameter to determine where in the recursion we are.
            </summary>
            <param name="_rank"></param>
        </member>
        <member name="M:Morpheus.Serialization.CArraySerializationHelper.AddArrayElementToXml">
            <summary>
            Use the data found in the recursion state (this object) to serialize a single element in the array to Xml.
            </summary>
        </member>
        <member name="T:Morpheus.Serialization.CEntityTypeData">
            <summary>
            This class encapsulates reflected information about an Entity (see Entity Framework)
            </summary>
            <remarks>
            About EntitySemantics:
            
            The largest difference is that Properties are used in addition to Fields. Also, because
            Entities must conform to numerous EntityFramework rules, the serializer doesn't give as
            much control to the application when serializing. Public Fields will be handled, as
            Unity3d's editor deals with Public Fields instead of Properties. However, the
            application needs to be aware that Microsoft's Entity Framework does not "handle"
            fields- it only handles properties.
            
            The goal is to create a serialization that ignores all Proxy information (from the
            EntityFramework) and can be DeSerialized into a "vanilla" version of the Entity (sans
            Proxy stuff). While the typical method of operation will have the server and client use
            the same Assembly with the same Data Entities, allowances are made for a situation where
            a client needs a "Unity3d Friendly" version of the client object.
            
            With the exception of <see cref="T:Morpheus.ADoNotSerialize"/> and <see cref="T:Morpheus.ASerializedName"/> ,
            none of the other attributes are honored for Entities. Namely, Surrogates are not
            supported (yet), as Entities are supposed to be of a very basic data-representation
            form. It would be easy to support Surrogates, but philosophically I believe its more
            important that Data Entities stay true to form.
            
            Properties and Fields will only be serialized if: (a) They inherit from
            <see cref="T:System.Collections.ICollection"/> -or- (b) They inherit from
            <see cref="T:System.Collections.ICollection"/> (c) Collection Properties must have public Getter (d)
            Non-collection Properties must have public Getter AND Setter (e) Fields must be Public
            
            Even though I decided to support Fields AND Properties. I expect the target Type to
            still be "Entity-Like", in that its purpose needs to stay true to a "Data Representation
            Only" class (as opposed to, say, the System.IO.File class, which represents more of an
            interfacing mechanism and not so much a Data Representatino). Unlike normal
            De/serialization, ONLY public fields will be de/serialized, as the sole reason for this
            allowance (fields instead of properties on de/serialization) is that the Unity Editor
            only exposes Public Fields to the designer.
            </remarks>
        </member>
        <member name="F:Morpheus.Serialization.CEntityTypeData.sm_cache">
            <summary>
            Cache so that we don't have to re-figure-out Types more than once. If the key's
            value is NULL, we have tested the Type for EntitySemantics and found that the Type
            should NOT use EntitySemantics.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CEntityTypeData.GetTypeData(System.Type)">
            <summary>
            Given a Type, return its CEntityTypeData. If the Type has been seen before, a cached
            version will be returned. This ASSUMES that _type will use EntitySemantics. To
            check, use <see cref="M:Morpheus.Serialization.CEntityTypeData.UsesEntitySemantics(System.Type)"/>
            </summary>
            <param name="_type">The Type to get information about</param>
            <returns>New Entity-Meaningful TypeData for an Entity</returns>
        </member>
        <member name="M:Morpheus.Serialization.CEntityTypeData.UsesEntitySemantics(System.Type)">
            <summary>
            The determiner of whether a Type is to use EntitySemantics
            </summary>
            <param name="_type"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.Serialization.CEntityTypeData.StripProxyType(System.Type)">
            <summary>
            Helper function to get an Entity's Type sans the Proxy
            </summary>
            <param name="_type">The type to check</param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.Serialization.CEntityTypeData.IsProxyClass(System.Type)">
            <summary>
            The check that determines if a Type is a Proxy Class. Does not check to see if the
            Type should be handled with EntitySemantics.
            </summary>
            <param name="_type">The Type to check for Proxy status</param>
            <returns>TRUE if the Type is an EntityFramework Proxy</returns>
        </member>
        <member name="M:Morpheus.Serialization.CEntityTypeData.#ctor(System.Type,Morpheus.AUseEntitySemantics)">
            <summary>
            Basically construct the entire pertinent information for an Entity Type
            </summary>
            <param name="_type">
            The Type of the entity- If this is a Proxy type (the Namespace is ""), then the
            BaseType will be taken instead
            </param>
            <param name="_attribute">The UseEntitySemantics attribute, if available</param>
        </member>
        <member name="T:Morpheus.Serialization.CFieldData">
            <summary>
            This class is used to track information about a specific field on a class. This is considered "immutable" data in that
            it will never be modified by any "current serialziation context". However, the current context CAN ignore any of the 
            directives here if it needs to.
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CFieldData.m_typeData">
            <summary>
            The TypeData object that this field belongs to. Used for the auto-field-renaming aspect.
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CFieldData.m_fieldName">
            <summary>
            This is, for all intents and purposes, the name by what the framework should know this field by. If it is NULL,
            then the XmlName property will query the m_typeData object for the name of the field.
            </summary>
        </member>
        <member name="P:Morpheus.Serialization.CFieldData.Field">
            <summary>
            The FieldInfo object that this data object represents
            </summary>
        </member>
        <member name="P:Morpheus.Serialization.CFieldData.DoNotSerialize">
            <summary>
            When set, this field is never to be serialized.
            </summary>
        </member>
        <member name="P:Morpheus.Serialization.CFieldData.ExplicitlySerialize">
            <summary>
            When set, this field should ALWAYS be serialized by the framework- this has no effect if a surrogate is handling serialization
            </summary>
        </member>
        <member name="P:Morpheus.Serialization.CFieldData.XmlName">
            <summary>
            The name that should be used for the XmlNode for this field
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CFieldData.#ctor(System.Reflection.FieldInfo,Morpheus.Serialization.CTypeData)">
            <summary>
            Construct the field data from a FieldInfo object. Internal Constructor means that noone outside this library
            should be creating objects of this class.
            </summary>
            <param name="_fieldInfo">The FieldInfo object</param>
            <param name="_typeData">The TypeData object that is constructing this CFieldData</param>
        </member>
        <member name="M:Morpheus.Serialization.CFieldData.HasAttribute(System.Type)">
            <summary>
            Use this method to check to see if this field has a particular attribute
            </summary>
            <param name="_attributeType">The <see cref="T:System.Type"/> of the attribute that the application is looking for</param>
            <returns>TRUE if the field has the attribute associated with it.</returns>
        </member>
        <member name="M:Morpheus.Serialization.CFieldData.GetAttributes(System.Type)">
            <summary>
            Get the attributes of the given type that are associated with the field.
            </summary>
            <param name="_attributeType">The Type of the attribute that the application is interested in</param>
            <returns>An array of Attributes that meet the Type specified</returns>
        </member>
        <member name="M:Morpheus.Serialization.CFieldData.GetAttribute``1">
            <summary>
            Get a single attribute of the Type specified as the generic parameter for this method.
            </summary>
            <typeparam name="TAttributeType">The Type of the attribute requested</typeparam>
            <returns>NULL if the attribute was not found, or the first attribute found in the custom attributes
            of the requested type.</returns>
        </member>
        <member name="T:Morpheus.Serialization.CFramework">
            <summary>
            This is the base class for both the serializer and the deserializer in the Morpheus library.
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CFramework.TYPEOF_STRING">
            <summary>
            typeof(string)
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CFramework.TYPEOF_INTPTR">
            <summary>
            typeof(IntPtr)
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CFramework.TYPEOF_UINTPTR">
            <summary>
            typeof(UIntPtr)
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CFramework.TYPEOF_DELEGATE">
            <summary>
            typeof(Delegate)
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CFramework.TYPEOF_MULTICAST_DELEGATE">
            <summary>
            typeof(System.MulticastDelegate)
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CFramework.sm_frameworkSurrogates">
            <summary>
            This dictionary contains External Surrogates defined by the Morpheus framework
            </summary>
            <remarks>
            Mainly contains help for Collections, but this is for anything in the .NET framework that needs help with 
            serialization. This feature is particularly helpful for framework elements that rely too heavily on OO principals 
            instead of Interface-driven design (a perfect example is "synchronized" or "readonly" forms of ArrayList). Since 
            there are no parameter-less constructors for those classes that inherited Arraylist, we need to define surrogates 
            that can generate those classes properly.
            </remarks>
        </member>
        <member name="M:Morpheus.Serialization.CFramework.#cctor">
            <summary>
            The static constructor sets up the external surrogates for framework classes.
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CFramework.m_context">
            <summary>
            The context for serialization / deserialization
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CFramework.m_ignoredFields">
            <summary>
            This is used by surrogates to tell the framework to ignore certain fields when handling a class. If any surrogates
            are defined for the class, the surrogates may or may not ignore these ignored fields. Specifically, surrogates
            are the only way to actually declare fields as "ignored" fields.
            </summary>
            <remarks>
            We do not allocate an actual List for these fields until a surrogate actually declares an ignored field.
            This is because ignored fields should probably be pretty rare.
            </remarks>
        </member>
        <member name="F:Morpheus.Serialization.CFramework.m_fieldStack">
            <summary>
            This stack contains the "vertical history" of the fields starting at the top of the object tree heading down
            to the current field being processed at whatever depth in the tree. The stack is used because any surrogate
            will always be interested in the "last-in" value.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CFramework.#ctor(Morpheus.CSerializationContext)">
            <summary>
            Construct with a specific context in mind. Use <see cref="F:Morpheus.CSerializationContext.Global"/> when
            the parameter is NULL.
            </summary>
            <param name="_context">The context for serialization</param>
        </member>
        <member name="M:Morpheus.Serialization.CFramework.#ctor">
            <summary>
            Construct with the "Global" context.
            </summary>
        </member>
        <member name="P:Morpheus.Serialization.CFramework.Context">
            <summary>
            The context for serialization / deserialization
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CFramework.PushCurrentField(Morpheus.Serialization.CFieldData)">
            <summary>
            Push a field onto the fieldStack
            </summary>
            <param name="_field">The field to push onto the stack</param>
        </member>
        <member name="M:Morpheus.Serialization.CFramework.PopField">
            <summary>
            Remove the top field from the fieldStack
            </summary>
        </member>
        <member name="P:Morpheus.Serialization.CFramework.TopField">
            <summary>
            Get the "Top" field on the fieldStack, or NULL if the fieldStack is empty
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CFramework.GetFieldName(Morpheus.Serialization.CFieldData)">
            <summary>
            Use context renamers to get the appropriate name for a field.
            </summary>
            <param name="_fieldData">The FieldData describing (in framework terms) this field</param>
            <returns>The name that should be used for the field</returns>
        </member>
        <member name="M:Morpheus.Serialization.CFramework.HasAttribute(System.Type)">
            <summary>
            Allows the application/surrogate to ask the framework whether or not the object field being
            (de)serialized has a particular attribute associated with it.
            </summary>
            <param name="_attributeType">The Type of the attribute interested in </param>
            <returns>TRUE if the field has the attribute, FALSE if it doesn't OR if the surrogate received
            a value that is not a field (a top-level value)</returns>
        </member>
        <member name="M:Morpheus.Serialization.CFramework.GetAttribute``1">
            <summary>
            Allows the application/surrogate to ask the framework for a single instance of an attribute
            of the Type specified as the generic-parameter to this generic-function.
            </summary>
            <typeparam name="TAttributeType">The Type of the attribute requested.</typeparam>
            <returns>NULL if there are no attributes of the specified Type, or the First attribute found
            if any attribute are present.</returns>
        </member>
        <member name="M:Morpheus.Serialization.CFramework.GetAttributes(System.Type)">
            <summary>
            Allows the application/surrogate to ask the framework for all instances of attributes of
            the Type specified as the parameter to this method.
            </summary>
            <param name="_attributeType">The Type of the attributes interested in</param>
            <returns>An array of attributes all of which are of the Type specified.</returns>
        </member>
        <member name="M:Morpheus.Serialization.CFramework.ConvertStringArrayToCommaList(System.Array)">
            <summary>
            Given an array of strings, convert the array into a comma-separated list. Make sure to properly
            process the raw string elements to make sure that commas are "escaped".
            </summary>
            <param name="_array">The array with string elements in it.</param>
            <returns>A string containing all elements in the array as a comma-separated list.</returns>
        </member>
        <member name="M:Morpheus.Serialization.CFramework.ProtectStringForStringlist(System.String)">
            <summary>
            By "Protecting" a string, we are adding an ESCAPE character and "Escaping" both that escape char AND the comma, which is
            used only as a list item separator. This also deals with a special "Escape" for empty strings in order to separate them 
            from null strings.
            </summary>
            <param name="_rawString">The string to protect</param>
            <returns>A properly escaped string, suitable for inclusion in a comma-separated list of strings.</returns>
        </member>
        <member name="M:Morpheus.Serialization.CFramework.UnprotectStringFromStringlist(System.String)">
            <summary>
            Unprotect the string from the stringList- remove escape sequences
            </summary>
            <param name="_string">the string to unprotect</param>
            <returns>the unprotected string</returns>
        </member>
        <member name="M:Morpheus.Serialization.CFramework.IsValidType(System.Type)">
            <summary>
            Determine if the Type passed in is valid for serialization. Essentially, pointers or equivalents are not valid.
            </summary>
            <param name="_type">The System.Type to check</param>
            <returns>TRUE if the Type is valid for serialization by the framework, FALSE if not.</returns>
        </member>
        <member name="M:Morpheus.Serialization.CFramework.StartProcessing">
            <summary>
            Called by Serialize or Deserialize to initiate state variables for a start-to-finish (de)serialize operation.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CFramework.IgnoreField(System.String)">
            <summary>
            Instruct the framework to ignore a field. Used by surrogates that handle only partial-class serialization. 
            The "Ignore Fields" feature of the framework only addresses fields declared in the "current" type- in other words, 
            fields declared in sub-classes are NOT ignored.
            </summary>
            <remarks>
            Multiple calls with the same field name will not cause errors, but it will incur a slight overhead, especially if other
            field names are ignored after the multiple.
            </remarks>
            <param name="_fieldName">The name of the field to ignore.</param>
        </member>
        <member name="M:Morpheus.Serialization.CFramework.ClearIgnoredFields">
            <summary>
            Clear the list of "ignored" fields
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CFramework.IsIgnoredField(System.String)">
            <summary>
            Determine if a given field name is meant to be ignored.
            </summary>
            <param name="_fieldName">The FieldName to check for.</param>
            <returns>TRUE if a surrogate has requested that the field be ignored, FALSE if not.</returns>
        </member>
        <member name="M:Morpheus.Serialization.CFramework.GetExternalSurrogate(System.Type)">
            <summary>
            This baseclass function allows serializers or deserializers to check for external surrogates for the given Type.
            This routine will look everywhere that external surrogates could be found- for now, that's the default Framework
            stuff and anything found in the Context.
            </summary>
            <param name="_type">The Type that we're checking for external surrogates</param>
            <returns>An IExternalSurrogate for _type, if anything exists.</returns>
        </member>
        <member name="M:Morpheus.Serialization.CFramework.GetNameForCollectionElement">
            <summary>
            Used by surrogates that deal with series of elements (arrays, collections) to figure out what to name each element for the
            collection
            </summary>
            <returns>The name to use for each element.</returns>
        </member>
        <member name="M:Morpheus.Serialization.CFramework.FixMemberName(System.String)">
            <summary>
            Determine if a member name needs to be altered because it would otherwise not be a valid XML element name
            </summary>
            <remarks>
            Mainly caused by auto-generated backing fields for Properties with {get;set;} semantic
            </remarks>
            <param name="_memberName">The name of the reflected member</param>
            <returns>A string appropriate for use as an XmlElement name</returns>
        </member>
        <member name="T:Morpheus.Serialization.CPropertyData">
            <summary>
            Contains a form of PropertyInfo for a Type that uses EntitySemantics.
            </summary>
        </member>
        <member name="P:Morpheus.Serialization.CPropertyData.Name">
            <summary>
            The Name to use for the property in serialization / deserialization. Doesn't 
            necessarily match PropertyInfo.Name if a renamer has been employed.
            </summary>
        </member>
        <member name="P:Morpheus.Serialization.CPropertyData.PropertyType">
            <summary>
            The Type of the Property represented by this object
            </summary>
        </member>
        <member name="P:Morpheus.Serialization.CPropertyData.ReflectedPropertyInfo">
            <summary>
            The PropertyInfo object for this Property
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CPropertyData.#ctor(System.Reflection.PropertyInfo)">
            <summary>
            Must construct with a PropertyInfo object from Reflection
            </summary>
            <param name="_propInfo">The Reflected information about the property</param>
        </member>
        <member name="M:Morpheus.Serialization.CPropertyData.SetValue(System.Object,System.Object)">
            <summary>
            Set the value of the Property
            </summary>
            <param name="_object">The object to set the value on</param>
            <param name="_value">The value of the property to set</param>
        </member>
        <member name="M:Morpheus.Serialization.CPropertyData.GetValue(System.Object)">
            <summary>
            Get the value of the property on a given object
            </summary>
            <param name="_object">The object to query for the value</param>
        </member>
        <member name="T:Morpheus.Serialization.CTypeData">
            <summary>
            This class contains Serializer-interesting data about a given Type. It contains Declared-Only fields- fields belonging to a base
            class are found on the m_baseType member of this class.
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CTypeData.sm_typeTable">
            <summary>
            A Cache of all of the Type's that have had CTypeData generated for them before.
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CTypeData.m_fields">
            <summary>
            All of the fields for this Type.
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CTypeData.m_onlySerializeExplicitFields">
            <summary>
            When Set by adding the <see cref="T:Morpheus.AExplicitlySerialize"/> attribute to the CLASS, only fields with this attribute will be added to the field-list
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CTypeData.m_doNotSerialize">
            <summary>
            This is set when the class has the <see cref="T:Morpheus.ADoNotSerialize"/> attribute on it. This merely makes sure that no fields on the class are serialized.
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CTypeData.m_renamer">
            <summary>
            The Renamer specified by adding a <see cref="T:Morpheus.AUseFieldRenamer"/> attribute to the CLASS and setting the Type of the renamer as the attribute-parameter.
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CTypeData.m_dynamicFieldRenamer">
            <summary>
            When TRUE, the CFieldData object has to call the <see cref="M:Morpheus.Serialization.CTypeData.RenameField(System.String,System.Reflection.FieldInfo)"/> method for each and every
            time its name is queried. FALSE means that the m_renamer can be set to null after all fields are "discovered".
            </summary>
        </member>
        <member name="P:Morpheus.Serialization.CTypeData.Type">
            <summary>
            The Type for this object
            </summary>
        </member>
        <member name="P:Morpheus.Serialization.CTypeData.BaseType">
            <summary>
            The Base Type data for this Type.
            </summary>
        </member>
        <member name="P:Morpheus.Serialization.CTypeData.ImplicitSurrogate">
            <summary>
            The Implicit Surrogate information for the Type. If this value is null, then there are no implicit surrogates.
            </summary>
        </member>
        <member name="P:Morpheus.Serialization.CTypeData.ExplicitSurrogate">
            <summary>
            The Explicit Surrogate information for the Type. If this value is null, then there are no explicit surrogates.
            </summary>
        </member>
        <member name="P:Morpheus.Serialization.CTypeData.FieldCount">
            <summary>
            The number of serializable fields for this type
            </summary>
        </member>
        <member name="P:Morpheus.Serialization.CTypeData.Item(System.Int32)">
            <summary>
            Indexing the CTypeData object will return the CFieldData for the field at the specified index.
            </summary>
            <param name="_index">The index of the field desired</param>
            <returns>The CFieldData object for the requested field.</returns>
        </member>
        <member name="P:Morpheus.Serialization.CTypeData.Item(System.String)">
            <summary>
            Index the Fields array based on the fieldName of the field
            </summary>
            <param name="_fieldName">The name of the field</param>
            <returns>The CFieldData for the field named _fieldName, or NULL if on field by that name exists</returns>
        </member>
        <member name="M:Morpheus.Serialization.CTypeData.GetTypeData(System.Type)">
            <summary>
            The External interface into this class- Find a CTypeData object for a given Type. Uses the cache to 
            limit the amount of processing performed.
            </summary>
            <param name="_type">The Type to search for</param>
            <returns>A CTypeData object containing interesting features of the Type</returns>
        </member>
        <member name="M:Morpheus.Serialization.CTypeData.#ctor(System.Type)">
            <summary>
            Must construct one of these with a Type. Private constructor means that only this class may create an
            object of this type.
            </summary>
            <param name="_type">The Type to generate data for</param>
        </member>
        <member name="M:Morpheus.Serialization.CTypeData.GenerateAttributeData">
            <summary>
            For the m_type, analyse the attributes on the Type and store the useful ones in this object
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CTypeData.GenerateFieldData">
            <summary>
            This method will enumerate over all of the object's fields and generate the m_fields list.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CTypeData.GenerateBaseClassData">
            <summary>
            Generate meaningful data for the base-type of this type.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CTypeData.GetImplicitSurrogate">
            <summary>
            Get the implicit surrogate information for the Type.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CTypeData.TryExplicitConstructor">
            <summary>
            If there is an explicit constructor defined, then invoke it and return the object that was created.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Morpheus.Serialization.CTypeData.RenameField(System.String,System.Reflection.FieldInfo)">
            <summary>
            Used by the CFieldData object to generate an appropriate Xml Name for a field
            </summary>
            <param name="_fieldName">The name of the field to rename</param>
            <param name="_fieldInfo">The FieldInfo data from the CFieldData object</param>
            <returns>NULL if there is no rename performed, or the new XmlName if the field is to be renamed.</returns>
        </member>
        <member name="T:Morpheus.Serialization.CDictionarySurrogate">
            <summary>
            This surrogate will (de)serialize the <see cref="T:System.Collections.Generic.Dictionary`2"/> class.
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CDictionarySurrogate.KEY_ELEMENT_NAME">
            <summary>
            This matches the name of the "key" Field in KeyValuePair
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CDictionarySurrogate.VALUE_ELEMENT_NAME">
            <summary>
            This matches the name of the "value" Field in KeyValuePair
            </summary>
        </member>
        <member name="P:Morpheus.Serialization.CDictionarySurrogate.NumberOfExpectedTypes">
            <summary>
            A Dictionary actually has 2 generic Types in the definition- one for the Key, and one for the Value
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CDictionarySurrogate.GetCollectionElements(System.Object)">
            <summary>
            For serializtion, we need to make sure we're extracting the non-generic <see cref="T:System.Collections.DictionaryEntry"/> elements
            from the collection.
            </summary>
            <remarks>
            By default, the base class would iterate over the Dictionary's default iterator, which would return generic 
            KeyValuePair's. The actual Type of these elements would not be known at compile time, so we cannot expect to
            see these objects here. Instead, we iterate over the more simplistic IDictionary interface which returns 
            the non-generic DictionaryEntry objects.
            </remarks>
            <param name="_collection">The collection, assumed to be a generic Dictionary.</param>
            <returns>An enumeration appropriate for the serialization of the Dictionary</returns>
        </member>
        <member name="M:Morpheus.Serialization.CDictionarySurrogate.AddElementToXml(System.String,System.Object,System.Xml.XmlElement,System.Type[],Morpheus.CSerializer)">
            <summary>
            Add each element of the collection (a <see cref="T:System.Collections.DictionaryEntry"/> to the Xml
            </summary>
            <param name="_name">The name for the element</param>
            <param name="_element">The element from the collection</param>
            <param name="_parentElement">The Xml to receive the element</param>
            <param name="_expectedTypes">The Expected Types for the element's components</param>
            <param name="_serializer">The serializer handling the serialization process.</param>
        </member>
        <member name="M:Morpheus.Serialization.CDictionarySurrogate.AddElementFromXml(System.Object,System.Xml.XmlElement,System.Type[],Morpheus.CDeserializer)">
            <summary>
            Add an Xml ChildNode to the collection being deserialized
            </summary>
            <param name="_collection">The collection that's being deserialized</param>
            <param name="_xmlElement">The XmlElement containing the data for this element</param>
            <param name="_expectedTypes">The expected Type(s) for this element</param>
            <param name="_deserializer">The deserialization framework controlling this process</param>
        </member>
        <member name="T:Morpheus.Serialization.CGenericCollectionsBaseSurrogate">
            <summary>
            This base class provides the logic for the serialization and deserialization of generic collections. It relies on
            virtual methods to do much of the specialized work for any particular collection type.
            </summary>
        </member>
        <member name="P:Morpheus.Serialization.CGenericCollectionsBaseSurrogate.NumberOfExpectedTypes">
            <summary>
            Most collections have exactly 1 expected generic parameter Type, but not all (see Dictionary)
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CGenericCollectionsBaseSurrogate.AddElementToXml(System.String,System.Object,System.Xml.XmlElement,System.Type[],Morpheus.CSerializer)">
            <summary>
            Add, using either default logic (this method) or subclass logic (overridden in that subclass), add an element 
            to the parent Xml.
            </summary>
            <param name="_name"></param>
            <param name="_element"></param>
            <param name="_parentElement"></param>
            <param name="_expectedTypes"></param>
            <param name="_serializer"></param>
        </member>
        <member name="M:Morpheus.Serialization.CGenericCollectionsBaseSurrogate.GetCollectionElements(System.Object)">
            <summary>
            The standard enumeration over the collection using the default "IEnumerable" implementation.
            </summary>
            <param name="_collection">The collection to enumerate over</param>
            <returns>The enumeration for the collection</returns>
        </member>
        <member name="M:Morpheus.Serialization.CGenericCollectionsBaseSurrogate.GetXmlChildren(System.Xml.XmlElement)">
            <summary>
            The standard enumeration for xml children is a "forwards" enumeration over the ChildNodes
            </summary>
            <param name="_parent">The Xml node that contains all of the individual elements of the collection as ChildNodes</param>
            <returns>An iterator over those element-nodes</returns>
        </member>
        <member name="M:Morpheus.Serialization.CGenericCollectionsBaseSurrogate.AddElementFromXml(System.Object,System.Xml.XmlElement,System.Type[],Morpheus.CDeserializer)">
            <summary>
            Add a single XmlElement to a collection, where that XmlElement is a child of the parent Collection element.
            </summary>
            <param name="_collection"></param>
            <param name="_xmlData"></param>
            <param name="_expectedTypes"></param>
            <param name="_deserializer"></param>
        </member>
        <member name="M:Morpheus.Serialization.CGenericCollectionsBaseSurrogate.Serialize(System.Object,System.Type,System.Xml.XmlElement,Morpheus.CSerializer)">
            <summary>
            Serialize a generic collection to a parent Xml element
            </summary>
            <param name="_object">The object (collection) to serialize</param>
            <param name="_useType">Treat the "_object" parameter as if it were of this type</param>
            <param name="_parentElement">The XML element that is to receive the collection as Xml data</param>
            <param name="_serializer">The Serializer framework object in charge of serializing the collection</param>
            <returns>TRUE unless the collection is not supposed to be treated like an "interface"</returns>
        </member>
        <member name="M:Morpheus.Serialization.CGenericCollectionsBaseSurrogate.Deserialize(Morpheus.CWorkingObject,System.Xml.XmlElement,Morpheus.CDeserializer)">
            <summary>
            Deserialize a series of "ChildNode"s from an XmlElement as elements for a generic Dictionary.
            </summary>
            <param name="_workingObject">The "working" object to receive the dictionary elements</param>
            <param name="_parentElement">The "parent" of the XmlElements containing the individual Dictionary elements</param>
            <param name="_deserializer">The deserialization framework handing the deserialization</param>
            <returns>TRUE unless the collection is not supposed to be treated like an "interface"</returns>
        </member>
        <member name="T:Morpheus.Serialization.CGenQueueSurrogate">
            <summary>
            This surrogate will (de)serialize the <see cref="T:System.Collections.Generic.Queue`1"/> class.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CGenQueueSurrogate.AddElementFromXml(System.Object,System.Xml.XmlElement,System.Type[],Morpheus.CDeserializer)">
            <summary>
            Add a single XmlElement to a collection, where that XmlElement is a child of the parent Collection element.
            </summary>
            <param name="_collection"></param>
            <param name="_xmlData"></param>
            <param name="_expectedTypes"></param>
            <param name="_deserializer"></param>
        </member>
        <member name="T:Morpheus.Serialization.CGenStackSurrogate">
            <summary>
            This surrogate will (de)serialize the <see cref="T:System.Collections.Generic.List`1"/> class.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CGenStackSurrogate.AddElementFromXml(System.Object,System.Xml.XmlElement,System.Type[],Morpheus.CDeserializer)">
            <summary>
            Add a single XmlElement to a collection, where that XmlElement is a child of the parent Collection element.
            </summary>
            <param name="_collection"></param>
            <param name="_xmlData"></param>
            <param name="_expectedTypes"></param>
            <param name="_deserializer"></param>
        </member>
        <member name="T:Morpheus.Serialization.CHashSetSurrogate">
            <summary>
            This surrogate will (de)serialize the <see cref="T:System.Collections.Generic.HashSet`1"/> class.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CHashSetSurrogate.AddElementFromXml(System.Object,System.Xml.XmlElement,System.Type[],Morpheus.CDeserializer)">
            <summary>
            Add a single XmlElement to a collection, where that XmlElement is a child of the 
            parent Collection element.
            </summary>
            <param name="_collection"></param>
            <param name="_xmlData"></param>
            <param name="_expectedTypes"></param>
            <param name="_deserializer"></param>
        </member>
        <member name="T:Morpheus.Serialization.CLinkedListSurrogate">
            <summary>
            This surrogate will (de)serialize the <see cref="T:System.Collections.Generic.LinkedList`1"/> class.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CLinkedListSurrogate.AddElementFromXml(System.Object,System.Xml.XmlElement,System.Type[],Morpheus.CDeserializer)">
            <summary>
            Add a single XmlElement to a collection, where that XmlElement is a child of the parent Collection element.
            </summary>
            <param name="_collection"></param>
            <param name="_xmlData"></param>
            <param name="_expectedTypes"></param>
            <param name="_deserializer"></param>
        </member>
        <member name="T:Morpheus.Serialization.CListSurrogate">
            <summary>
            This surrogate will (de)serialize the <see cref="T:System.Collections.Generic.List`1"/> class.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CListSurrogate.AddElementFromXml(System.Object,System.Xml.XmlElement,System.Type[],Morpheus.CDeserializer)">
            <summary>
            Add a single XmlElement to a collection, where that XmlElement is a child of the parent Collection element.
            </summary>
            <param name="_collection"></param>
            <param name="_xmlData"></param>
            <param name="_expectedTypes"></param>
            <param name="_deserializer"></param>
        </member>
        <member name="T:Morpheus.Serialization.CArrayListSurrogate">
            <summary>
            Contains information on how to serialize and deserialize an ArrayList
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CArrayListSurrogate.Serialize(System.Object,System.Type,System.Xml.XmlElement,Morpheus.CSerializer)">
            <summary>
            Serialize an ArrayList using its enumerator
            </summary>
            <param name="_object">The ArrayList object</param>
            <param name="_useType">The Type that _object is to be treated as</param>
            <param name="_parentNode">The node which will receive the ArrayList data</param>
            <param name="_serializer">The Serializer controlling this serialization</param>
            <returns>TRUE always</returns>
        </member>
        <member name="M:Morpheus.Serialization.CArrayListSurrogate.Deserialize(Morpheus.CWorkingObject,System.Xml.XmlElement,Morpheus.CDeserializer)">
            <summary>
            Enumerate through the child nodes of an ArrayList and deserialize each one. Use the
            <see cref="M:System.Collections.ArrayList.Add(System.Object)"/> method to add each element to the ArrayList.
            </summary>
            <param name="_object">The working object to receive the data about the arraylist</param>
            <param name="_parentNode">The node containing the elements of the ArrayList</param>
            <param name="_deserializer">The Deserializer controlling this deserializtion</param>
            <returns>TRUE always</returns>
        </member>
        <member name="M:Morpheus.Serialization.CArrayListSurrogate.AddElement(System.Collections.ArrayList,System.Object)">
            <summary>
            Add an element to an ArrayList
            </summary>
            <param name="_collection">The ArrayList to add an element to</param>
            <param name="_element">The element to add to the collection</param>
        </member>
        <member name="T:Morpheus.Serialization.CHashtableSurrogate">
            <summary>
            A Hashtable can often be serialized using an enumerator and deserialized using an "Add" method.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CHashtableSurrogate.Serialize(System.Object,System.Type,System.Xml.XmlElement,Morpheus.CSerializer)">
            <summary>
            Serialize an Hashtable using its enumerator
            </summary>
            <param name="_object">The Hashtable object</param>
            <param name="_useType">Treat the "_object" parameter as if it were of this type</param>
            <param name="_parentNode">The node which will receive the Hashtable data</param>
            <param name="_serializer">The Serializer controlling this serialization</param>
            <returns>TRUE always</returns>
        </member>
        <member name="M:Morpheus.Serialization.CHashtableSurrogate.Deserialize(Morpheus.CWorkingObject,System.Xml.XmlElement,Morpheus.CDeserializer)">
            <summary>
            Enumerate through the child nodes of an Hashtable and deserialize each one. Use the
            <see cref="M:System.Collections.Hashtable.Add(System.Object,System.Object)"/> method to add each element to the Hashtable.
            </summary>
            <param name="_object">The working object to receive the data about the Hashtable</param>
            <param name="_parentNode">The node containing the elements of the Hashtable</param>
            <param name="_deserializer">The Deserializer controlling this deserializtion</param>
            <returns>TRUE always</returns>
        </member>
        <member name="M:Morpheus.Serialization.CHashtableSurrogate.AddElement(System.Collections.Hashtable,System.Collections.DictionaryEntry)">
            <summary>
            Add a new DictionaryEntry to a Hashtable
            </summary>
            <param name="_collection">The Hashtable to receive the new element</param>
            <param name="_element">The DictionaryEntry</param>
        </member>
        <member name="T:Morpheus.Serialization.CQueueSurrogate">
            <summary>
            Contains information on how to serialize and deserialize a Queue using <see cref="T:System.Collections.ICollection"/>
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CQueueSurrogate.Serialize(System.Object,System.Type,System.Xml.XmlElement,Morpheus.CSerializer)">
            <summary>
            Serialize a Queue using its enumerator
            </summary>
            <param name="_object">The Queue object</param>
            <param name="_useType">Treat the "_object" parameter as if it were of this type</param>
            <param name="_parentNode">The node which will receive the Queue data</param>
            <param name="_serializer">The Serializer controlling this serialization</param>
            <returns>TRUE always</returns>
        </member>
        <member name="M:Morpheus.Serialization.CQueueSurrogate.Deserialize(Morpheus.CWorkingObject,System.Xml.XmlElement,Morpheus.CDeserializer)">
            <summary>
            Enumerate through the child nodes of an Queue and deserialize each one. Use the
            <see cref="M:System.Collections.Queue.Enqueue(System.Object)"/> method to add each element to the Queue.
            </summary>
            <param name="_object">The working object to receive the data about the Queue</param>
            <param name="_parentNode">The node containing the elements of the Queue</param>
            <param name="_deserializer">The Deserializer controlling this deserializtion</param>
            <returns>TRUE always</returns>
        </member>
        <member name="M:Morpheus.Serialization.CQueueSurrogate.AddElement(System.Collections.Queue,System.Object)">
            <summary>
            Add an element to a Queue by calling <see cref="M:System.Collections.Queue.Enqueue(System.Object)"/>
            </summary>
            <param name="_collection">The Collection to add an element to</param>
            <param name="_element">The element to add to the collection</param>
        </member>
        <member name="T:Morpheus.Serialization.CReadOnlyArrayListSurrogate">
            <summary>
            The ReadOnlyArrayList class is a PRIVATE class in mscorlib that is created when the application wishes
            to have a "readonly" ArrayList. To get this "readonly" version, the application calls
            <see cref="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)"/> with the ArrayList that readonly operation is desired for as the
            paramter.
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CReadOnlyArrayListSurrogate.ReadOnlyArrayListType">
            <summary>
            The Type of a ReadOnlyArrayList- Since this is a private class, its Type has to be figured out using
            alternate means.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CReadOnlyArrayListSurrogate.#cctor">
            <summary>
            The static constructor's only job is to get the Type of a ReadOnlyArrayList.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CReadOnlyArrayListSurrogate.Serialize(System.Object,System.Type,System.Xml.XmlElement,Morpheus.CSerializer)">
            <summary>
            Serialize an SyncArrayList using its enumerator
            </summary>
            <param name="_object">The working object to receive the data about the arraylist</param>
            <param name="_useType">Treat the "_object" parameter as if it were of this type</param>
            <param name="_parentNode">The node containing the elements of the ArrayList</param>
            <param name="_serializer">The Deserializer controlling this deserializtion</param>
            <returns>TRUE always</returns>
        </member>
        <member name="M:Morpheus.Serialization.CReadOnlyArrayListSurrogate.Deserialize(Morpheus.CWorkingObject,System.Xml.XmlElement,Morpheus.CDeserializer)">
            <summary>
            Enumerate through the child nodes of an ArrayList and deserialize each one. Use the
            <see cref="M:System.Collections.ArrayList.Add(System.Object)"/> method to add each element to the ArrayList.
            </summary>
            <param name="_object">The working object to receive the data about the arraylist</param>
            <param name="_parentNode">The node containing the elements of the ArrayList</param>
            <param name="_deserializer">The Deserializer controlling this deserializtion</param>
            <returns>TRUE always</returns>
        </member>
        <member name="M:Morpheus.Serialization.CReadOnlyArrayListSurrogate.AddElement(System.Collections.ArrayList,System.Object)">
            <summary>
            Add an element to an ArrayList
            </summary>
            <param name="_collection">The ArrayList to add an element to</param>
            <param name="_element">The element to add to the collection</param>
        </member>
        <member name="M:Morpheus.Serialization.CReadOnlyArrayListSurrogate.MakeSpecialCollection(System.Collections.ArrayList)">
            <summary>
            Turn an ArrayList into a readonly ArrayList
            </summary>
            <param name="_collection">The standard ArrayList</param>
            <returns>A ReadOnly ArrayList</returns>
        </member>
        <member name="T:Morpheus.Serialization.CSortedListSurrogate">
            <summary>
            A SortedList can often be serialized using an enumerator and deserialized using an "Add" method.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CSortedListSurrogate.Serialize(System.Object,System.Type,System.Xml.XmlElement,Morpheus.CSerializer)">
            <summary>
            Serialize a SortedList using its enumerator
            </summary>
            <param name="_object">The SortedList object</param>
            <param name="_useType">Treat the "_object" parameter as if it were of this type</param>
            <param name="_parentNode">The node which will receive the SortedList data</param>
            <param name="_serializer">The Serializer controlling this serialization</param>
            <returns>TRUE always</returns>
        </member>
        <member name="M:Morpheus.Serialization.CSortedListSurrogate.Deserialize(Morpheus.CWorkingObject,System.Xml.XmlElement,Morpheus.CDeserializer)">
            <summary>
            Enumerate through the child nodes of an SortedList and deserialize each one. Use the
            <see cref="M:System.Collections.SortedList.Add(System.Object,System.Object)"/> method to add each element to the SortedList.
            </summary>
            <param name="_object">The working object to receive the data about the SortedList</param>
            <param name="_parentNode">The node containing the elements of the SortedList</param>
            <param name="_deserializer">The Deserializer controlling this deserializtion</param>
            <returns>TRUE always</returns>
        </member>
        <member name="M:Morpheus.Serialization.CSortedListSurrogate.AddElement(System.Collections.SortedList,System.Collections.DictionaryEntry)">
            <summary>
            Add a new entry to a SortedList.
            </summary>
            <param name="_collection">The SortedList to add the entry to</param>
            <param name="_element">The element to add to the collection</param>
        </member>
        <member name="T:Morpheus.Serialization.CStackSurrogate">
            <summary>
            An Stack can often be serialized using an enumerator and deserialized using the "Push" method.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CStackSurrogate.Serialize(System.Object,System.Type,System.Xml.XmlElement,Morpheus.CSerializer)">
            <summary>
            Serialize a Stack using its enumerator
            </summary>
            <param name="_object">The Stack object</param>
            <param name="_useType">Treat the "_object" parameter as if it were of this type</param>
            <param name="_parentNode">The node which will receive the Stack data</param>
            <param name="_serializer">The Serializer controlling this serialization</param>
            <returns>TRUE always</returns>
        </member>
        <member name="M:Morpheus.Serialization.CStackSurrogate.Deserialize(Morpheus.CWorkingObject,System.Xml.XmlElement,Morpheus.CDeserializer)">
            <summary>
            Enumerate through the child nodes of an Stack and deserialize each one. Use the
            <see cref="M:System.Collections.Stack.Push(System.Object)"/> method to add each element to the Stack.
            </summary>
            <param name="_object">The working object to receive the data about the Stack</param>
            <param name="_parentNode">The node containing the elements of the Stack</param>
            <param name="_deserializer">The Deserializer controlling this deserializtion</param>
            <returns>TRUE always</returns>
        </member>
        <member name="M:Morpheus.Serialization.CStackSurrogate.AddElement(System.Collections.Stack,System.Object)">
            <summary>
            Add an element to a Stack by calling <see cref="M:System.Collections.Stack.Push(System.Object)"/>
            </summary>
            <param name="_collection">The Collection to add an element to</param>
            <param name="_element">The element to add to the collection</param>
        </member>
        <member name="M:Morpheus.Serialization.CStackSurrogate.GetXmlChildren(System.Xml.XmlElement)">
            <summary>
            The Stack actually needs the elements in the reverse order because of the way its
            enumerator works when serializing.
            </summary>
            <param name="_parent"></param>
            <returns></returns>
        </member>
        <member name="T:Morpheus.Serialization.CSyncArrayListSurrogate">
            <summary>
            The SyncArrayList class is a PRIVATE class in mscorlib that is created when the application wishes to have a "syncronized" 
            ArrayList. To get this "sync'ed" version, the application calls <see cref="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)"/> with the 
            ArrayList that synchronization is desired for as the parameter.
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CSyncArrayListSurrogate.SyncArrayListType">
            <summary>
            The Type of a SyncArrayList- Since this is a private class, its Type has to be figured out using
            alternate means.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CSyncArrayListSurrogate.#cctor">
            <summary>
            The static constructor's only job is to get the Type of a SyncArrayList.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CSyncArrayListSurrogate.Serialize(System.Object,System.Type,System.Xml.XmlElement,Morpheus.CSerializer)">
            <summary>
            Serialize an SyncArrayList using its enumerator
            </summary>
            <param name="_object">The working object to receive the data about the arraylist</param>
            <param name="_useType">Treat the "_object" parameter as if it were of this type</param>
            <param name="_parentNode">The node containing the elements of the ArrayList</param>
            <param name="_serializer">The Deserializer controlling this deserializtion</param>
            <returns>TRUE always</returns>
        </member>
        <member name="M:Morpheus.Serialization.CSyncArrayListSurrogate.Deserialize(Morpheus.CWorkingObject,System.Xml.XmlElement,Morpheus.CDeserializer)">
            <summary>
            Enumerate through the child nodes of an ArrayList and deserialize each one. Use the
            <see cref="M:System.Collections.ArrayList.Add(System.Object)"/> method to add each element to the ArrayList.
            </summary>
            <param name="_object">The working object to receive the data about the arraylist</param>
            <param name="_parentNode">The node containing the elements of the ArrayList</param>
            <param name="_deserializer">The Deserializer controlling this deserializtion</param>
            <returns>TRUE always</returns>
        </member>
        <member name="M:Morpheus.Serialization.CSyncArrayListSurrogate.AddElement(System.Collections.ArrayList,System.Object)">
            <summary>
            Add an element to an ArrayList
            </summary>
            <param name="_collection">The ArrayList to add an element to</param>
            <param name="_element">The element to add to the collection</param>
        </member>
        <member name="M:Morpheus.Serialization.CSyncArrayListSurrogate.MakeSpecialCollection(System.Collections.ArrayList)">
            <summary>
            Turn an ArrayList into a synchronized ArrayList
            </summary>
            <param name="_collection">The standard ArrayList</param>
            <returns>A Synchronized ArrayList</returns>
        </member>
        <member name="T:Morpheus.Serialization.CSyncHashtableSurrogate">
            <summary>
            The SyncHashtable class is a PRIVATE class in mscorlib that is created when the application wishes to have a 
            "syncronized" Hashtable. To get this "sync'ed" version, the application calls
            <see cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)"/> with the Hashtable that synchronization is desired for as the
            parameter.
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CSyncHashtableSurrogate.SyncHashtableType">
            <summary>
            The Type of a SyncHashtable- Since this is a private class, its Type has to be figured out using
            alternate means.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CSyncHashtableSurrogate.#cctor">
            <summary>
            The static constructor's only job is to get the Type of a SyncHashtable.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CSyncHashtableSurrogate.Serialize(System.Object,System.Type,System.Xml.XmlElement,Morpheus.CSerializer)">
            <summary>
            Serialize an SyncHashtable using its enumerator
            </summary>
            <param name="_object">The working object to receive the data about the Hashtable</param>
            <param name="_useType">Treat the "_object" parameter as if it were of this type</param>
            <param name="_parentNode">The node containing the elements of the Hashtable</param>
            <param name="_serializer">The Deserializer controlling this deserializtion</param>
            <returns>TRUE always</returns>
        </member>
        <member name="M:Morpheus.Serialization.CSyncHashtableSurrogate.Deserialize(Morpheus.CWorkingObject,System.Xml.XmlElement,Morpheus.CDeserializer)">
            <summary>
            Enumerate through the child nodes of an Hashtable and deserialize each one. Use the
            <see cref="M:System.Collections.Hashtable.Add(System.Object,System.Object)"/> method to add each element to the Hashtable.
            </summary>
            <param name="_object">The working object to receive the data about the Hashtable</param>
            <param name="_parentNode">The node containing the elements of the Hashtable</param>
            <param name="_deserializer">The Deserializer controlling this deserializtion</param>
            <returns>TRUE always</returns>
        </member>
        <member name="M:Morpheus.Serialization.CSyncHashtableSurrogate.AddElement(System.Collections.Hashtable,System.Collections.DictionaryEntry)">
            <summary>
            Add a new DictionaryEntry to a Hashtable
            </summary>
            <param name="_collection">The Hashtable to receive the new element</param>
            <param name="_element">The DictionaryEntry</param>
        </member>
        <member name="M:Morpheus.Serialization.CSyncHashtableSurrogate.MakeSpecialCollection(System.Collections.Hashtable)">
            <summary>
            Turn an ordinary Hashtable into a Synchronized hashtable
            </summary>
            <param name="_collection">The ordinary HashTable</param>
            <returns>The Synchronized hashtable</returns>
        </member>
        <member name="T:Morpheus.Serialization.CSyncQueueSurrogate">
            <summary>
            The SyncQueue class is a PRIVATE class in mscorlib that is created when the application wishes
            to have a "syncronized" Queue. To get this "sync'ed" version, the application calls
            <see cref="M:System.Collections.Queue.Synchronized(System.Collections.Queue)"/> with the Queue that synchronization is desired for as the
            parameter.
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CSyncQueueSurrogate.SyncQueueType">
            <summary>
            The Type of a SyncQueue- Since this is a private class, its Type has to be figured out using
            alternate means.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CSyncQueueSurrogate.#cctor">
            <summary>
            The static constructor's only job is to get the Type of a SyncQueue.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CSyncQueueSurrogate.Serialize(System.Object,System.Type,System.Xml.XmlElement,Morpheus.CSerializer)">
            <summary>
            Serialize an SyncQueue using its enumerator
            </summary>
            <param name="_object">The SyncQueue object</param>
            <param name="_useType">Treat the "_object" parameter as if it were of this type</param>
            <param name="_parentNode">The node which will receive the SyncQueue data</param>
            <param name="_serializer">The serializer context</param>
        </member>
        <member name="M:Morpheus.Serialization.CSyncQueueSurrogate.Deserialize(Morpheus.CWorkingObject,System.Xml.XmlElement,Morpheus.CDeserializer)">
            <summary>
            Enumerate through the child nodes of a Queue and deserialize each one. Use the
            <see cref="M:System.Collections.Queue.Enqueue(System.Object)"/> method to add each element to the Queue.
            </summary>
            <param name="_object">The working object to receive the data about the Queue</param>
            <param name="_parentNode">The node containing the elements of the Queue</param>
            <param name="_deserializer">The Deserializer controlling this deserializtion</param>
            <returns>TRUE always</returns>
        </member>
        <member name="M:Morpheus.Serialization.CSyncQueueSurrogate.AddElement(System.Collections.Queue,System.Object)">
            <summary>
            Add an element to a Queue by calling <see cref="M:System.Collections.Queue.Enqueue(System.Object)"/>
            </summary>
            <param name="_collection">The Collection to add an element to</param>
            <param name="_element">The element to add to the collection</param>
        </member>
        <member name="M:Morpheus.Serialization.CSyncQueueSurrogate.MakeSpecialCollection(System.Collections.Queue)">
            <summary>
            Turn a Queue into a Synchronized Queue
            </summary>
            <param name="_collection">The collection to turn into something special</param>
            <returns>The "Special" collection</returns>
        </member>
        <member name="T:Morpheus.Serialization.CSyncSortedListSurrogate">
            <summary>
            The SyncSortedList class is a PRIVATE class in mscorlib that is created when the application wishes
            to have a "syncronized" SortedList. To get this "sync'ed" version, the application calls
            <see cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)"/> with the SortedList that synchronization is desired for as the
            parameter.
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CSyncSortedListSurrogate.SyncSortedListType">
            <summary>
            The Type of a SyncSortedList- Since this is a private class, its Type has to be figured out using
            alternate means.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CSyncSortedListSurrogate.#cctor">
            <summary>
            The static constructor's only job is to get the Type of a SyncSortedList.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CSyncSortedListSurrogate.Serialize(System.Object,System.Type,System.Xml.XmlElement,Morpheus.CSerializer)">
            <summary>
            Serialize an SyncSortedList using its enumerator
            </summary>
            <param name="_object">The SyncSortedList object</param>
            <param name="_useType">Treat the "_object" parameter as if it were of this type</param>
            <param name="_parentNode">The node which will receive the SyncSortedList data</param>
            <param name="_serializer">The serializer context</param>
        </member>
        <member name="M:Morpheus.Serialization.CSyncSortedListSurrogate.Deserialize(Morpheus.CWorkingObject,System.Xml.XmlElement,Morpheus.CDeserializer)">
            <summary>
            Enumerate through the child nodes of a SortedList and deserialize each one. Use the
            <see cref="M:System.Collections.SortedList.Add(System.Object,System.Object)"/> method to add each element to the SortedList.
            </summary>
            <param name="_object">The working object to receive the data about the SortedList</param>
            <param name="_parentNode">The node containing the elements of the SortedList</param>
            <param name="_deserializer">The Deserializer controlling this deserializtion</param>
            <returns>TRUE always</returns>
        </member>
        <member name="M:Morpheus.Serialization.CSyncSortedListSurrogate.AddElement(System.Collections.SortedList,System.Collections.DictionaryEntry)">
            <summary>
            Add a new entry to a SortedList.
            </summary>
            <param name="_collection">The SortedList to add the entry to</param>
            <param name="_element">The element to add to the collection</param>
        </member>
        <member name="M:Morpheus.Serialization.CSyncSortedListSurrogate.MakeSpecialCollection(System.Collections.SortedList)">
            <summary>
            Return a Sync'ed SortedList from an ordinary one
            </summary>
            <param name="_collection">The SortedList that needs to be synchronized</param>
            <returns>A Sync'ed version of the collection</returns>
        </member>
        <member name="T:Morpheus.Serialization.CSyncStackSurrogate">
            <summary>
            The SyncStack class is a PRIVATE class in mscorlib that is created when the application wishes
            to have a "syncronized" Stack. To get this "sync'ed" version, the application calls
            <see cref="M:System.Collections.Stack.Synchronized(System.Collections.Stack)"/> with the Stack that synchronization is desired for as the
            parameter.
            </summary>
        </member>
        <member name="F:Morpheus.Serialization.CSyncStackSurrogate.SyncStackType">
            <summary>
            The Type of a SyncStack- Since this is a private class, its Type has to be figured out using
            alternate means.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CSyncStackSurrogate.#cctor">
            <summary>
            The static constructor's only job is to get the Type of a SyncStack.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CSyncStackSurrogate.Serialize(System.Object,System.Type,System.Xml.XmlElement,Morpheus.CSerializer)">
            <summary>
            Serialize an SyncStack using its enumerator
            </summary>
            <param name="_object">The SyncStack object</param>
            <param name="_useType">Treat the "_object" parameter as if it were of this type</param>
            <param name="_parentNode">The node which will receive the SyncStack data</param>
            <param name="_serializer">The serializer context</param>
        </member>
        <member name="M:Morpheus.Serialization.CSyncStackSurrogate.Deserialize(Morpheus.CWorkingObject,System.Xml.XmlElement,Morpheus.CDeserializer)">
            <summary>
            Enumerate through the child nodes of a Stack and deserialize each one. Use the
            <see cref="M:System.Collections.Stack.Push(System.Object)"/> method to add each element to the Stack.
            </summary>
            <param name="_object">The working object to receive the data about the Stack</param>
            <param name="_parentNode">The node containing the elements of the Stack</param>
            <param name="_deserializer">The Deserializer controlling this deserializtion</param>
            <returns>TRUE always</returns>
        </member>
        <member name="M:Morpheus.Serialization.CSyncStackSurrogate.AddElement(System.Collections.Stack,System.Object)">
            <summary>
            Add an element to a Stack by calling <see cref="M:System.Collections.Stack.Push(System.Object)"/>
            </summary>
            <param name="_collection">The Collection to add an element to</param>
            <param name="_element">The element to add to the collection</param>
        </member>
        <member name="M:Morpheus.Serialization.CSyncStackSurrogate.MakeSpecialCollection(System.Collections.Stack)">
            <summary>
            Turn a Stack into a Synchronized Stack
            </summary>
            <param name="_collection">The collection to turn into something special</param>
            <returns>The "Special" collection</returns>
        </member>
        <member name="M:Morpheus.Serialization.CSyncStackSurrogate.GetXmlChildren(System.Xml.XmlElement)">
            <summary>
            Just like the "Stack", the SyncStack needs the ChildNodes in reverse order
            </summary>
            <param name="_parent"></param>
            <returns></returns>
        </member>
        <member name="T:Morpheus.Serialization.CSystemCollectionsBaseSurrogate`2">
            <summary>
            This is the base class for the <see cref="N:System.Collections"/> collections supported by the framework.
            </summary>
        </member>
        <member name="M:Morpheus.Serialization.CSystemCollectionsBaseSurrogate`2.GetEnumerator(System.Object)">
            <summary>
            This janky P.O.S. code is to fix the bug in SyncHashtable and SyncSortedList that prevents the proper
            enumeration using IEnumerable and ICollection- By casting to IDictionary, we can get the "Real" enumerator
            </summary>
            <param name="_collection">The collection that needs to be enumerated</param>
            <returns>A "proper" enumerator for the collection, based on the BUG in the MSCORLIB code</returns>
        </member>
        <member name="M:Morpheus.Serialization.CSystemCollectionsBaseSurrogate`2.SerializeEnumeration(System.Object,System.Xml.XmlElement,Morpheus.CSerializer)">
            <summary>
            Serialize the enumeration, serializing each element 
            </summary>
            <param name="_collection">The collection that is to be enumerated</param>
            <param name="_parentNode">The XmlNode to receive the elements</param>
            <param name="_serializer">The framework controlling the serialization</param>
        </member>
        <member name="M:Morpheus.Serialization.CSystemCollectionsBaseSurrogate`2.BaseSerialize(System.Object,System.Type,System.Xml.XmlElement,Morpheus.CSerializer)">
            <summary>
            Serialize an ICollection using the enumerator and the Synchronization hints
            </summary>
            <param name="_collection">The collection to serialize</param>
            <param name="_useType">Treat the "_object" parameter as if it were of this type</param>
            <param name="_parentNode">The Xml node to receive the elements of the collection</param>
            <param name="_serializer">The serializer used to serialize the collection</param>
            <returns>TRUE always</returns>
        </member>
        <member name="M:Morpheus.Serialization.CSystemCollectionsBaseSurrogate`2.SpecialDeserialize(Morpheus.CWorkingObject,System.Xml.XmlElement,Morpheus.CDeserializer)">
            <summary>
            Deserialization helper to deserialize XML nodes into a "special" collection.
            </summary>
            <remarks>
            A "special" collection is one of the "hidden" collections that implement Synchronized or ReadOnly
            behavior for the System.Collections collections.
            </remarks>
            <param name="_object">The working object to receive the deserialized values</param>
            <param name="_node">The XmlNode containing the data for the collection</param>
            <param name="_deserializer">The deserialization framework performing the overall deserialization</param>
            <returns>TRUE always</returns>
        </member>
        <member name="M:Morpheus.Serialization.CSystemCollectionsBaseSurrogate`2.BasicDeserialize(Morpheus.CWorkingObject,System.Xml.XmlElement,Morpheus.CDeserializer)">
            <summary>
            Enumerate through the child nodes of the collection and deserialize each one. Use the
            method provided to add each element to the collection.
            </summary>
            <param name="_object">The working object to receive the data about the Stack</param>
            <param name="_parentNode">The node containing the elements of the Stack</param>
            <param name="_deserializer">The Deserializer controlling this deserializtion</param>
            <returns>TRUE always</returns>
        </member>
        <member name="M:Morpheus.Serialization.CSystemCollectionsBaseSurrogate`2.GetXmlChildren(System.Xml.XmlElement)">
            <summary>
            The standard enumeration for xml children is a "forwards" enumeration over the ChildNodes
            </summary>
            <param name="_parent">The Xml node that contains all of the individual elements of the collection as ChildNodes</param>
            <returns>An iterator over those element-nodes</returns>
        </member>
        <member name="M:Morpheus.Serialization.CSystemCollectionsBaseSurrogate`2.AddElement(`0,`1)">
            <summary>
            Overridden by the subtype to add an element to the collection once that element has been deserialized
            </summary>
            <param name="_collection">The collection to add the item to</param>
            <param name="_element">The element to add to the collection</param>
        </member>
        <member name="M:Morpheus.Serialization.CSystemCollectionsBaseSurrogate`2.MakeSpecialCollection(`0)">
            <summary>
            Turn a collection into a "Special" collection- Synchronized or ReadOnly, etc.
            </summary>
            <param name="_collection">The collection to turn into something special</param>
            <returns>The "Special" collection</returns>
        </member>
        <member name="T:Morpheus.CDeserializer">
            <summary>
            This class provides methods that allow data to be transmuted between a .NET object and
            Xml.
            </summary>
            <remarks>
            This class will operate on ALL fields, including protected and private ones. If you
            don't like this idea, then don't use this class. Use the .NET Xml serializer instead.
            
            EXAMPLES AND FORMATS -------------------- class CPerson { string m_name; int m_age;
            CAddress m_address; string[] m_kidsNames; string m_aNullValue = null; CAddress
            m_otherAddress; }
            
            class CAddress { string Street; string City; int Zip; }
            
            class CSuperAddress : CAddress { string Country; }
            
            --- yields ---
            
            <CPerson> <Name> Homer Simpson </Name> <Age> 35 </Age> <Address> <Street> 45 Mount
            Horrible </Street> <City> Springfield </City> <Zip> 84372 </Zip> </Address>
            <KidsNames _Array="3"> Bart,Lisa,Maggie </KidsNames> <ANullValue Null="true"/>
            <OtherAddress Type="CSuperAddress"> <Street> 88 Schroeder Way </Street> <City> Boston
            </City> <Zip> 12837 </Zip> <Country> USA </Country> </OtherAddress> </CPerson>
            
            
            </remarks>
            <remarks>Use the "Helper" class for static methods.</remarks>
        </member>
        <member name="F:Morpheus.CDeserializer.m_references">
            <summary>
            The table used to remember objects that have been deserialized with a "refID" tag.
            </summary>
        </member>
        <member name="M:Morpheus.CDeserializer.#ctor">
            <summary>
            Default constructor uses the "Global" serialization context
            </summary>
        </member>
        <member name="M:Morpheus.CDeserializer.#ctor(Morpheus.CSerializationContext)">
            <summary>
            Construct with a default context object
            </summary>
            <param name="_context">The context object to use for the serialization</param>
        </member>
        <member name="M:Morpheus.CDeserializer.Deserialize(System.Xml.XmlNode)">
            <summary>
            Given an XmlNode, turn the data into that node into an object, if possible
            </summary>
            <param name="_xml">
            The Xml that contains data useful in filling out the fields of an object
            </param>
            <returns>The object created from the XML</returns>
        </member>
        <member name="M:Morpheus.CDeserializer.Deserialize``1(System.Xml.XmlNode)">
            <summary>
            Given an XmlNode, turn the data into that node into an object, if possible. Assume
            that the object needs to be of generic-parameter Type T
            </summary>
            <typeparam name="T">
            The Type that the Xml is supposed to deserialize into
            </typeparam>
            <param name="_xml">
            The Xml that contains data useful in filling out the fields of an object
            </param>
            <returns>The object of type T created from the XML</returns>
        </member>
        <member name="M:Morpheus.CDeserializer.MakeElement(System.Xml.XmlNode)">
            <summary>
            Helper to make sure that what's sent in to the Deserializer is handled properly.
            Turns an XmlDocument into an XmlElement if the parameter is a document.
            </summary>
            <param name="_xml">The XML containing the data for the object</param>
            <returns>An XmlElement appropriate for deserialization</returns>
        </member>
        <member name="M:Morpheus.CDeserializer.FrameworkDeserialize(System.Xml.XmlElement,System.Type)">
            <summary>
            This is the recursively-called routine that will actually direct the deserialization
            using the analysis of the xml node being deserialized.
            </summary>
            <param name="_xml">The XML containing the data for the object</param>
            <param name="_defaultType">
            The Type that is expected for this object- this may be overridden by the XML
            </param>
            <returns>The object that was created from the XML</returns>
        </member>
        <member name="M:Morpheus.CDeserializer.CheckNullAndReference(System.Xml.XmlElement,Morpheus.CWorkingObject)">
            <summary>
            Check the easiest forms of deserialization- Null and RefTo an object already
            deserialized.
            </summary>
            <param name="_xml">The XML that's being deserialized</param>
            <param name="_workObj">
            The Object that was deserialized (when the return value is TRUE)
            </param>
            <returns>
            TRUE means that the _workObj parameter contains valid data and nothing further
            should be done, FALSE means that no deserialization was performed.
            </returns>
        </member>
        <member name="M:Morpheus.CDeserializer.HandleDeserialization(System.Xml.XmlElement,System.Type,Morpheus.CWorkingObject)">
            <summary>
            The framework will deserialize the object. No more surrogates or other "exceptional"
            behaviour.
            </summary>
            <param name="_xml"></param>
            <param name="_type"></param>
            <param name="_workingObject"></param>
        </member>
        <member name="M:Morpheus.CDeserializer.DeserializeReferenceType(System.Xml.XmlElement,System.Type,Morpheus.CWorkingObject)">
            <summary>
            The Type is a reference type with zero or more fields, and it is to be deserialized
            using the Framework's algorithm
            </summary>
            <param name="_xml">The XML containing the field data</param>
            <param name="_type">The Type that is to be deserialized</param>
            <param name="_workingObject">
            The working object to be used if it is set (create new object instance if not)
            </param>
            <returns>The newly deserialized object</returns>
        </member>
        <member name="M:Morpheus.CDeserializer.DeserializeObjectFields(System.Xml.XmlElement,System.Object,Morpheus.Serialization.CTypeData)">
            <summary>
            This routine will enumerate all fields associated with an object and deserialize
            each field. This routine's scope is simply the declared fields for the "top" level
            of the class's inheritance chain- in other words, this will NOT deserialize a base
            class's fields.
            </summary>
            <param name="_xml">The XML containing the field data</param>
            <param name="_objectToPopulate">The object whose fields are being populated</param>
            <param name="_typeData">
            Serialization Type Data describing this Type (not to include base-class)
            </param>
        </member>
        <member name="M:Morpheus.CDeserializer.DeserializeArray(System.Xml.XmlElement,System.Type,Morpheus.CWorkingObject)">
            <summary>
            Create an Array from the data in the Xml and return that array.
            </summary>
            <param name="_xml">The XML containing the data for the array</param>
            <param name="_type">The Type of the array, as inferred from the framework</param>
            <param name="_workingObject">
            A working object (optional) that must be an Array (if its not null)
            </param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CDeserializer.DeserializeArrayFromElements(System.Xml.XmlElement,Morpheus.CArrayDeserializationHelper)">
            <summary>
            Using childNodes from an element, deserialize an array by deserializing the
            individual elements into the array elements.
            </summary>
            <param name="_xml">
            The XML parent node containing the array elements as childNodes
            </param>
            <param name="_arrayHelper">The ArrayDeserializationHelper</param>
        </member>
        <member name="M:Morpheus.CDeserializer.DeserializeArrayFromCondensedArray(System.String[],Morpheus.CArrayDeserializationHelper)">
            <summary>
            Using the info in a "condensed array", deserialize an Array into an object.
            </summary>
            <param name="_condensedArray">
            The "Condensed Array"- a string[] containing data from a CSV list
            </param>
            <param name="_arrayHelper">The ArrayDeserializationHelper</param>
        </member>
        <member name="M:Morpheus.CDeserializer.CreateArrayDeserializationHelper(System.Xml.XmlElement,System.Type,Morpheus.CWorkingObject,System.Int32)">
            <summary>
            Given information about the current state, create an ArrayDeserializationHelper to
            help with the deserialization process
            </summary>
            <param name="_xml">The XML containing the Array information</param>
            <param name="_type">The Type of the array expected</param>
            <param name="_workingObject">
            A "Working Object", likely from a surrogate that didn't complete the deserialization
            </param>
            <param name="_inferredLength">
            The Inferred Length of the array, from a "Condensed Array" already found in the XML
            </param>
            <returns>
            A properly formed <see cref="T:Morpheus.CArrayDeserializationHelper"/> object.
            </returns>
        </member>
        <member name="M:Morpheus.CDeserializer.FindCondensedArray(System.Xml.XmlElement)">
            <summary>
            Check the XML to see if it contains a CSV list of stuff. IF it does, then split it
            up and return the resulting string[]
            </summary>
            <param name="_xml">The XML node to check</param>
            <returns>
            Null if nothing was found, or a string[] containing the values from the CSV list if
            it is found
            </returns>
        </member>
        <member name="M:Morpheus.CDeserializer.InferArrayLength(System.Xml.XmlElement)">
            <summary>
            This routine will try to figure out how large an array is based on the nodes in the
            XML
            </summary>
            <param name="_xml"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CDeserializer.ApplySurrogates(System.Xml.XmlElement,System.Type,Morpheus.CWorkingObject)">
            <summary>
            Check to see if there are surrogates that handle the deserialization.
            </summary>
            <param name="_xml">The XML containing the object data</param>
            <param name="_type">The TYPE that we're trying to deserialize</param>
            <param name="_workingObject">
            A "Working Object" that deserializers use to determine if they need to create a new
            object or if they have an object that they can deserialize into.
            </param>
            <returns>
            TRUE if a surrogate was successful in completing the deserialization of the object,
            or FALSE if the surrogates were not able to complete all deserialization
            </returns>
        </member>
        <member name="M:Morpheus.CDeserializer.DeserializeUsingEntitySemantics(System.Xml.XmlElement,System.Type,Morpheus.CWorkingObject)">
            <summary>
            The Type uses EntitySemantics. See <see cref="T:Morpheus.Serialization.CEntityTypeData"/> for more info on
            EntitySemantics
            </summary>
            <param name="_xml">The XML containing the data</param>
            <param name="_type">
            The Type that has already been determined to use Entity Semantics
            </param>
            <param name="_workingObject">Where to put the resulting object</param>
        </member>
        <member name="M:Morpheus.CDeserializer.GetTypeFromXmlOrDefault(System.Xml.XmlElement,System.Type)">
            <summary>
            Check an XmlElement to see if it includes a specific "Type" attribute. If so, return
            the actual Type associated with that attribute's value.
            </summary>
            <param name="_xml">The XmlElement containing the field's information</param>
            <param name="_defaultType">
            If there is no Type attribute, then return this value as the "default"
            </param>
            <returns>
            NULL if no Type attribute was found, or the Type object corresponding the value of
            the Type attribute
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown if there is a Type attribute, but that attribute's value cannot be turned
            into a Type object.
            </exception>
        </member>
        <member name="M:Morpheus.CDeserializer.GetExpectedType(System.Xml.XmlElement)">
            <summary>
            Return the "Expected Type" of the field that the framework is currently working on.
            This value may be NULL if this value is at the "Top" of the (de)serialization,
            before any "field" has been detected.
            </summary>
            <returns>
            The <see cref="T:System.Type"/> of the field the framework is working on, or NULL if at the
            Top of the operation.
            </returns>
        </member>
        <member name="M:Morpheus.CDeserializer.SetObjectRefId(System.Object,System.String)">
            <summary>
            Associate the object with the given reference ID.
            </summary>
            <remarks>
            This is called from within the <see cref="T:Morpheus.CWorkingObject"/> class when the working
            object is set.
            </remarks>
            <param name="_object">The object to be associated with the reference id</param>
            <param name="_refId">The refId that the object belongs to</param>
        </member>
        <member name="T:Morpheus.CExternalSurrogatePair">
            <summary>
            This helper class encapsulates a pair of IExternalSurrogates. When the "Serialize" or
            "Deserialize" methods are called, this class will call the first surrogate's Serialize
            method and, if it didn't return TRUE, then return the value of the second surrogate's
            return value. The same thing happens for the Deserialize operation.
            </summary>
            <remarks>
            While there's no reason not to let any application use this class, the usage model is
            tailor-fit to help <see cref="T:Morpheus.Serialization.CFramework"/> in an optimal fashion. Thus,
            if some of the API looks a little weird, that's why.
            </remarks>
        </member>
        <member name="P:Morpheus.CExternalSurrogatePair.Surrogate1">
            <summary>
            The first surrogate to be called
            </summary>
        </member>
        <member name="P:Morpheus.CExternalSurrogatePair.Surrogate2">
            <summary>
            The second surrogate to be called
            </summary>
        </member>
        <member name="M:Morpheus.CExternalSurrogatePair.Update(Morpheus.IExternalSurrogate,Morpheus.IExternalSurrogate)">
            <summary>
            This static method acts as an "accumulator" where, as new surrogates are "found"
            that should be called in turn for a given Type, new Pairs are called and connected
            to each other.
            </summary>
            <param name="_working">
            The "Working" variable that is being "accumulated into"
            </param>
            <param name="_next">
            The "next" IExternalSurrogate that should be "accumulated into" the working
            surrogate
            </param>
            <returns>
            An IExternalSurrogate representing the "current" state of the "accumulator"
            </returns>
        </member>
        <member name="M:Morpheus.CExternalSurrogatePair.#ctor(Morpheus.IExternalSurrogate,Morpheus.IExternalSurrogate)">
            <summary>
            Construct the Pair using Two separate surrogates.
            </summary>
            <param name="_surrogate1">The 1st surrogate</param>
            <param name="_surrogate2">The 2nd surrogate</param>
        </member>
        <member name="M:Morpheus.CExternalSurrogatePair.Serialize(System.Object,System.Type,System.Xml.XmlElement,Morpheus.CSerializer)">
            <summary>
            Given an object and a "parent" xml element, add all of the information describing
            the object (its fields, for instance) to the parent element. The implementation of
            this method should be very cautious about modifying the parent element itself-
            generally the only acceptable thing to do with the parent is to -add- new attributes
            and elements. It is VERY DANGEROUS to look past the element itself- The
            implementation should not need to deal with ancestors and/or siblings of the
            passed-in element.
            </summary>
            <param name="_object">The object whose data needs to be added to _parentNode</param>
            <param name="_useType">
            Treat the "_object" parameter as if it were of this type
            </param>
            <param name="_parentElement">
            The "Parent" XmlElement that should recieve _object's data
            </param>
            <param name="_serializer">
            The serializer instance making this call- used to get current context.
            </param>
            <returns>
            TRUE if the surrogate was able to completely serialize the object, FALSE if the
            framework should perform its "default" function.
            </returns>
        </member>
        <member name="M:Morpheus.CExternalSurrogatePair.Deserialize(Morpheus.CWorkingObject,System.Xml.XmlElement,Morpheus.CDeserializer)">
            <summary>
            Given an XmlElement and a "CWorkingObject" instance, try to deserialize the Xml into
            the working object. The surrogate may be responsible for object creation- the
            _workingObject should be checked to see if an object has already been created (by,
            for instance, a super-class). All of the information for the object should be
            wholely contained within the XmlElement supplied. The implementation should never
            need to "hunt around" the XML DOM for information about the object.
            </summary>
            <param name="_workingObject">
            The container for object that is being deserialized. If the "WorkingObject" property
            is a NULL value, then the deserializer is expected to create the object and use the
            <see cref="M:Morpheus.CWorkingObject.Set(System.Object)"/> method to assign the newly created object to the
            working object. If it is NOT a null value, then the deserializer is not allowed to
            modify this "Working Object" value.
            </param>
            <param name="_parentElement">
            The XmlElement containing the data to populate the object with
            </param>
            <param name="_deserializer">
            The CDeserializer instance making this call- This can be used to get the context
            information or any other relevent information.
            </param>
            <returns>
            TRUE if the surrogate was able to completely deserialize the object, FALSE if the
            framework should perform its "default" function.
            </returns>
        </member>
        <member name="T:Morpheus.CFixM_">
            <summary>
            This class is used to globally check a field name to see if it starts with "m_" followed
            by a lower-case character. If it does, then that name is changed to remove the m_ and switch
            the lower-case char to an upper-case char.
            </summary>
            <example>
            Field Name      Changed To      Reason
            ----------------------------------------------------------------------------------------------
            Name            Name            No change- there's no "m_"
            address         address         No change- there's no "m_"
            m_age           Age             Changed because the field follows the Morpheus coding standard
            m_x             X               Changed because even single-char fields are OK
            m_              m_              There is no third char, so nothing is changed
            m_Name          m_Name          No change because the third char is not lowercase
            </example>
            <remarks>
            The Morpheus coding standard demands that private fields begin with "m_" and use a camel-case 
            descriptor thereafter.
            </remarks>
        </member>
        <member name="M:Morpheus.CFixM_.ConvertFieldName(System.String,System.Reflection.FieldInfo)">
            <summary>
            This method will check the name of a field for the "m_" prefix and change it to something 
            "more readable" if reasonable.
            </summary>
            <param name="_fieldName">The name of the field to convert</param>
            <param name="_fieldInfo">The <see cref="T:System.Reflection.FieldInfo"/> for the field</param>
            <returns>The new name of the field (may be the same as the original!)</returns>
        </member>
        <member name="M:Morpheus.CFixM_.ConvertName(System.String)">
            <summary>
            This method will check the name of a field for the "m_" prefix and change it to something 
            "more readable" if reasonable.
            </summary>
            <param name="_name">The name of the field to try to change</param>
            <returns>The new name of the field (may be the same as the original!)</returns>
        </member>
        <member name="T:Morpheus.CSerializationContext">
            <summary>
            This class contains all of the information needed to customize the serialization process
            </summary>
            <remarks>
            THREAD SAFETY NOTICE- The Framework's Serializer and Deserializer will treat Context as if it
            were a CONSTANT OBJECT- The Framework will never modify any part of the Context object. It is
            the application's responsibility to not modify the context while the framework is using it.
            
            
            The role of the "Global" context is paramount to understanding how this class is designed.
            The goal is to allow an application to EASILY change the way the serialization process handles
            any single part of the process without having to create a lot of supporting code.
            
            This is a recursive class, in that the application can have contexts that are derived from 
            any number of "child contexts", each of which deferring to the level below it until one of
            the contexts actually has an application value set.
            </remarks>
        </member>
        <member name="F:Morpheus.CSerializationContext.Global">
            <summary>
            The Global context is what's used to fall back on for every parameter in the context.
            </summary>
        </member>
        <member name="F:Morpheus.CSerializationContext.m_parent">
            <summary>
            The internal inherited context is used to return a value when there is none specifically 
            set for the item at this level.
            </summary>
        </member>
        <member name="M:Morpheus.CSerializationContext.#ctor(System.Boolean)">
            <summary>
            This private constructor is used by the static "Global" field to make sure nothing looks at 
            the "parent" member.
            </summary>
            <param name="_isGlobal">Any value that triggers this constructor override to be used by the
            Global field.</param>
        </member>
        <member name="M:Morpheus.CSerializationContext.#ctor">
            <summary>
            Default constructor for a serialization context
            </summary>
        </member>
        <member name="M:Morpheus.CSerializationContext.#ctor(Morpheus.CSerializationContext)">
            <summary>
            Construct a CSerialization context that inherits values from some other context.
            </summary>
            <remarks>
            This is generally used by the framework, but since an application could use this as well, it is 
            marked public rather than internal.
            </remarks>
            <param name="_parent">The context to inherit</param>
        </member>
        <member name="M:Morpheus.CSerializationContext.ResetToGlobalDefault">
            <summary>
            Make this object suitable to be the Global context
            </summary>
        </member>
        <member name="M:Morpheus.CSerializationContext.ResetToDefaults">
            <summary>
            This method sets all of the compile-time defaults for a context object.
            </summary>
        </member>
        <member name="M:Morpheus.CSerializationContext.SetFullNames">
            <summary>
            Set the predefined names to their full values ("_Root" instead of "_R")
            </summary>
        </member>
        <member name="M:Morpheus.CSerializationContext.SetShortNames">
            <summary>
            Set the predefined names to their short values ("_R" instead of "_Root")
            </summary>
        </member>
        <member name="M:Morpheus.CSerializationContext.SetConcise">
            <summary>
            Set values so that the short, concise output is generated
            </summary>
        </member>
        <member name="M:Morpheus.CSerializationContext.SetVerbose">
            <summary>
            Set values so that the long, verbose output is generated
            </summary>
        </member>
        <member name="T:Morpheus.CSerializationContext.EContextFields">
            <summary>
            Context Fields Flags direct the default serializers how to handle certain features
            </summary>
        </member>
        <member name="F:Morpheus.CSerializationContext.EContextFields.NONE">
            <summary>
            No flags
            </summary>
        </member>
        <member name="F:Morpheus.CSerializationContext.EContextFields.REMOVE_NULL_VALUES_FROM_XML">
            <summary>
            can be used to save space arbitrarily by the application
            </summary>
        </member>
        <member name="F:Morpheus.CSerializationContext.EContextFields.FIX_M_">
            <summary>
            can be used to make output readable by removing the "m_" in front of field names
            </summary>
        </member>
        <member name="F:Morpheus.CSerializationContext.EContextFields.ARRAYS_WITH_EXPLICIT_ELEMENTS">
            <summary>
            Prevents condensed comma-separated-lists for simple array element types
            </summary>
        </member>
        <member name="F:Morpheus.CSerializationContext.EContextFields.ARRAY_ELEMENTS_INCLUDE_INDICIES">
            <summary>
            Adds an attribute with an array index for all array-element nodes
            </summary>
        </member>
        <member name="F:Morpheus.CSerializationContext.EContextFields.DU_STRINGS_CAN_BE_REFERRED_TO">
            <summary>
            Allows the serializer to "refer to" identical (usually interned) strings.
            </summary>
        </member>
        <member name="F:Morpheus.CSerializationContext.EContextFields.ALL">
            <summary>
            All possible flags
            </summary>
        </member>
        <member name="M:Morpheus.CSerializationContext.GetFlag(Morpheus.CSerializationContext.EContextFields)">
            <summary>
            Get a context flag from the context.
            </summary>
            <param name="_field">The flag to get</param>
            <returns>True or False, depending the state of the flag requested</returns>
        </member>
        <member name="M:Morpheus.CSerializationContext.ClearFlag(Morpheus.CSerializationContext.EContextFields)">
            <summary>
            Clear all context flags on the context
            </summary>
            <param name="_flag"></param>
        </member>
        <member name="P:Morpheus.CSerializationContext.RemoveNullValuesFromXml">
            <summary>
            When this is set, any field with a null value will not be placed into the serialized XML
            </summary>
            <remarks>
            Surrogates of all kinds should adhere to this request, but they are not required to.
            </remarks>
        </member>
        <member name="P:Morpheus.CSerializationContext.FixM_">
            <summary>
            When this property is set, the framework will change all fields that start with "m_" into names that 
            do not have the "m_" in front of them. This produces more readable Xml.
            </summary>
            <remarks>
            For example, if a field is named "m_name", the framework will turn this into "Name" by removing the
            "m_" and changing the first letter of what's left into an uppercase value. The third character MUST
            be a lower-case letter [a-z] in order for this to work.
            </remarks>
        </member>
        <member name="P:Morpheus.CSerializationContext.AllArraysHaveExplicitElements">
            <summary>
            When TRUE, all Arrays will be serialized with explicit XmlElements for each element in the array.
            By default, primitives and strings are serialized with a comma-separated list.
            </summary>
        </member>
        <member name="P:Morpheus.CSerializationContext.ArrayElementsIncludeIndicies">
            <summary>
            When TRUE, any array element that has its own XmlElement will have the integer-index of the element
            included as an attribute on the Array-element's XmlElement.
            By Default, array-elements are serialized in order of their position in the array itself. When the 
            array is deserialized, the elements are loaded into the array based on their ordinal position in the
            child-nodes of the array-node.
            </summary>
        </member>
        <member name="P:Morpheus.CSerializationContext.DuplicateStringsCanBeReferredTo">
            <summary>
            When TRUE, the serializer will recognize strings that are duplicate objects (usually happens with
            interned strings) and use a reference to a single version of the string. This may be useful
            when there are very large strings being serialized many times.
            </summary>
        </member>
        <member name="P:Morpheus.CSerializationContext.UseFullUtcDateTimeStrings">
            <summary>
            This property is a helper to assign the appropriate IExternalSurrogate to this Context based on the 
            application's needs. The application can use "RegisterExternalSurrogate" to achieve the same effect.
            </summary>
            <remarks>
            Since DateTime is part of the framework, the "framework surrogates" aren't typically associated with
            a Context object. However, in the case of DateTime, it could very regularly be required that a more
            "Readable" form of the DateTime be used for serialization.
            </remarks>
        </member>
        <member name="F:Morpheus.CSerializationContext.m_fieldRenamer">
            <summary>
            The field-renamer for this context instance
            </summary>
        </member>
        <member name="P:Morpheus.CSerializationContext.FieldRenamer">
            <summary>
            The Field Renamer for the serialization context
            </summary>
        </member>
        <member name="F:Morpheus.CSerializationContext.m_externalSurrogates">
            <summary>
            The dictionary linking serialization surrogates to System.Type's
            </summary>
            <remarks>
            Do not instantiate this unless someone actually registers a surrogate at this context-level.
            </remarks>
        </member>
        <member name="M:Morpheus.CSerializationContext.GetExternalSurrogate(System.Type)">
            <summary>
            This method will retrieve an external surrogate for a particular type.
            </summary>
            <param name="_type">The System.Type to look for</param>
            <returns>An ISerializationSurrogate that has been registered for that Type, or NULL if none has been registered.</returns>
        </member>
        <member name="M:Morpheus.CSerializationContext.RegisterExternalSurrogate(System.Type,Morpheus.IExternalSurrogate)">
            <summary>
            Register an external surrogate with this serialization context. External Surrogates take priority over
            all other serialization techniques, including implicit surrogates.
            </summary>
            <param name="_type">The System.Type that is to use this exernal surrogate</param>
            <param name="_surrogate">The surrogate to register with the Type</param>
            <remarks>
            While each Type may only have one External Surrogate registered with it for any particular context, a
            particular Type may have different surrogates registered at different "levels" of the Context inheritance
            chain.
            </remarks>
        </member>
        <member name="M:Morpheus.CSerializationContext.RemoveExternalSurrogate(System.Type)">
            <summary>
            Remove a registered surrogate for a particular Type. This will remove the surrogate ONLY IF it exists for
            this specific context- Inherited contexts will NOT be searched for the type.
            </summary>
            <param name="_type">The Type for which the surrogate needs to be removed</param>
            <returns>TRUE if the Type was found, FALSE if it was not.</returns>
        </member>
        <member name="P:Morpheus.CSerializationContext.RootElementName">
            <summary>
            The name of the root element
            </summary>
        </member>
        <member name="P:Morpheus.CSerializationContext.TypeAttributeName">
            <summary>
            The name of the attribute used for the Type of an element
            </summary>
        </member>
        <member name="P:Morpheus.CSerializationContext.NullAttributeName">
            <summary>
            The name used for the attribute signalling a NULL value
            </summary>
        </member>
        <member name="P:Morpheus.CSerializationContext.NullAttributeValue">
            <summary>
            The value to assign to the XML attribute when NULL is indicated
            </summary>
        </member>
        <member name="P:Morpheus.CSerializationContext.ReferenceIdAttributeName">
            <summary>
            The name of the attribute generated for a Reference ID
            </summary>
        </member>
        <member name="P:Morpheus.CSerializationContext.ReferToAttributeName">
            <summary>
            The name of the attrbute generated for a ReferTo
            </summary>
        </member>
        <member name="P:Morpheus.CSerializationContext.ArrayAttributeName">
            <summary>
            The name of the attrbute generated for an Array Attribute
            </summary>
        </member>
        <member name="P:Morpheus.CSerializationContext.ArrayElementName">
            <summary>
            The name of the element generated for an object contained in an array 
            </summary>
        </member>
        <member name="P:Morpheus.CSerializationContext.ArrayIndexAttributeName">
            <summary>
            The name of the attribute used for an index within an array
            </summary>
        </member>
        <member name="P:Morpheus.CSerializationContext.ArrayLowerBoundAttribute">
            <summary>
            The name for the attribute specifed for the lower bound of an array
            </summary>
        </member>
        <member name="P:Morpheus.CSerializationContext.UseEntitySemanticsAttributeName">
            <summary>
            The name of the Attribute to add to an Element when the serializer finds that it
            uses EntitySemantics
            </summary>
        </member>
        <member name="T:Morpheus.CSerializationHelpers">
            <summary>
            This class contains methods, mainly static, to serialize and deserialize objects to/from formats other than 
            XmlNodes and derivatives thereof.
            </summary>
        </member>
        <member name="M:Morpheus.CSerializationHelpers.ToFile(System.Object,System.String)">
            <summary>
            This helper will use a default CSerializer to serialize an object to a named file. It will overwrite that file.
            </summary>
            <param name="_object">The object to serializat</param>
            <param name="_filename">The name of the file to save the serialized object to</param>
        </member>
        <member name="M:Morpheus.CSerializationHelpers.ToFile(System.Object,System.String,Morpheus.CSerializationContext)">
            <summary>
            This helper will use a default CSerializer to serialize an object to a named file. It will overwrite that file.
            It will use a specified <see cref="T:Morpheus.CSerializationContext"/> to control the serialization
            </summary>
            <param name="_object">The object to serializat</param>
            <param name="_filename">The name of the file to save the serialized object to</param>
            <param name="_context">The Serialization Context to use for the serialization</param>
        </member>
        <member name="M:Morpheus.CSerializationHelpers.ToFile(System.Object,System.String,Morpheus.CSerializer)">
            <summary>
            This helper will use a default CSerializer to serialize an object to a named file. It will overwrite that file.
            </summary>
            <param name="_object">The object to serializat</param>
            <param name="_filename">The name of the file to save the serialized object to</param>
            <param name="_serializer">The Serializer to use in the serialization of the object</param>
        </member>
        <member name="M:Morpheus.CSerializationHelpers.ToString(System.Object,Morpheus.CSerializationContext)">
            <summary>
            This helper will turn an object into a properly formatted XML document, as a string.
            </summary>
            <param name="_object">The object to turn into a string</param>
            <param name="_context">The Serialization Context to use, if the default one won't work.</param>
            <returns>The object serialized as a string-form XML document</returns>
        </member>
        <member name="M:Morpheus.CSerializationHelpers.FromFile``1(System.String,Morpheus.CSerializationContext)">
            <summary>
            Retrieve a deserialized object from a file
            </summary>
            <typeparam name="T">The Type of the object that is to be deserialized</typeparam>
            <param name="_filename">The name of the file that contains the information for deserialization</param>
            <param name="_context">Serialization context for the operation</param>
            <returns>The object that was deserialized</returns>
        </member>
        <member name="M:Morpheus.CSerializationHelpers.FromFile``1(System.String,Morpheus.CDeserializer)">
            <summary>
            Given a filename and a deserializer, return the object that was created from deserializing the Xml in the file
            </summary>
            <typeparam name="T">The Type of the object that is to be deserialized</typeparam>
            <param name="_filename">The name of the file that contains the information for deserialization</param>
            <param name="_deserializer">The Deserializer to use for the deserialization</param>
            <returns>The object that was deserialized</returns>
        </member>
        <member name="T:Morpheus.CSerializer">
            <summary>
            This class provides methods that allow data to be transmuted between a .NET object and
            Xml.
            </summary>
            <remarks>
            This class will operate on ALL fields, including protected and private ones. If you
            don't like this idea, then don't use this class. Use the .NET Xml serializer instead.
            
            <code>
            EXAMPLES AND FORMATS
            --------------------
            class CPerson
            {
                string m_name;
                int m_age;
                CAddress m_address;
                string[] m_kidsNames;
                string m_aNullValue = null;
                CAddress m_otherAddress;
            }
            
            class CAddress
            {
                string Street;
                string City;
                int Zip;
            }
            
            class CSuperAddress : CAddress
            {
                string Country;
            }
            
            ---   yields   ---
            
            <CPerson>
                <Name>Homer Simpson</Name>
                <Age>35</Age>
                <Address>
                    <Street>45 Mount Horrible</Street>
                    <City>Springfield</City>
                    <Zip>84372</Zip>
                </Address>
                <KidsNames _Array="3">Bart,Lisa,Maggie</KidsNames>
                <ANullValue Null="true"/>
                <OtherAddress Type="CSuperAddress">
                    <Street>88 Schroeder Way</Street>
                    <City>Boston</City>
                    <Zip>12837</Zip>
                    <Country>USA</Country>
                </OtherAddress>
            </CPerson>
            
            </code>
            
            Use the "Helper" class for static methods.
            </remarks>
        </member>
        <member name="F:Morpheus.CSerializer.m_references">
            <summary>
            This table represents a set of all objects that have been referenced. It is used to
            prevent multiple-references (performance) and circular references (infinite loops).
            </summary>
        </member>
        <member name="F:Morpheus.CSerializer.m_refId">
            <summary>
            An incrementing ID representing the ID to be assigned to the next reference to be
            serialized.
            </summary>
        </member>
        <member name="M:Morpheus.CSerializer.#ctor">
            <summary>
            Default constructor uses the Global context
            </summary>
        </member>
        <member name="M:Morpheus.CSerializer.#ctor(Morpheus.CSerializationContext)">
            <summary>
            Construct with a default context object
            </summary>
            <param name="_context">The context object to use for the serialization</param>
        </member>
        <member name="M:Morpheus.CSerializer.Serialize(System.Object)">
            <summary>
            Serialize an object.
            </summary>
            <param name="_object">The object to serialize</param>
            <returns>An XmlDocument containing the serialized object</returns>
        </member>
        <member name="M:Morpheus.CSerializer.FrameworkSerialize(System.String,System.Object,System.Xml.XmlNode,System.Type)">
            <summary>
            Apply all of the rules of the framework to serialize an object into XML and add that
            XmlElement to a parent XmlNode.
            </summary>
            <param name="_nameForElement">
            The name to be attached to the element created for this object
            </param>
            <param name="_object">The object reference that is to be serialized</param>
            <param name="_parentNode">
            The "parent node" that will receive, as an appended child, the new serialized
            object's node
            </param>
            <param name="_expectedType">
            The Type that the object is "expected" to be. If the object is NOT of this type,
            then explicit Type information is added.
            </param>
        </member>
        <member name="M:Morpheus.CSerializer.CreateElementForValue(System.String,System.Object,System.Xml.XmlNode,System.Type)">
            <summary>
            Create an XmlElement for an object. Do not populate the new element.
            </summary>
            <remarks>
            FieldRenamers are NOT called at this level- the caller of this method needs to
            handle all field renaming
            </remarks>
            <param name="_elementName">
            The name that should be assigned to the newly created element
            </param>
            <param name="_expectedType">
            The expected type of the object. Used to decide whether or not to add explicit Type
            data
            </param>
            <param name="_object">The object that is being serialized</param>
            <param name="_parentNode">The XML node that the new node will be a child of</param>
            <returns>An XmlElement with some basic attributes for an object</returns>
        </member>
        <member name="M:Morpheus.CSerializer.ApplySurrogates(System.Object,System.Xml.XmlElement,System.Type)">
            <summary>
            Apply any surrogates to the object for serialization
            </summary>
            <param name="_object">The object that may be serialized with a surrogate</param>
            <param name="_elementForObject">
            The XmlElement that is to receive the object data
            </param>
            <param name="_useType">
            The Type that the object should be treated as. If NULL, use object.GetType()
            </param>
            <returns>
            TRUE if the serialziation was completed by a surrogate, FALSE if the framework
            should do its job.
            </returns>
        </member>
        <member name="M:Morpheus.CSerializer.SerializeUsingEntitySemantics(System.Object,System.Type,System.Xml.XmlElement)">
            <summary>
            This "different" serializer handles Properties, not Fields, and conforms to the
            conventions found in Microsoft's Entity Framework
            </summary>
            <param name="_object"></param>
            <param name="_useType"></param>
            <param name="_elementForObject"></param>
        </member>
        <member name="M:Morpheus.CSerializer.HandleDuplicateReferences(System.Object,System.Xml.XmlElement)">
            <summary>
            Check to see if the object has been serialized before. If it has, then make sure
            that the reference information for it is added.
            </summary>
            <remarks>This routine has the overloaded</remarks>
            <param name="_object">The object that's being serialized</param>
            <param name="_elementForObject">
            The element that the object is being serialized to
            </param>
            <returns>TRUE if the object is a duplicate, FALSE if it is a "new" object</returns>
        </member>
        <member name="M:Morpheus.CSerializer.AddObjectToElement(System.Object,System.Xml.XmlElement)">
            <summary>
            Add an object to an element. This is the "standard framework way" to serialize an
            object.
            </summary>
            <param name="_object">
            The object to be serialized. No assumption made about the object.
            </param>
            <param name="_elementForObject">
            The element that will receive the serialized data
            </param>
        </member>
        <member name="M:Morpheus.CSerializer.AddReferenceTypeToXml(System.Object,System.Xml.XmlElement)">
            <summary>
            Add all of the fields of a reference type to the XML. Add all of the base classes of
            the type as well.
            </summary>
            <remarks>
            Assume a non-null object. This is a private, thus controlled access, method.
            </remarks>
            <param name="_object">
            The object to be serialized. We know that the object is a ref-type that may have
            fields and a base-class
            </param>
            <param name="_elementForObject">The Element to add data to for this object</param>
        </member>
        <member name="M:Morpheus.CSerializer.AddTypeFieldsToXml(System.Object,System.Xml.XmlElement,Morpheus.Serialization.CTypeData)">
            <summary>
            Add all of the fields of a given object identified by a CTypeData-descriptor to the
            XML.
            </summary>
            <param name="_object">The object containing the fields / fieldData</param>
            <param name="_elementForObject">
            The XML Element to add the data to (each field becomes a childNode)
            </param>
            <param name="_typeData">
            The descriptor which identifies which fields on the _object to add to the XML
            </param>
        </member>
        <member name="M:Morpheus.CSerializer.AddArrayToXml(System.Array,System.Xml.XmlElement)">
            <summary>
            Use this method when an Array field needs to be added to the XML serialization
            </summary>
            <remarks>
            For element types that are primitives and strings, build a comma-separated list of
            values that should end up taking less space. For all other element types, create
            child-elements for each array element.
            </remarks>
            <param name="_array">The array to add to the XML Element</param>
            <param name="_elementToAddTo">The XML Element that is to contain the array</param>
        </member>
        <member name="M:Morpheus.CSerializer.AddMultiDimensionalArray(System.Array,System.Xml.XmlElement)">
            <summary>
            Add a multi-dimensional array to an element.
            </summary>
            <param name="_array">The array to add</param>
            <param name="_elementToAddTo">The element to add the array to</param>
        </member>
        <member name="T:Morpheus.CSurrogate">
            <summary>
            This class defines information about an implicit surrogate. This wraps up Implicit surrogates- External surrogates are controlled
            on a "contextual" basis, while Implicit surrogates are always used.
            </summary>
            <remarks>
            Information on Surrogates:
            
            Implicit Surrogates are essentially function pointers to methods in a class responsible for serialization and deserialization
            for that class. It was a difficult decision to use reflection to find implicit surrogates. Because there
            is no way to specify both constructors AND static methods using interfaces (the prefered mechanism), the
            Deserialization process would have been subject to Reflection regardless of the use of an interface for the
            Serialization aspect. Because of this dichotomy, I chose to use a similar mechanism for BOTH serialization AND
            Deserialization- the alternative would have been to use an interface for one and reflection for the other, and
            i really dislike that option.
            
            All implicit surrogates must follow this calling convention:
            
                        Serializer: bool = fn( XmlNode [, CSerializer] )
                                    -- Serializer is an INSTANCE Method
                      Return Value: a "bool" value telling the framework whether or not the surrogate "completed" the job. 
                                        A "FALSE" return value tells the framework to continue processing the object 
                                        as if there were no surrogate. This can be used in conjunction with the <see cref="T:Morpheus.ADoNotSerialize"/>
                                        attribute to do custom serialization on those fields that need special consideration, while 
                                        letting the Framework do all of the "standard" work.
                          XmlNode : Contains the "parent" XmlNode (XmlElement) into which this surrogate is to add data.
                      CSerializer : Contains the Serialization Context that MAY GIVE HINTS to the surrogate, but the surrogate can do whatever it wants
            
            
                      Deserializer: bool = fn( CWorkingObject, XmlNode [, CDeserializer] )
                                    -- Deserializer is a STATIC Method
                      Return Value: a "bool" value telling the framework whether or not the surrogate "completed" the job. 
                   CWorkingObject : A "Working Object" that the surrogate can use to determine if it needs to create a new object or use a pre-created one
                          XmlNode : Contains the data, in XML format, for the deserialization.
                    CDeserializer : Contains the Deserialization Context that MAY GIVE HINTS to the surrogate, but the surrogate can do whatever it wants
            
            An XmlElement will be sent to the surrogate, but the surrogate can accept either an XmlElement -or- an XmlNode.
            
            Because reflection is being used, and because there's no way to enforce type-safety at compile-time, I chose
            to allow the programmer some leeway in the construction of the methods. 
            
            * Both serialization and deserialization REQUIRE the presence of an XmlNode or an XmlElement parameter, for this is the crux of 
              this library's functionality.
            * All of the parameters can be placed in any position in the parameter list- this class will sort it all out.
            
            </remarks>
        </member>
        <member name="T:Morpheus.CSurrogate.CImplicitSurrogate">
            <summary>
            This class contains reflection data about the implicit surrogate
            </summary>
        </member>
        <member name="F:Morpheus.CSurrogate.CImplicitSurrogate.m_method">
            <summary>
            The method that can be .Invoke'ed
            </summary>
        </member>
        <member name="F:Morpheus.CSurrogate.CImplicitSurrogate.m_parameterCount">
            <summary>
            The number of parameters that the surrogate accepts
            </summary>
        </member>
        <member name="F:Morpheus.CSurrogate.CImplicitSurrogate.m_indexXml">
            <summary>
            The index in the parameter array where to put the (required) XmlNode
            </summary>
        </member>
        <member name="F:Morpheus.CSurrogate.CImplicitSurrogate.m_indexFramework">
            <summary>
            The index in the parameter array where to put the (optional) CFramework object
            </summary>
        </member>
        <member name="F:Morpheus.CSurrogate.CImplicitSurrogate.m_indexObject">
            <summary>
            The index in the parameter array where to put the (optional) bool out-param
            </summary>
        </member>
        <member name="M:Morpheus.CSurrogate.CImplicitSurrogate.#ctor(System.Reflection.MethodInfo,System.Int32)">
            <summary>
            Initialize the ImplicitSurrogate object with the method for the surrogate and the number of parameters for the method.
            </summary>
            <param name="_methodInfo">The MethodInfo object for calling the method</param>
            <param name="_parameterCount">The number of parameters for the method</param>
        </member>
        <member name="F:Morpheus.CSurrogate.m_type">
            <summary>
            The System.Type that this surrogate will take effect for. This must be specified in the constructor
            of this surrogate.
            </summary>
        </member>
        <member name="F:Morpheus.CSurrogate.m_implicitSerializer">
            <summary>
            The implicit serializer
            </summary>
        </member>
        <member name="F:Morpheus.CSurrogate.m_implicitDeserializer">
            <summary>
            The implicit Deserializer
            </summary>
        </member>
        <member name="P:Morpheus.CSurrogate.HasSurrogate">
            <summary>
            Return TRUE if there is surrogate information for the Type, FALSE if not
            </summary>
        </member>
        <member name="M:Morpheus.CSurrogate.#ctor(System.Type)">
            <summary>
            Construct the surrogate info object using the Type that may have surrogate info.
            </summary>
            <param name="_type">The Type to search for a Surrogate for</param>
        </member>
        <member name="M:Morpheus.CSurrogate.FindSurrogates">
            <summary>
            Look at the Type for the presence of implicit surrogates. It is OK not to find ANY surrogates, but
            it is NOT OK to find one surrogate and not a second.
            </summary>
            <returns>TRUE if an implicit surrogate was found, FALSE if not</returns>
        </member>
        <member name="M:Morpheus.CSurrogate.EstablishImplicitSerializer(System.Reflection.MemberInfo)">
            <summary>
            Given a class member that has already been established as having a <see cref="T:Morpheus.AImplicitSerializer"/>
            attribute, figure out if its a legitimate member to have that attribute. If it is, set the
            Implicit Serializer property of this object to the member. If it is not, throw an exception.
            </summary>
            <param name="_member">The member of the type in question</param>
        </member>
        <member name="M:Morpheus.CSurrogate.EstablishImplicitDeserializer(System.Reflection.MemberInfo)">
            <summary>
            Given a class member that has already been established as having a <see cref="T:Morpheus.AImplicitDeserializer"/>
            attribute, figure out if its a legitimate memeber to have that attribute. If it is, set the
            Implicit Deserializer property of this object to this member. If it is not, throw an exception.
            </summary>
            <param name="_member">The member of the type to examine</param>
        </member>
        <member name="M:Morpheus.CSurrogate.CreateImplicitSurrogate(System.Reflection.MethodInfo,System.Boolean)">
            <summary>
            Assuming that the member is already "legal", now check its parameters. 
            </summary>
            <param name="_method">The method information that needs to be checked.</param>
            <param name="_isDeserializer">If TRUE, then check the member to see if it has an "CWorkingObject" parameter.</param>
            <returns>The surrogate information IF the member is a valid surrogate.</returns>
        </member>
        <member name="M:Morpheus.CSurrogate.ProcessParameterType(System.Reflection.ParameterInfo,System.Type,System.Reflection.MethodInfo,System.Int32@)">
            <summary>
            Handler for dealing with a specific parameter on an implicit surrogate.
            </summary>
            <remarks>
            When processing parameters for an implicit surrogate, we test the parameter against an "expected type". The parameter type
            must be cast-able to the expected type. Also, we check the "index" of the parameter to make sure we haven't "found" a 
            parameter of that type before. 
            
            If the parameter is NOT of the type, then return false.
            If the parameter IS of the type, check the index to make sure its not been set before, and set it to the value specified
            as the "currentIndex" parameter to this function.
            
            Huge fallback is that this does not work as-is if a method is meant to have multiple parameters of the same type.
            
            The only reason that this is not a STATIC member is 
            </remarks>
            <param name="_paramInfo">The ParameterInfo object for this parameter</param>
            <param name="_expectedType">The expected type for the parameter- The actual type must be cast-able to this type</param>
            <param name="_method">The <see cref="T:System.Reflection.MethodInfo"/> for the method we're checking</param>
            <param name="_index">A reference to the storage location where the Index will be stored.</param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CSurrogate.BuildParamArray(Morpheus.CSurrogate.CImplicitSurrogate,System.Xml.XmlElement,Morpheus.Serialization.CFramework,Morpheus.CWorkingObject)">
            <summary>
            Create the parameter array for an implicit surrogate using the data created by the rest of this class.
            </summary>
            <param name="_implicit">The implicit surrogate</param>
            <param name="_xmlToSerializeTo">The XML that the object will serialize itself to</param>
            <param name="_framework">The Context that the object will use (optionally) to serialize the data.</param>
            <param name="_object">The "Working Object" useful to a deserializer</param>
            <returns>an object[] containing the parameter data as dictated by the implicitSurrogate object</returns>
        </member>
        <member name="M:Morpheus.CSurrogate.Serialize(System.Object,System.Xml.XmlElement,Morpheus.CSerializer)">
            <summary>
            Serialize an object of this type.
            </summary>
            <param name="_object">The object to serialize</param>
            <param name="_xml">The XML node that will receive the data for the serialization</param>
            <param name="_serializer">The serialization context to help with serialization</param>
            <returns>TRUE if the serialization is complete, FALSE if the framework needs to complete the serialization</returns>
        </member>
        <member name="M:Morpheus.CSurrogate.Deserialize(Morpheus.CWorkingObject,System.Xml.XmlElement,Morpheus.Serialization.CFramework)">
            <summary>
            Deserialize an object of this type.
            </summary>
            <param name="_object">A reference to an object that is being deserialized. NULL --> The serializer needs to create the object!</param>
            <param name="_xml">The XML node that contains the data for the deserialization</param>
            <param name="_framework">The serialization context to help with deserialization</param>
            <returns>TRUE if the deserialization is complete, FALSE if the framework needs to complete the deserialization</returns>
        </member>
        <member name="T:Morpheus.CWorkingObject">
            <summary>
            This class deals with the deserialization process and the need to assocate a the 
            current working-object of a deserialization as soon as that object is created. This is 
            because of the needs of resolving multiple-references to the same object.
            </summary>
        </member>
        <member name="P:Morpheus.CWorkingObject.WorkingObject">
            <summary>
            The Working Object for the instance.
            </summary>
        </member>
        <member name="P:Morpheus.CWorkingObject.WorkingType">
            <summary>
            Used in Surrogate Deserialization to understand which superclass of a Type is being
            deserialized. Useful when default deserialization happens for a subclass, but 
            surrogate deserialization occurs in a base class.
            </summary>
        </member>
        <member name="F:Morpheus.CWorkingObject.m_deserializer">
            <summary>
            The deserializer that is in control of the deserialzation dealing with this working 
            object
            </summary>
        </member>
        <member name="F:Morpheus.CWorkingObject.m_refId">
            <summary>
            The refID that is to be associated with the working object when it is set
            </summary>
        </member>
        <member name="P:Morpheus.CWorkingObject.IsSet">
            <summary>
            Return TRUE if the current working object is referencing something, FALSE if 
            it is NULL
            </summary>
        </member>
        <member name="M:Morpheus.CWorkingObject.Set(System.Object)">
            <summary>
            Set the working object to some new object. This may only be called once for a 
            workingObject instance
            </summary>
            <param name="_object">The object that is to be the new working object</param>
        </member>
        <member name="M:Morpheus.CWorkingObject.UpdateDeserializer">
            <summary>
            Update the Deserializer's reference table with the information found in this 
            working object.
            </summary>
        </member>
        <member name="M:Morpheus.CWorkingObject.SetRefInfo(Morpheus.CDeserializer,System.String)">
            <summary>
            Used by the framework when it realizes that the working object needs to be 
            assocated with a reference ID
            </summary>
            <param name="_deserializer">The instance of the deserializer working on this 
            object</param>
            <param name="_refId">The ID to be associated with the object WHEN it is 
            assigned.</param>
        </member>
        <member name="M:Morpheus.CWorkingObject.GetExistingOrCreateNew``1">
            <summary>
            Use this method in your deserializer when you don't really care if the 
            WorkingObject has been created yet or if it needs to be created. This method will 
            check for a previously created object, and if it doesn't exist, it will create a 
            new object using a parameter-less constructor.
            </summary>
            <typeparam name="TObjectType">The Type of the object that the surrogate is 
            expecting</typeparam>
            <returns>A non-NULL object reference cast to the Type specified</returns>
            <exception cref="T:System.InvalidCastException">Thrown if there is an existing working 
            object, but that object cannot be cast to the Type specified.</exception>
        </member>
        <member name="M:Morpheus.CWorkingObject.GetExistingOrCreateNew(System.Type)">
            <summary>
            Use this method in your deserializer when you don't really care if the 
            WorkingObject has been created yet or if it needs to be created. This method will 
            check for a previously created object, and if it doesn't exist, it will create a 
            new object using a parameter-less constructor.
            </summary>
            <param name="_objectType">The Type of the object that the surrogate is expecting
            </param>
            <returns>A non-NULL object reference cast to the Type specified</returns>
            <exception cref="T:System.InvalidCastException">Thrown if there is an existing working 
            object, but that object cannot be cast to the Type specified.</exception>
        </member>
        <member name="M:Morpheus.CWorkingObject.GetWorkingObject``1">
            <summary>
            Helper function that returns the existing workingObject pre-cast to the
            specified Type.
            </summary>
            <typeparam name="TObjectType">
            The Type to pre-cast the working object to
            </typeparam>
            <returns>The Working Object pre-cast to the specified Type.</returns>
        </member>
        <member name="T:Morpheus.IExternalSurrogate">
            <summary>
            This interface is used by the serializer framework in order to provide custom external serialization and 
            deserialization for any Types. External serialization is used when an application does not have access to 
            the Type's definition.
            </summary>
            <remarks>
            External serializers are generally useful for two things-
            
            1) External Surrogates can be used for serializing classes that an application did not write, but would like to 
                have control over how the class is serialized. Primarily, this will include classes in the .NET Framework
                (mscorlib, etc) or in libraries written by other people.
            2) They can be used if an application wants to serialize a type in a certain way under certain circumstances,
                but still wants the serialization framework to be able to serialize the Type under "normal" circumstances.
                This is accomplished using the <see cref="T:Morpheus.CSerializationContext"/> class to associate an external surrogate
                with a serializer/deserializer.
            </remarks>
        </member>
        <member name="M:Morpheus.IExternalSurrogate.Serialize(System.Object,System.Type,System.Xml.XmlElement,Morpheus.CSerializer)">
            <summary>
            Given an object and a "parent" xml element, add all of the information describing the object (its fields, 
            for instance) to the parent element. The implementation of this method should be very cautious about 
            modifying the parent element itself- generally the only acceptable thing to do with the parent is to -add-
            new attributes and elements. It is VERY DANGEROUS to look past the element itself- The implementation 
            should not need to deal with ancestors and/or siblings of the passed-in element.
            </summary>
            <param name="_object">The object whose data needs to be added to _parentNode</param>
            <param name="_useType">The Type of the object to use- Important when applying a surrogate to a base 
            class when the subclass didn't have a surrogate</param>
            <param name="_parentElement">The "Parent" XmlElement that should recieve _object's data</param>
            <param name="_serializer">The serializer instance making this call- used to get current context.</param>
            <returns>TRUE if the surrogate was able to completely serialize the object, FALSE if the framework should 
            perform its "default" function.</returns>
        </member>
        <member name="M:Morpheus.IExternalSurrogate.Deserialize(Morpheus.CWorkingObject,System.Xml.XmlElement,Morpheus.CDeserializer)">
            <summary>
            Given an XmlElement and a "CWorkingObject" instance, try to deserialize the Xml into the working object.
            The surrogate may be responsible for object creation- the _workingObject should be checked to see if
            an object has already been created (by, for instance, a super-class). All of the information for the 
            object should be wholely contained within the XmlElement supplied. The implementation should never need
            to "hunt around" the XML DOM for information about the object.
            </summary>
            <param name="_workingObject">The container for object that is being deserialized. If the "WorkingObject"
            property is a NULL value, then the deserializer is expected to create the object and use the 
            <see cref="M:Morpheus.CWorkingObject.Set(System.Object)"/> method to assign the newly created object to the working object. If it 
            is NOT a null value, then the deserializer is not allowed to modify this "Working Object" value.</param>
            <param name="_parentElement">The XmlElement containing the data to populate the object with</param>
            <param name="_deserializer">The CDeserializer instance making this call- This can be used to get the
            context information or any other relevent information.</param>
            <returns>TRUE if the surrogate was able to completely deserialize the object, FALSE if the framework should 
            perform its "default" function.</returns>
        </member>
        <member name="T:Morpheus.IFieldRenamer">
            <summary>
            This interface is implemented when an application wants to rename fields using some 
            externally defined algorithm.
            </summary>
            <remarks>
            The process that changes fields beginning with "m_" uses this interface to accomplish 
            that task.
            
            This is generally a "global" process. To change the name of specific fields, use the 
            <see cref="T:Morpheus.ASerializedName"/> attribute. This interface is also used by the 
            <see cref="T:Morpheus.AUseFieldRenamer"/> attribute to change the fields on a specific class.
            </remarks>
        </member>
        <member name="M:Morpheus.IFieldRenamer.ConvertFieldName(System.String,System.Reflection.FieldInfo)">
            <summary>
            Change the name of a field into some other name. If no change is to occur, simply 
            return value passed in.
            </summary>
            <param name="_fieldName">The name of the field whose name you are changing</param>
            <param name="_fieldInfo">The FieldInfo for the field whose name you are changing</param>
            <returns>
            The "New Name" for the field, or simply return _fieldName if no change is to 
            occur. Never return NULL unless NULL is passed in to the routine.
            </returns>
        </member>
        <member name="T:Morpheus.ProtobufFieldRenamer">
            <summary>
            This class is used to remove trailing underscore from Protobuf fields, assuring that the first letter of the
            field name is capitalized.
            </summary>
        </member>
        <member name="M:Morpheus.ProtobufFieldRenamer.ConvertFieldName(System.String,System.Reflection.FieldInfo)">
            <summary>
            This method will check the name of a field for the "_" postfix and change it to something 
            "more readable" if reasonable.
            </summary>
            <param name="_fieldName">The name of the field to convert</param>
            <param name="_fieldInfo">The <see cref="T:System.Reflection.FieldInfo"/> for the field</param>
            <returns>The new name of the field (may be the same as the original!)</returns>
        </member>
        <member name="M:Morpheus.ProtobufFieldRenamer.ConvertName(System.String)">
            <summary>
            This method will check the name of a field for the "m_" prefix and change it to something 
            "more readable" if reasonable.
            </summary>
            <param name="_name">The name of the field to try to change</param>
            <returns>The new name of the field (may be the same as the original!)</returns>
        </member>
        <member name="T:Morpheus.AElementName">
            <summary>
            This attribute is used to specify a specific name for elements of a collection when
            serializing that collection. This is not used for deserialization
            </summary>
        </member>
        <member name="M:Morpheus.AElementName.#ctor(System.String)">
            <summary>
            Construct the attribute with the name to be used to serialize the collection
            </summary>
            <param name="_name">The name for elements of the collection</param>
        </member>
        <member name="P:Morpheus.AElementName.Name">
            <summary>
            The name to be used when serializing elements of the collection.
            </summary>
        </member>
        <member name="T:Morpheus.ATreatAsInterface">
            <summary>
            This attribute is optional, and instructs the serialization framework whether or not to treat a field
            as an interface even though it may be declared as a specific implementation class (Hashtable vs IDictionary).
            The distinction is important because, when treated as an Interface, none of the "extra" fields governing
            the specific implementation are included (Capacity, Comparers, etc).
            </summary>
        </member>
        <member name="M:Morpheus.ATreatAsInterface.#ctor(System.Boolean)">
            <summary>
            Specifiy with this attribute whether or not "interface serialization" should be used rather than
            serialization using the actual class.
            </summary>
            <param name="_useSpecialSerialization">TRUE will result in more concise serialization based on the 
            Interface for collections.</param>
        </member>
        <member name="P:Morpheus.ATreatAsInterface.UseSpecialSerialization">
            <summary>
            When TRUE, use the Interface rather than the implementation for collections.
            </summary>
        </member>
        <member name="M:Morpheus.ATreatAsInterface.TreatAsInterface(Morpheus.Serialization.CFramework)">
            <summary>
            Helper function that will allow a surrogate to check to see if a collection should be treated
            as if it were an interface as opposed to being treated as a full class.
            </summary>
            <param name="_framework">The (de)serialization framework in charge of this operation</param>
            <returns>TRUE if the collection SHOULD be treated as if it were a simple interface</returns>
        </member>
        <member name="T:Morpheus.CDateTimeSurrogate">
            <summary>
            Optimize the data needed to serialize a DateTime object.
            </summary>
            <remarks>
            Use Hexdecimal to further shorten the length of the serialized string
            </remarks>
        </member>
        <member name="M:Morpheus.CDateTimeSurrogate.Serialize(System.Object,System.Type,System.Xml.XmlElement,Morpheus.CSerializer)">
            <summary>
            Turn a DateTime into a string and add that string to the parent node
            </summary>
            <param name="_object">The DateTime object</param>
            <param name="_useType">The Type that _object is to be treated as</param>
            <param name="_parentNode">The node to place the DateTime string into</param>
            <param name="_serializer">The serializer- not used</param>
        </member>
        <member name="M:Morpheus.CDateTimeSurrogate.Deserialize(Morpheus.CWorkingObject,System.Xml.XmlElement,Morpheus.CDeserializer)">
            <summary>
            Turn the innerText of an XML node into a DateTime and return that DateTime
            </summary>
            <param name="_object">The object to deserialize into</param>
            <param name="_node">The node containing the DateTime string</param>
            <param name="_deserializer">The serializer- not used</param>
            <returns>a DateTime object</returns>
        </member>
        <member name="T:Morpheus.CGuidSurrogate">
            <summary>
            The fields in a guid are numerous and small- the string representation of a guid is much more efficient
            </summary>
        </member>
        <member name="M:Morpheus.CGuidSurrogate.Serialize(System.Object,System.Type,System.Xml.XmlElement,Morpheus.CSerializer)">
            <summary>
            Turn a guid into a string and add that string to the parent node
            </summary>
            <param name="_object">The GUID object</param>
            <param name="_useType">Treat the "_object" parameter as if it were of this type</param>
            <param name="_parentNode">The node to place the guid string into</param>
            <param name="_serializer">The serializer- not used.</param>
        </member>
        <member name="M:Morpheus.CGuidSurrogate.Deserialize(Morpheus.CWorkingObject,System.Xml.XmlElement,Morpheus.CDeserializer)">
            <summary>
            Turn the innerText of an XML node into a guid and return that guid
            </summary>
            <param name="_node">The node containing the GUID string</param>
            <param name="_object">The object to deserialize into</param>
            <param name="_deserializer">The Deserializer- not used</param>
            <returns>a GUID object</returns>
        </member>
        <member name="T:Morpheus.CUtcDateTimeSurrogate">
            <summary>
            This class implements <see cref="T:Morpheus.IExternalSurrogate"/> and provides an alternate format for 
            DateTime structures. This format follows the UTC "Complete date plus hours, minutes and seconds"
            </summary>
        </member>
        <member name="P:Morpheus.CUtcDateTimeSurrogate.Surrogate">
            <summary>
            The IExternalSurrogate that can be used to serialize and deserialize DateTime structures.
            </summary>
        </member>
        <member name="F:Morpheus.CUtcDateTimeSurrogate.UTC_COMPLETE_DATE_TIME_FORMAT">
            <summary>
            The DateTime customer format string for the UTC "Complete date plus hours, minutes and seconds"
            </summary>
        </member>
        <member name="M:Morpheus.CUtcDateTimeSurrogate.ToString(System.DateTime)">
            <summary>
            Turn a DateTime struct into a complete UTC format.
            </summary>
            <param name="_dateTime">The DateTime struct to convert</param>
            <returns>A string representing the DateTime in UTC (complete) format.</returns>
        </member>
        <member name="M:Morpheus.CUtcDateTimeSurrogate.FromString(System.String)">
            <summary>
            Turn a string assumed to contain a date/time in complete UTC form into a DateTime struct.
            </summary>
            <param name="_dateTime">The string version of the DateTime</param>
            <returns>The DateTime form of the string</returns>
        </member>
        <member name="M:Morpheus.CUtcDateTimeSurrogate.Serialize(System.Object,System.Type,System.Xml.XmlElement,Morpheus.CSerializer)">
            <summary>
            This is the SerializationSurrogate used to turn a <see cref="T:System.DateTime"/> structure into a UTC
            "Complete date plus hours, minutes and seconds" string.
            </summary>
            <param name="_object">The (presumed to be) DateTime object</param>
            <param name="_useType">Treat the "_object" parameter as if it were of this type</param>
            <param name="_parentNode">The node to place the UTC string into</param>
            <param name="_serializer">The serializer- not used.</param>
            <returns>"true", because this routine completely serializes the DateTime</returns>
        </member>
        <member name="M:Morpheus.CUtcDateTimeSurrogate.Deserialize(Morpheus.CWorkingObject,System.Xml.XmlElement,Morpheus.CDeserializer)">
            <summary>
            This is the Deserializer to turn a UTC "Complete date plus hours, minutes and seconds" string
            back into a DateTime structure.
            </summary>
            <param name="_workingObject">The object that is to receive the new DateTime structure</param>
            <param name="_parentNode">The node whose InnerText contains the UTC string</param>
            <param name="_deserializer">The deserializer- not used.</param>
            <returns>"true", because this routine completely deserializes the DateTime</returns>
        </member>
        <member name="T:Morpheus.CStringBuilderSurrogate">
            <summary>
            Optimize the data needed to serialize a <see cref="T:System.Text.StringBuilder"/> object.
            </summary>
        </member>
        <member name="M:Morpheus.CStringBuilderSurrogate.Serialize(System.Object,System.Type,System.Xml.XmlElement,Morpheus.CSerializer)">
            <summary>
            Turn a DateTime into a string and add that string to the parent node
            </summary>
            <param name="_object">The DateTime object</param>
            <param name="_useType">The Type that _object is to be treated as</param>
            <param name="_parentNode">The node to place the DateTime string into</param>
            <param name="_serializer">The serializer- not used</param>
        </member>
        <member name="M:Morpheus.CStringBuilderSurrogate.Deserialize(Morpheus.CWorkingObject,System.Xml.XmlElement,Morpheus.CDeserializer)">
            <summary>
            Turn the innerText of an XML node into a DateTime and return that DateTime
            </summary>
            <param name="_object">The object to deserialize into</param>
            <param name="_node">The node containing the DateTime string</param>
            <param name="_deserializer">The serializer- not used</param>
            <returns>a DateTime object</returns>
        </member>
        <member name="T:Morpheus.XDeserializationError">
            <summary>
            This is a custom exception dealing with Deserialization.
            </summary>
        </member>
        <member name="M:Morpheus.XDeserializationError.#ctor(System.String)">
            <summary>
            Construct the exception with a message
            </summary>
            <param name="_message">Presumably a message describing the deserialization error</param>
        </member>
        <member name="T:Morpheus.XInvalidImplicitSerializer">
            <summary>
            This is a custom exception dealing with classes that use the <see cref="T:Morpheus.AImplicitDeserializer"/>
            and <see cref="T:Morpheus.AImplicitSerializer"/> attributes incorrectly.
            </summary>
        </member>
        <member name="F:Morpheus.XInvalidImplicitSerializer.Type">
            <summary>
            The <see cref="F:Morpheus.XInvalidImplicitSerializer.Type"/> of object that was being serialized
            </summary>
        </member>
        <member name="F:Morpheus.XInvalidImplicitSerializer.Member">
            <summary>
            <see cref="N:System.Reflection"/> information about the member being serialized
            </summary>
        </member>
        <member name="F:Morpheus.XInvalidImplicitSerializer.Text">
            <summary>
            Some message presumably describing the error
            </summary>
        </member>
        <member name="M:Morpheus.XInvalidImplicitSerializer.#ctor(System.Type,System.Reflection.MemberInfo,System.String)">
            <summary>
            Constructor with information about the implicit serializer
            </summary>
            <param name="_type">The <see cref="F:Morpheus.XInvalidImplicitSerializer.Type"/> of object that was being serialized</param>
            <param name="_member"><see cref="N:System.Reflection"/> information about the member being serialized</param>
            <param name="_text">Some message presumably describing the error</param>
        </member>
        <member name="P:Morpheus.XInvalidImplicitSerializer.Message">
            <summary>
            Some message presumably describing the error
            </summary>
        </member>
        <member name="M:Morpheus.XInvalidImplicitSerializer.ToString">
            <summary>
            Some message presumably describing the error
            </summary>
        </member>
        <member name="T:Morpheus.XSerializationError">
            <summary>
            This is a custom exception dealing with serialization.
            </summary>
        </member>
        <member name="M:Morpheus.XSerializationError.#ctor(System.String)">
            <summary>
            Construct the exception with a message
            </summary>
            <param name="_message">Presumably a message describing the serialization error</param>
        </member>
        <member name="T:Morpheus.XUnknownReference">
            <summary>
            Thrown when an element refers to a "reference element", but that reference element has not been deserialized yet.
            </summary>
        </member>
        <member name="M:Morpheus.XUnknownReference.#ctor(System.String)">
            <summary>
            Construct the exception with a message
            </summary>
            <param name="_message">Presumably a message describing which reference was unknown</param>
        </member>
        <member name="T:Morpheus.CMemoryStream">
            <summary>
            A stripped down version of <see cref="T:System.IO.MemoryStream"/> that allows the underlying
            buffer to be reassigned at will.
            </summary>
        </member>
        <member name="F:Morpheus.CMemoryStream.m_buffer">
            <summary>
            Reference to the external buffer to use as a stream
            </summary>
        </member>
        <member name="F:Morpheus.CMemoryStream.m_origin">
            <summary>
            The origin in the external buffer for the stream
            </summary>
        </member>
        <member name="F:Morpheus.CMemoryStream.m_length">
            <summary>
            The length of data within the external buffer that is valid to return
            </summary>
        </member>
        <member name="F:Morpheus.CMemoryStream.m_position">
            <summary>
            The current position in the "stream" (offset from m_origin)
            </summary>
        </member>
        <member name="F:Morpheus.CMemoryStream.m_readOnly">
            <summary>
            When set, disable the ability to "Write" to this stream.
            </summary>
        </member>
        <member name="M:Morpheus.CMemoryStream.#ctor">
            <summary>
            Default constructor creates a zero-length array as the "stream"
            </summary>
        </member>
        <member name="M:Morpheus.CMemoryStream.#ctor(System.Byte[])">
            <summary>
            Initialize the CMemoryReaderStream with an entire byte[]
            </summary>
            <param name="_buffer">The byre[] to use with this object</param>
        </member>
        <member name="M:Morpheus.CMemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Initialize the CMemoryReaderStream with a portion of a byte[]
            </summary>
            <param name="_buffer">The byre[] to use with this object</param>
            <param name="_offset">The offset into _buffer to start the stream</param>
            <param name="_length">The length of data in the buffer to use</param>
        </member>
        <member name="M:Morpheus.CMemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Initialize the CMemoryReaderStream with a portion of a byte[]
            </summary>
            <param name="_buffer">The byre[] to use with this object</param>
            <param name="_offset">The offset into _buffer to start the stream</param>
            <param name="_length">The length of data in the buffer to use</param>
            <param name="_readOnly">Used to make this stream a "Read-only" stream.</param>
        </member>
        <member name="M:Morpheus.CMemoryStream.SetBuffer(System.Byte[])">
            <summary>
            Set the internal buffer using an entire byte[]
            </summary>
            <param name="_buffer">The byre[] to use with this object</param>
        </member>
        <member name="M:Morpheus.CMemoryStream.SetBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set the buffer for the CMemoryReaderStream with a portion of a byte[]
            </summary>
            <param name="_buffer">The byre[] to use with this object</param>
            <param name="_offset">The offset into _buffer to start the stream</param>
            <param name="_length">The length of data in the buffer to use</param>
        </member>
        <member name="P:Morpheus.CMemoryStream.CanRead">
            <summary>
            Can you read from this stream?
            </summary>
        </member>
        <member name="P:Morpheus.CMemoryStream.CanWrite">
            <summary>
            Can you write to this stream?
            </summary>
        </member>
        <member name="P:Morpheus.CMemoryStream.CanSeek">
            <summary>
            Can you Seek within this stream?
            </summary>
        </member>
        <member name="P:Morpheus.CMemoryStream.Length">
            <summary>
            How many bytes are left in this stream
            </summary>
        </member>
        <member name="P:Morpheus.CMemoryStream.BytesAvailable">
            <summary>
            The number of bytes available to read in the stream.
            </summary>
        </member>
        <member name="P:Morpheus.CMemoryStream.Position">
            <summary>
            The number of bytes into the stream that the current position is.
            </summary>
        </member>
        <member name="M:Morpheus.CMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Move the internal pointer to a specified position.
            </summary>
            <param name="_offset">
            The offset from the _origin to move the pointer to
            </param>
            <param name="_origin">
            Describes how to move the pointer based on the offset
            </param>
            <returns>The new pointer value.</returns>
        </member>
        <member name="M:Morpheus.CMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from the stream into a subsection of a byte[]
            </summary>
            <param name="_buffer">The byte[] to read into</param>
            <param name="_offset">
            The position in the byte[] of the first byte to read
            </param>
            <param name="_count">
            The number of bytes to read into the byte[]. Fewer bytes may be read than
            requested.
            </param>
            <returns>The number of bytes actually read into the _buffer.</returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown when _buffer is null.
            </exception>
        </member>
        <member name="M:Morpheus.CMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write data to the underlying byte[]
            </summary>
            <param name="_buffer">The data to write to the byte[]</param>
            <param name="_offset">The offset into the data to write</param>
            <param name="_count">The number of bytes to write into the byte[]</param>
        </member>
        <member name="M:Morpheus.CMemoryStream.Flush">
            <summary>
            Flushing this buffer does nothing.
            </summary>
        </member>
        <member name="M:Morpheus.CMemoryStream.SetLength(System.Int64)">
            <summary>
            Set the stream length. Check to see if the underlying array can handle it.
            </summary>
            <param name="_newLength">The new "length" of the stream</param>
        </member>
        <member name="M:Morpheus.CMemoryStream.GetBytes">
            <summary>
            Copy the contents of the underlying array into a new byte[] specifically sized
            to the Length of this stream.
            </summary>
            <returns>a byte[] copy of the underlying stream data.</returns>
        </member>
        <member name="T:Morpheus.CStreamSplice">
            <summary>
            A StreamSplice is a section of a larger stream. The limitations of this sub-stream are
            enforced by this splice to make sure consumers do not move the "position" out of bounds
            of the splice.
            </summary>
        </member>
        <member name="M:Morpheus.CStreamSplice.#ctor(System.IO.Stream,System.Int64)">
            <summary>
            Construct a "splice" of a Stream that starts at the current Position of the stream
            passed in, and has a specific length.
            </summary>
            <param name="_stream">
            The "base" stream, generally a larger stream that this object breaks into a smaller
            part of.
            </param>
            <param name="_length">The length of this stream-splice.</param>
        </member>
        <member name="P:Morpheus.CStreamSplice.CanRead">
            <summary>
            For a stream-splice, always TRUE
            </summary>
        </member>
        <member name="P:Morpheus.CStreamSplice.CanSeek">
            <summary>
            For a stream-splice, always TRUE
            </summary>
        </member>
        <member name="P:Morpheus.CStreamSplice.CanWrite">
            <summary>
            For a stream-splice, always FALSE
            </summary>
        </member>
        <member name="M:Morpheus.CStreamSplice.Flush">
            <summary>
            This does nothing to a stream-splice
            </summary>
        </member>
        <member name="P:Morpheus.CStreamSplice.Length">
            <summary>
            Gets the total Length of the Stream-splice
            </summary>
        </member>
        <member name="P:Morpheus.CStreamSplice.Position">
            <summary>
            Gets / Sets the Position within the StreamSplice.
            </summary>
        </member>
        <member name="M:Morpheus.CStreamSplice.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the Position of the StreamSplice based on a "SeekOrigin".
            </summary>
            <param name="_offset">The offset for the seek operation</param>
            <param name="_origin">Information about where the offset is to be applied</param>
            <returns>The Postion within the stream after the offset is applied.</returns>
        </member>
        <member name="M:Morpheus.CStreamSplice.SetLength(System.Int64)">
            <summary>
            Unsupported by the StreamSplice
            </summary>
            <param name="_value">The new length of the stream</param>
        </member>
        <member name="M:Morpheus.CStreamSplice.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a section of the StreamSplice and return the number of bytes read
            </summary>
            <param name="_buffer">The buffer to hold the data read from the stream</param>
            <param name="_offset">
            The offset from the beginning of the buffer where to start saving the bytes from the
            stream
            </param>
            <param name="_count">The number of bytes to read from the stream</param>
            <returns>The number of bytes actually read from the stream</returns>
        </member>
        <member name="M:Morpheus.CStreamSplice.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Unsupported by the StreamSplice
            </summary>
            <param name="_buffer"></param>
            <param name="_offset"></param>
            <param name="_count"></param>
        </member>
        <member name="T:Morpheus.CTextWriterPrepender">
             <summary>
             A wrapper class for TextWriters that makes sure every "line" of text, as defined by
             <see cref="F:System.IO.TextWriter.CoreNewLine"/> starts with a specifed string. This allows for
             static strings and strings generated by lambda functions, which are useful for instance
             if you want to timestamp every line of text.
             </summary>
             <remarks>
             This code snippet shows both how to create a timestamp prepender and how to use the
             <see cref="T:Morpheus.CTextWriterSplitter"/> .
             <code>
             var outFile = File.CreateText( @"\t.txt" );
             
             // Prepends the date/time of when the prepender was created to every line (not very useful)
             var timestamper = new CTextWriterPrepender( outFile, DateTime.Now.ToString() + " ---->   " );
             
             // Prepends the current date/time, as the lambda function is called as soon as the first character of the new line is written
             var timestamper = new CTextWriterPrepender( outFile, () => DateTime.Now.ToString() + " ---->   " );
             
             // A bit more sophisticated maybe? Dunno... your call
             var timestamper = new CTextWriterPrepender( outFile )
             {
                 StringToPrepend = " --> ",
                 PrependerFunction = () => DateTime.Now.ToString()
             };
             
             
             // Redirect Console.Out with the prepender
             Console.SetOut( timestamper );
             
             // -or-  with the splitter/prepender combo
             Console.SetOut( new CTextWriterSplitter( Console.Out, timestamper ) );
            </code>
             </remarks>
        </member>
        <member name="P:Morpheus.CTextWriterPrepender.StringToPrepend">
            <summary>
            A static string that is prepended before the first character of every line, but
            AFTER the PrependerFunction's string if its specified.
            </summary>
        </member>
        <member name="P:Morpheus.CTextWriterPrepender.PrependerFunction">
            <summary>
            This function is called before the first character of every line is written. The
            string returned from this function will be placed BEFORE the
            <see cref="P:Morpheus.CTextWriterPrepender.StringToPrepend"/> string.
            </summary>
        </member>
        <member name="M:Morpheus.CTextWriterPrepender.#ctor(System.IO.TextWriter)">
            <summary>
            Construct wrapping an existing TextWriter
            </summary>
            <param name="_writer">The TextWriter to wrap with this prepender</param>
        </member>
        <member name="M:Morpheus.CTextWriterPrepender.#ctor(System.IO.TextWriter,System.String)">
            <summary>
            Construct with a TextWriter and a static string
            </summary>
            <param name="_writer">The TextWriter to wrap with this prepender</param>
            <param name="_stringToPrepend">
            The string to be prepended to every line of text
            </param>
        </member>
        <member name="M:Morpheus.CTextWriterPrepender.#ctor(System.IO.TextWriter,System.Func{System.String})">
            <summary>
            Construct with a lambda function (or delegate) to be called before writing the first
            character of text on every line
            </summary>
            <param name="_writer">The TextWriter to wrap with this prepender</param>
            <param name="_prependerFunction">
            The function that generates the string to prepend
            </param>
        </member>
        <member name="M:Morpheus.CTextWriterPrepender.Finalize">
            <summary>
            Make sure things like Files get flushed and closed. One of those rare instances when
            you need a finalizer.
            </summary>
        </member>
        <member name="P:Morpheus.CTextWriterPrepender.Encoding">
            <summary>
            The encoding of the TextWriter that this object is wrapping
            </summary>
        </member>
        <member name="M:Morpheus.CTextWriterPrepender.Write(System.Char)">
            <summary>
            Write a character of text. Includes the logic to detect "Beginning of Line" and act
            appropriately
            </summary>
            <param name="_char"></param>
        </member>
        <member name="M:Morpheus.CTextWriterPrepender.CheckForEndOfLine(System.Char)">
            <summary>
            Checks to see if a character will be the last character of a line... the last
            character of the <see cref="F:System.IO.TextWriter.CoreNewLine"/> Only checks for up to 2
            newline characters (usually carriage-return line-feed)
            </summary>
            <param name="_char">The character that is going to be written next</param>
        </member>
        <member name="M:Morpheus.CTextWriterPrepender.PrependIfNeeded">
            <summary>
            Checks to see if we need to prepend text and prepend the right text if needed.
            </summary>
        </member>
        <member name="M:Morpheus.CTextWriterPrepender.Dispose(System.Boolean)">
            <summary>
            Make sure that the wrapped object gets disposed too
            </summary>
            <param name="_disposing"></param>
        </member>
        <member name="T:Morpheus.CTextWriterSplitter">
             <summary>
             A simple wrapper class around some number of other textwriters that will make sure all output that goes to one writer will
             go to all writers
             </summary>
             <remarks>
             
             var outFile = File.CreateText( @"\t.txt" );
             
             Console.SetOut( new CTextWriterSplitter( Console.Out, outFile ) );
            
             </remarks>
        </member>
        <member name="F:Morpheus.CTextWriterSplitter.m_writers">
            <summary>
            The <see cref="T:System.IO.TextWriter"/> list that receives all output
            </summary>
        </member>
        <member name="F:Morpheus.CTextWriterSplitter.m_disposed">
            <summary>
            Flag to make sure this is not Disposed multiple times
            </summary>
        </member>
        <member name="M:Morpheus.CTextWriterSplitter.#ctor(System.IO.TextWriter[])">
            <summary>
            A new splitter class to send output to whatever TextWriters are specified in the constructor
            </summary>
            <param name="_writers">Any number of TextWriters, all of which will receive output</param>
        </member>
        <member name="M:Morpheus.CTextWriterSplitter.Finalize">
            <summary>
            Make sure things like Files get flushed and closed. One of those rare instances when you need a finalizer.
            </summary>
        </member>
        <member name="P:Morpheus.CTextWriterSplitter.Encoding">
            <summary>
            Use the first textwriter's encoding unless there are no text writers; then use default but it doesn't really matter
            </summary>
        </member>
        <member name="M:Morpheus.CTextWriterSplitter.Write(System.Char)">
            <summary>
            The only method that must be implemented- all other methods in the bsae implementation use this at the end
            </summary>
            <param name="_char">A character to write</param>
        </member>
        <member name="M:Morpheus.CTextWriterSplitter.DontDispose">
            <summary>
            Call this if you do not want this TextWriter to dispose your other text writers.
            </summary>
        </member>
        <member name="M:Morpheus.CTextWriterSplitter.Dispose(System.Boolean)">
            <summary>
            This is called by the base class's Dispose() method, which implements IDisposable.
            Make sure that all writers attached to this thing get disposed when it gets disposed.
            </summary>
            <param name="_disposing">TRUE- Called by IDisposable.Dispose  FALSE- Called by finalizer.
            See <see cref="M:System.IO.TextWriter.Dispose(System.Boolean)"/></param>
        </member>
        <member name="T:Morpheus.CChromosome">
            <summary>
            A chromosome for use with the <see cref="T:Morpheus.CGeneticAlgorithm"/> class.
            </summary>
        </member>
        <member name="P:Morpheus.CChromosome.WordCount">
            <summary>
            The number of words in this chromosome
            </summary>
        </member>
        <member name="P:Morpheus.CChromosome.BitsPerWord">
            <summary>
            The number of bits per word
            </summary>
        </member>
        <member name="M:Morpheus.CChromosome.MarkDirty">
            <summary>
            Mark this chromosome as dirty, so it will surely call the evaluator the next time
            <see cref="M:Morpheus.CChromosome.GetValue"/> is called.
            </summary>
        </member>
        <member name="F:Morpheus.CChromosome.m_longs">
            <summary>
            The raw data, as 64-bit words which are taken apart.
            </summary>
        </member>
        <member name="F:Morpheus.CChromosome.m_dirty">
            <summary>
            When not dirty, the chromosome will use a cached value.
            </summary>
        </member>
        <member name="F:Morpheus.CChromosome.m_cachedValue">
            <summary>
            The cached value of the chromosome- Works in conjunction with m_dirty
            </summary>
        </member>
        <member name="F:Morpheus.CChromosome.m_mask">
            <summary>
            Calculate the mask once- saves operations in GetWord
            </summary>
        </member>
        <member name="F:Morpheus.CChromosome.m_evaluator">
            <summary>
            The evaluator for the chromosome. Assume that this operation is not fast or trivial,
            thus "dirty" and a cached value.
            </summary>
        </member>
        <member name="M:Morpheus.CChromosome.#ctor(System.Int32,System.Int32,System.Func{Morpheus.CChromosome,System.Double})">
            <summary>
            Construct a raw chromosome, giving it personality.
            </summary>
            <param name="_wordCount">The number of words in the chromosome</param>
            <param name="_bitsPerWord">The number of bits per word</param>
            <param name="_evaluator">
            The (presumably non-trivial) evaluator for the chromosome
            </param>
        </member>
        <member name="M:Morpheus.CChromosome.#ctor(Morpheus.CChromosome)">
            <summary>
            Create using a template chromosome. This is NOT a clone or copy constructor. It does
            copy the personality of the chromosome- the word count, bit length of words, and
            evaluator.
            </summary>
            <param name="_other"></param>
        </member>
        <member name="M:Morpheus.CChromosome.FromOther(Morpheus.CChromosome)">
            <summary>
            This will populate all data in this chromosome from the data in another chromosome.
            This is a Deep Copy- All data is copied into this chromosome. This allows the GA to
            allocate chromosomes once and keep them around, thereby saving on garbage
            collections.
            </summary>
            <param name="_other"></param>
        </member>
        <member name="M:Morpheus.CChromosome.GetValue">
            <summary>
            Get the chromosome's value, based on the evaluator passed in to the constructor.
            Will only call the evaluator if this chromosome is "dirty", meaning that we have
            reason to believe that the chromosome has changed since the last time the evaluator
            was called.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CChromosome.GetWord(System.Int32)">
            <summary>
            Retrieve a word from this chromosome, using WordCount and BitsPerWord
            </summary>
            <param name="_index">The index into this single-dimensional chromosome</param>
            <returns>Up to 64 bits from the chromosome</returns>
        </member>
        <member name="F:Morpheus.CChromosome.m_8bytes">
            <summary>
            object-local cache for 8 bits- prevents re-allocation
            </summary>
        </member>
        <member name="M:Morpheus.CChromosome.GetRandom64bits">
            <summary>
            Get a random 64 bits of data represented by an unsigned long integer
            </summary>
            <returns>An unsigned long random integer</returns>
        </member>
        <member name="M:Morpheus.CChromosome.Randomize">
            <summary>
            Place random bits in all of this chromosome
            </summary>
        </member>
        <member name="M:Morpheus.CChromosome.Mutate(System.Double)">
            <summary>
            Mutate this chromosome by flipping bits. Will always flip at least one bit. The
            Strength parameter represents the probability of flipping subsequent bits.
            </summary>
            <param name="_strength">
            Chance of another bit being flipped each time a bit is flipped- Theoretically could
            create an infinite loop. This method enforces a maximum value of 75% chance of
            subsequent bit flips.
            </param>
        </member>
        <member name="M:Morpheus.CChromosome.CrossoverBits(Morpheus.CChromosome,Morpheus.CChromosome)">
            <summary>
            Crossover by randomly choosing bits from one or the other chromosome.
            </summary>
            <param name="_1">The first chromosome to get bits from</param>
            <param name="_2">The second chromosome to get bits from</param>
        </member>
        <member name="M:Morpheus.CChromosome.CrossoverSplice(Morpheus.CChromosome,Morpheus.CChromosome)">
            <summary>
            Crossover two chromosomes by splicing a random section of one chromosome into the
            other chromosome. This creates contiguous sequences of bits from one or the other
            chromosome.
            </summary>
            <param name="_1">The first chromosome to splice from</param>
            <param name="_2">The second chromosome to splice from</param>
        </member>
        <member name="M:Morpheus.CChromosome.Merge(System.UInt64,System.UInt64)">
            <summary>
            Helper for CrossoverSplice- Takes part of a ulong from one chromosome and splices it
            with the "other" part of the ulong from the other chromosome
            </summary>
            <param name="_1">The first ulong to splice from</param>
            <param name="_2">The second ulong to splice from</param>
            <returns>
            A merged ulong containing the left bits from one ulong and the right bits from the
            other
            </returns>
        </member>
        <member name="M:Morpheus.CChromosome.CompareTo(System.Object)">
            <summary>
            Allow chromosomes to be sorted based on their "Value" (from <see cref="M:Morpheus.CChromosome.GetValue"/> .
            </summary>
            <param name="_obj">Some other object, presumed to be a chromosome</param>
            <returns>
            -1 if this is less than obj, 0 if they're equal, or 1 if this is greater than the
            other chromosome
            </returns>
        </member>
        <member name="M:Morpheus.CChromosome.CompareTo(Morpheus.CChromosome)">
            <summary>
            Allow chromosomes to be sorted based on their "Value" (from <see cref="M:Morpheus.CChromosome.GetValue"/> .
            </summary>
            <param name="_other">Some other object, presumed to be a chromosome</param>
            <returns>
            -1 if this is less than obj, 0 if they're equal, or 1 if this is greater than the
            other chromosome
            </returns>
        </member>
        <member name="M:Morpheus.CChromosome.Equals(System.Object)">
            <summary>
            Compare based on content of the bits
            </summary>
            <param name="_obj">Some other object to compare to this</param>
            <returns>TRUE if the bits are equal, FALSE if not</returns>
        </member>
        <member name="M:Morpheus.CChromosome.GetHashCode">
            <summary>
            HashCode can just be the hash code of the longs array
            </summary>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CChromosome.ToString">
            <summary>
            Turn this chromosome into a string of values.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Morpheus.CChromosome.Words">
            <summary>
            Allow access to the words as an enumeration
            </summary>
        </member>
        <member name="T:Morpheus.CCrc16_CCITT">
            <summary>
            This class encapsulates a CRC-16 algorithm based on the CCITT polynomial.
            </summary>
            <remarks>
            This is a table-based algorithm which was tested as much faster than a purely
            bit-manipulation method.
            
            This algorithm is faster than using <see cref="T:System.Security.Cryptography.MD5CryptoServiceProvider"/> when the
            size of the data is approximately 5k or less. For data sizes greater than 5k-bytes,
            the MD5 calculation becomes faster.
            
            The larger the dataset, the better MD5 performs compared to this algorithm.
            
            Another significant difference is that MD5 produces a 16-byte result, where CCITT-16
            produces a 2-byte result.
            </remarks>
        </member>
        <member name="M:Morpheus.CCrc16_CCITT.CalculateCrc(System.Byte[])">
            <summary>
            Calculate the CCITT-CRC16 over an entire byte array
            </summary>
            <param name="_data">The data to calculate the CRC over</param>
            <returns>The CRC16 for the data in the array</returns>
        </member>
        <member name="M:Morpheus.CCrc16_CCITT.CalculateCrc(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Calculate the CCITT-CRC16 over a subset of a byte array
            </summary>
            <param name="_data">The data to calculate the CRC over</param>
            <param name="_offset">
            The offset into the buffer where to start calculating the CRC
            </param>
            <param name="_length">The number of bytes to include in the CRC</param>
            <returns>The CRC16 for the data in the array</returns>
        </member>
        <member name="M:Morpheus.CCrc16_CCITT.CalculateCrc(System.UInt16)">
            <summary>
            This override will calculate the CCITT-CRC16 for a USHORT.
            </summary>
            <remarks>
            This method is used, for instance, to create the "pair" for a framing operation.
            For instance, the parameter to this method would represent the length of the
            frame and the return value of this method is appended that length and placed at
            the beginning of the frame.
            </remarks>
            <param name="_number">The 2-byte number to take the CRC of</param>
            <returns>The CCITT-CRC of the ushort parameter</returns>
        </member>
        <member name="M:Morpheus.CCrc16_CCITT.CalculateCrc(System.Int32)">
            <summary>
            This override will calculate the CCITT-CRC16 for an Int32.
            </summary>
            <remarks>
            For example, the parameter to this method would represent the length of
            something that, coupled with its CRC, may be a checksum of sorts
            </remarks>
            <param name="_number">
            The 4-byte number to take the CRC of. Sign is irrelevant.
            </param>
            <returns>The CCITT-CRC of number supplied</returns>
        </member>
        <member name="T:Morpheus.CCrypto">
            <summary>
            Class to help with the encryption and decryption of strings. Any strings encrypted with an object of
            this class must be decrypted by the same object.
            </summary>
        </member>
        <member name="F:Morpheus.CCrypto.TOTAL_SALT_LENGTH">
            <summary>
            
            </summary>
        </member>
        <member name="P:Morpheus.CCrypto.Key">
            <summary>
            Retrieve the key as a string
            </summary>
        </member>
        <member name="P:Morpheus.CCrypto.IV">
            <summary>
            Retrieve the initialization vector as a string
            </summary>
        </member>
        <member name="P:Morpheus.CCrypto.SystemSalt">
            <summary>
            Retrieve the system salt as a string
            </summary>
        </member>
        <member name="P:Morpheus.CCrypto.SystemSaltLength">
            <summary>
             The number of bytes in the system salt for this instantiation
            </summary>
        </member>
        <member name="P:Morpheus.CCrypto.MessageSaltLength">
            <summary>
            The number of bytes in the message salt for this instantiation
            </summary>
        </member>
        <member name="M:Morpheus.CCrypto.#ctor">
            <summary>
            Set up this instantiation
            </summary>
        </member>
        <member name="M:Morpheus.CCrypto.#ctor(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Set up the CCrypto with information from a previous CCrypto
            </summary>
            <param name="_key"></param>
            <param name="_iv"></param>
            <param name="_salt"></param>
        </member>
        <member name="M:Morpheus.CCrypto.#ctor(System.String,System.String,System.String)">
            <summary>
            Set up the CCrypto with information from a previous CCrypto
            </summary>
            <param name="_key"></param>
            <param name="_iv"></param>
            <param name="_salt"></param>
        </member>
        <member name="M:Morpheus.CCrypto.Encrypt(System.String)">
            <summary>
            Encrypt a string into a new string
            </summary>
            <param name="_string">The string to encrypt</param>
            <returns>The encrypted string.</returns>
        </member>
        <member name="M:Morpheus.CCrypto.Decrypt(System.String)">
            <summary>
            Decrypt a string that's been previously encrypted. The string must have been created with the <see cref="M:Morpheus.CCrypto.Encrypt(System.String)"/>
            method of this class.
            </summary>
            <param name="_string">The string that had been encrypted with this class</param>
            <returns>The string that was originally encrypted.</returns>
        </member>
        <member name="M:Morpheus.CCrypto.BytesToString(System.Byte[])">
            <summary>
            Turn an array of bytes into a string
            </summary>
            <param name="_data"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CCrypto.StringToBytes(System.String)">
            <summary>
            Turn a string into an array of bytes. The string must have been created from an original byte
            array using the <see cref="M:Morpheus.CCrypto.BytesToString(System.Byte[])"/> method of this class.
            </summary>
            <param name="_string"></param>
            <returns></returns>
        </member>
        <member name="T:Morpheus.CCsvImporter">
            <summary>
            This class is designed to parse a string (stream, file) into its components. It does
            support the return of actual data objects with fields / properties populated from each
            line of the CSV file based on the column names in the CSV.
            
            The application can "alias" column names to alternative field/property names.
            
            The application can send in a (single, presumably large) string, a stream, or a
            filename.
            
            The application can receive an enumeration of populated objects as well as a
            list-of-lists of strings representing the data.
            
            The class uses <see cref="M:System.Convert.ChangeType(System.Object,System.Type)"/> to coerce strings into the
            appropriate data type for the fields/properties of a data object.
            
            This class does not (yet) support fixed-width columns- only data separated by specific
            separators can be parsed.
            
            This class treats quoted data elements correctly by not considering any separator
            characters as special when enclosed in quotes. It does not handle escaped-quotes (yet)
            e.g.
            
            "the quote \" character is escaped"
            
            would parse as
            
            the quote\
            
            The class strips whitespace found on either side of a separator character
            
            The class will ignore any blank lines found. A "blank line" contains either nothing or
            only whitespace. If the separator for data elements is itself a whitespace character,
            then multiple such separators in a line will prevent the "skipping" of the line.
            </summary>
        </member>
        <member name="T:Morpheus.CCsvImporter.DFormatExceptionHandler">
            <summary>
            This delegate can be used to handle exceptions in the input stream
            </summary>
            <param name="_stringToConvert">What was being converted</param>
            <param name="_resultingType">
            The Type that the string was supposed to be converted to
            </param>
            <param name="_memberName">The column name for the conversion</param>
            <returns></returns>
        </member>
        <member name="F:Morpheus.CCsvImporter.ColumnSeparator">
            <summary>
            Those characters which may separate data elements from each other. The application
            may set this value.
            </summary>
        </member>
        <member name="F:Morpheus.CCsvImporter.ColumnNameSpaceReplacement">
            <summary>
            The character to replace any spaces in a column name with. For instance, you may
            specify an underline to replace spaces, making "First Name" result in a
            field/property called "First_Name". Specifying an empty string (default) simply
            removes spaces from column names.
            </summary>
        </member>
        <member name="F:Morpheus.CCsvImporter.RemoveQuotes">
            <summary>
            Flag telling the importer to remove literal quotes from data. When FALSE, any quoted
            data element will be returned
            </summary>
        </member>
        <member name="E:Morpheus.CCsvImporter.OnHeaderRead">
            <summary>
            Called (with a StringBuilder) when the header is read from the CSV
            </summary>
        </member>
        <member name="E:Morpheus.CCsvImporter.OnLineRead">
            <summary>
            Called when a line of text has been read from the CSV. Returns the actual line of
            text, unparsed.
            </summary>
        </member>
        <member name="E:Morpheus.CCsvImporter.OnUnusableColumn">
            <summary>
            Called when a column name will not be used because there is no corresponding field
            in the object.
            
            This has no negative effect if the CSV is not to be coerced into objects.
            </summary>
        </member>
        <member name="F:Morpheus.CCsvImporter.OnFormatError">
            <summary>
            A function that will handle a conversion error by returning what the conversion of
            the string should be, given the expected type and member name. This handler is
            called only after an exception is thrown, so it should only be used sparingly and
            not as a "general purpose data conversion" mechanism.
            </summary>
        </member>
        <member name="F:Morpheus.CCsvImporter.m_columnNames">
            <summary>
            A collection of column names, as they appear in the CSV
            </summary>
        </member>
        <member name="F:Morpheus.CCsvImporter.m_data">
            <summary>
            All of the data found in the CSV, parsed into individual data element strings
            </summary>
        </member>
        <member name="M:Morpheus.CCsvImporter.#ctor">
            <summary>
            The default constructor
            </summary>
        </member>
        <member name="M:Morpheus.CCsvImporter.ParseString(System.Text.StringBuilder,System.String,System.Boolean)">
            <summary>
            Parse a string (in the form of a StringBuilder) into its constituent parts
            </summary>
            <param name="_line">The string to parse</param>
            <param name="_separator">The character(s) to use as separators</param>
            <param name="_removeQuotes">If set, quoted strings have the quotes removed</param>
            <returns>An enumeration of strings defined by _line and _separator</returns>
        </member>
        <member name="M:Morpheus.CCsvImporter.RemoveTrailingWhitespace(System.Text.StringBuilder)">
            <summary>
            Simple routine to remove whitespace from the end of a StringBuilder
            </summary>
            <param name="_string">The string to remove whitespace from</param>
        </member>
        <member name="M:Morpheus.CCsvImporter.TranslateColumnNames(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Translate the column names found in a CSV into new names based on a table of aliases
            </summary>
            <param name="_aliases">The aliases for the column names</param>
            <returns>
            A new list of names based on the column names overlaid with the aliases
            </returns>
        </member>
        <member name="M:Morpheus.CCsvImporter.GetUsableMappings(System.Collections.Generic.IList{System.String},System.Type)">
            <summary>
            Map a list of names to fields or properties of a <see cref="T:System.Type"/> ,
            returning a list of <see cref="T:System.Reflection.MemberInfo"/> objects. A null entry
            in the list means that there was no corresponding field/property in the Type based
            on the column name
            </summary>
            <param name="_columnNames">
            The column names used to look up fields/properties in the Type
            </param>
            <param name="_type">The Type that will receive CSV values</param>
            <returns>
            A list of MemberInfo objects corresponding to the fields/properties in the Type
            </returns>
        </member>
        <member name="M:Morpheus.CCsvImporter.ImportStream(System.IO.TextReader)">
            <summary>
            Import a CSV file based on a <see cref="T:System.IO.StreamReader"/>
            </summary>
            <param name="_stream">The stream to import</param>
        </member>
        <member name="M:Morpheus.CCsvImporter.ProcessHeader(System.Text.StringBuilder)">
            <summary>
            Parse and process the "header" row of a CSV file
            </summary>
            <param name="_header">
            A <see cref="T:System.Text.StringBuilder"/> containing the header row
            </param>
        </member>
        <member name="M:Morpheus.CCsvImporter.ProcessLine(System.Text.StringBuilder)">
            <summary>
            Parse and process a non-header row of a CSV file (a data row)
            </summary>
            <param name="_line">A <see cref="T:System.Text.StringBuilder"/> containing the data row</param>
        </member>
        <member name="M:Morpheus.CCsvImporter.ImportFile(System.String)">
            <summary>
            Import a CSV file from the operating system
            </summary>
            <param name="_filename">The filename of the CSV file</param>
        </member>
        <member name="M:Morpheus.CCsvImporter.ImportString(System.String)">
            <summary>
            Treat a string as a CSV file, and import it
            </summary>
            <param name="_csvFileContents">
            Presumably, the contents of a CSV file pre-read into a string
            </param>
        </member>
        <member name="M:Morpheus.CCsvImporter.GetData``1">
            <summary>
            Create a collection of data objects of a specified Type based on the data imported
            into this CSV importer object
            </summary>
            <remarks>
            Calling this method may invoke the "OnUnusableColumn" event, if it is specified,
            once for each column name that does not have a corresponding field or property
            defined in the specified class "T"
            </remarks>
            <typeparam name="T">The Type of each data element to return</typeparam>
            <returns>
            An enumeration of the contents of the CSV file converted into objects of Type "T"
            </returns>
        </member>
        <member name="M:Morpheus.CCsvImporter.GetData``1(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Create a collection of data objects of a specified Type based on the data imported
            into this CSV importer object
            </summary>
            <remarks>
            Calling this method may invoke the "OnUnusableColumn" event, if it is specified,
            once for each column name that does not have a corresponding field or property
            defined in the specified class "T"
            </remarks>
            <typeparam name="T">The Type of each data element to return</typeparam>
            <param name="_aliases">
            A dictionary (string->string) that tells the converter when to change the name of a
            CSV column because the corresponding member in "T" has a different name
            </param>
            <returns>
            An enumeration of the contents of the CSV file converted into objects of Type "T"
            </returns>
        </member>
        <member name="M:Morpheus.CCsvImporter.HandleConversion(System.String,System.Type,System.String)">
            <summary>
            Handle the conversion of a string to the expected Type within the destination object
            by calling the built-in <see cref="M:System.Convert.ChangeType(System.Object,System.Type)"/> method. If
            this method throws a format exception, then call the handler specified (if it
            exists) or re-throw the exeption
            </summary>
            <param name="_stringValue">The value from the CSV file to convert</param>
            <param name="_convertTo">The System.Type of the value to convert TO</param>
            <param name="_fieldName">
            The name of the field within the CSV file that we're converting
            </param>
            <returns>
            An object of type _convertTo that is representative of the string value
            </returns>
        </member>
        <member name="M:Morpheus.CCsvImporter.GetColumnNames">
            <summary>
            Return the list of column names
            </summary>
            <returns>A list of column names</returns>
        </member>
        <member name="M:Morpheus.CCsvImporter.GetData">
            <summary>
            Return the raw data rows found in the file, as an array of arrays of strings
            </summary>
            <returns></returns>
        </member>
        <member name="T:Morpheus.CFileFinder">
            <summary>
            This class helps an application find a file that is either in the application's current
            running directory OR its somewhere "up" the directory structure of the Current
            Directory.
            </summary>
            <remarks>
            Usually, when a program is "run" from within Visual Studio, it is run from the
            "[appName]/bin/debug" subdirectory. Many times you would like to place a data file in
            the "[appName]" directory and not have to worry about messing around trying to find it.
            This class helps make finding that file a painless process.
            </remarks>
        </member>
        <member name="M:Morpheus.CFileFinder.FindFileUpHierarchy(System.String,System.Boolean)">
            <summary>
            Find a file somewhere in the current directory -OR- in any one of the parent
            directories of the current directory
            </summary>
            <param name="_filename">
            The filename to look for. All directory information is STRIPPED from the filename.
            </param>
            <param name="_useExecutableDirectory">
            Tells the routine to make sure the directory containing this program's executable is
            used to find files.
            </param>
            <returns>
            The full pathname for the file if it is found, or NULL if no file with that name was
            found anywhere in the hierarchy.
            </returns>
        </member>
        <member name="M:Morpheus.CFileFinder.FindFileUpHierarchyRecursive(System.String,System.String)">
            <summary>
            Internal function used to recursively find the file in this hierarchy
            </summary>
            <param name="_directoryName">The current directory that we're looking at</param>
            <param name="_filename">
            The filename of the file, with all directory information stripped already.
            </param>
            <returns>
            NULL if we're looking at the "top" directory already and the file wasn't found
            there, or the full filename including path if the file WAS found in this directory,
            OR the recursive result of calling this function for the directory "above" this
            directory.
            </returns>
        </member>
        <member name="T:Morpheus.CFileHasher">
            <summary>
            This class will calculate the hash value for a given file/stream using either MD5 or whatever
            other <see cref="T:System.Security.Cryptography.HashAlgorithm"/> specified by the application
            </summary>
        </member>
        <member name="F:Morpheus.CFileHasher.m_hashAlgorithm">
            <summary>
            The hash algorithm used by this object instance
            </summary>
        </member>
        <member name="M:Morpheus.CFileHasher.#ctor">
            <summary>
            Default algorithm uses MD5
            </summary>
        </member>
        <member name="M:Morpheus.CFileHasher.#ctor(System.Security.Cryptography.HashAlgorithm)">
            <summary>
            Specify the type of hashing that the app wants to use
            </summary>
            <param name="_hashAlgorithm">The hash algorithm used by this instance</param>
        </member>
        <member name="M:Morpheus.CFileHasher.#ctor(System.String)">
            <summary>
            Create a hash algorithm from a name. See <see cref="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)"/> for
            more information. 
            </summary>
            <param name="_hashAlgorithmName">"MD5", "SHA[1|256|384|512]", etc.</param>
        </member>
        <member name="M:Morpheus.CFileHasher.AssertValidHashAlgorithm">
            <summary>
            Helper function to make sure that the selected hash algorithm supports what it needs to.
            </summary>
        </member>
        <member name="M:Morpheus.CFileHasher.Initialize">
            <summary>
            Start using the hash algorithm
            </summary>
        </member>
        <member name="M:Morpheus.CFileHasher.ProcessBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Transform a block of data into the hash
            </summary>
            <param name="_buffer"></param>
            <param name="_offset"></param>
            <param name="_count"></param>
        </member>
        <member name="M:Morpheus.CFileHasher.Finished">
            <summary>
            Finish off the transformation of the file data
            </summary>
        </member>
        <member name="P:Morpheus.CFileHasher.HashValue">
            <summary>
            The Hash computed by the processor
            </summary>
        </member>
        <member name="P:Morpheus.CFileHasher.HashSize">
            <summary>
            The number of bytes comprizing the hash
            </summary>
        </member>
        <member name="P:Morpheus.CFileHasher.HashString">
            <summary>
            The hash value as a hex string
            </summary>
        </member>
        <member name="T:Morpheus.CFileProcessor">
            <summary>
            This class allows an application to "process" a file concurrently with reading it. It assumes 
            that the application needs to deal with VERY LARGE FILES, otherwise there is no benefit.
            </summary>
        </member>
        <member name="T:Morpheus.CFileProcessor.DFileChunkProcessor">
            <summary>
            Delegate matching <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)"/> for processing bytes read from the file
            </summary>
            <param name="_buffer">The buffer containing the data</param>
            <param name="_offset">The starting point in the buffer where the data resides. When called by CFileProcessor,
            this value is always zero</param>
            <param name="_count">The number of bytes found in _buffer. DO NOT USE _buffer.Length to get the byte count!</param>
        </member>
        <member name="T:Morpheus.CFileProcessor.DExceptionHandler">
            <summary>
            Called by the processor when it sees an exception has been raised during async processing.
            </summary>
            <param name="_exception">The exception that was thrown- this will be called on a threadpool thread most likely</param>
        </member>
        <member name="F:Morpheus.CFileProcessor.DEFAULT_BUFFER_SIZE">
            <summary>
            The default buffer size for this class
            </summary>
        </member>
        <member name="F:Morpheus.CFileProcessor.m_stopped">
            <summary>
            Used for the "synchronous" method to sync up to the end of the file processing
            </summary>
        </member>
        <member name="F:Morpheus.CFileProcessor.m_buffers">
            <summary>
            The buffers used by the object to [0] read data from the file, and [1] process data that has been read
            </summary>
        </member>
        <member name="F:Morpheus.CFileProcessor.m_currentBufferIndex">
            <summary>
            Indicator as to which of the two buffers is being read into and which is being processed
            </summary>
        </member>
        <member name="F:Morpheus.CFileProcessor.m_inputStream">
            <summary>
            The input stream of data for this class to process.
            </summary>
        </member>
        <member name="F:Morpheus.CFileProcessor.m_isProcessing">
            <summary>
            Used to make sure that this object is finished with one processing task before another one starts
            </summary>
        </member>
        <member name="F:Morpheus.CFileProcessor.m_bufferSize">
            <summary>
            The size of the buffer for an object of this class. Each instance gets its own 2 copies of a buffer of this size.
            </summary>
        </member>
        <member name="P:Morpheus.CFileProcessor.InternalBufferSize">
            <summary>
            The size of the buffer for an object of this class. Each instance gets its own 2 copies of a buffer of this size.
            The buffer is allocated when it is needed, not when this value is set.
            </summary>
        </member>
        <member name="P:Morpheus.CFileProcessor.Count">
            <summary>
            The number of bytes that have been read
            </summary>
        </member>
        <member name="P:Morpheus.CFileProcessor.ChunksRead">
            <summary>
            The number of "chunks" (full-or-partial) buffers read (but not necessarily processed)
            </summary>
        </member>
        <member name="P:Morpheus.CFileProcessor.EstimatedChunks">
            <summary>
            Based on the <see cref="P:System.IO.Stream.Length"/> value, the number of chunks that is expected to be
            read from the file
            </summary>
        </member>
        <member name="P:Morpheus.CFileProcessor.AsyncException">
            <summary>
            An exception thrown within the async completion routine of the file processor.
            </summary>
        </member>
        <member name="F:Morpheus.CFileProcessor.m_hasIoException">
            <summary>
            Indicates whether the IO completion caused the exception, or if the app-processor caused it.
            </summary>
        </member>
        <member name="P:Morpheus.CFileProcessor.HasIoException">
            <summary>
            If TRUE, then there WAS an exception and it was caused by the Async IO completion
            </summary>
        </member>
        <member name="P:Morpheus.CFileProcessor.HasProcessingException">
            <summary>
            If TRUE, then there WAS an exception and it was caused by the application's Processing method
            </summary>
        </member>
        <member name="P:Morpheus.CFileProcessor.CurrentBuffer">
            <summary>
            Internal helper to access the "current buffer"- the one that has just been "filled up" with data from a stream read
            </summary>
        </member>
        <member name="P:Morpheus.CFileProcessor.OtherBuffer">
            <summary>
            Internal helper to access the "other buffer"- the one that should be filled with file data asynchronously
            </summary>
        </member>
        <member name="M:Morpheus.CFileProcessor.SwapBuffers">
            <summary>
            Swap the buffers for the next async file completion
            </summary>
        </member>
        <member name="F:Morpheus.CFileProcessor.m_disposeOnFinished">
            <summary>
            Make sure the finisher disposes whatever this references.
            </summary>
        </member>
        <member name="E:Morpheus.CFileProcessor.OnInitialize">
            <summary>
            Called before the first file i/o is started
            </summary>
        </member>
        <member name="E:Morpheus.CFileProcessor.OnFinished">
            <summary>
            Called after the last "chunk" of data has been read AND processed
            </summary>
        </member>
        <member name="E:Morpheus.CFileProcessor.OnProcessBytes">
            <summary>
            Called for each "chunk" of data
            </summary>
        </member>
        <member name="E:Morpheus.CFileProcessor.OnException">
            <summary>
            Called if an exception was caught during async file processing
            </summary>
        </member>
        <member name="M:Morpheus.CFileProcessor.InitializeProcessor">
            <summary>
            Regardless of what method is used to kick off file processing, this method should be one of the first things
            called by the method, BEFORE any event handling.
            </summary>
        </member>
        <member name="M:Morpheus.CFileProcessor.ProcessFile(System.String,System.Boolean)">
            <summary>
            Given the name of a file, process that file
            </summary>
            <param name="_filename">The name of the file to process</param>
            <param name="_waitForCompletion">If TRUE, this routine will wait for all file processing to complete before 
            returning. It will still use Async I/O.</param>
            <returns>the number of bytes found in the stream</returns>
        </member>
        <member name="M:Morpheus.CFileProcessor.ProcessFile(System.IO.Stream,System.Boolean)">
            <summary>
            Given a stream assumed to support asynchronous I/O, process that stream
            </summary>
            <param name="_inputStream">The stream to process</param>
            <param name="_waitForCompletion">If TRUE, this routine will wait for all file processing to complete before 
            returning. It will still use Async I/O.</param>
            <returns>The number of bytes found in the stream</returns>
        </member>
        <member name="M:Morpheus.CFileProcessor.AsyncHandler(System.IAsyncResult)">
            <summary>
            This is the "main" handler, which completes file i/o and handles processing of the bytes.
            </summary>
            <param name="_result">From the Async I/O library</param>
        </member>
        <member name="M:Morpheus.CFileProcessor.HandleProcessing(System.Int32)">
            <summary>
            Call the appropriate processors and handle exceptions properly
            </summary>
            <param name="_bytesRead">The number of bytes to process</param>
        </member>
        <member name="M:Morpheus.CFileProcessor.CompleteIo(System.IAsyncResult)">
            <summary>
            Complete the pending async IO and handle exceptions properly
            </summary>
            <param name="_result">The IAsyncResult identifying the IO request</param>
            <returns>The number of bytes read, or 0 if EOF or an exception was thrown</returns>
        </member>
        <member name="M:Morpheus.CFileProcessor.StartNextIo">
            <summary>
            Begin the next Io operation, and handle exceptions properly
            </summary>
            <returns>TRUE if the IO operation started successfully, or FALSE if a problem was encountered</returns>
        </member>
        <member name="M:Morpheus.CFileProcessor.FinishProcessing">
            <summary>
            Called when the Async handling routine determines that there is no more file to process.
            </summary>
        </member>
        <member name="M:Morpheus.CFileProcessor.Initialize">
            <summary>
            Can be overridden by inherting class to do initialization stuff. Base does nothing.
            </summary>
        </member>
        <member name="M:Morpheus.CFileProcessor.ProcessBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Can be overridden by inherting class to do processing stuff. Base does nothing.
            </summary>
        </member>
        <member name="M:Morpheus.CFileProcessor.Finished">
            <summary>
            Can be overridden by inherting class to do finalization stuff. Base does nothing.
            </summary>
        </member>
        <member name="T:Morpheus.CGeneticAlgorithm">
            <summary>
            A generalized Genetic Algorithm. Uses the <see cref="T:Morpheus.CChromosome"/> class.
            </summary>
        </member>
        <member name="F:Morpheus.CGeneticAlgorithm.SAMPLING_HEURISTIC">
            <summary>
            When the worst chromosome error is more than this TIMES the best chromosome error,
            switch sampling algorithms. This number is a wild guess.
            </summary>
        </member>
        <member name="F:Morpheus.CGeneticAlgorithm.m_fullPool">
            <summary>
            A list containing all "good" chromosomes- these are used in crossover and mutation
            to move into the "New Pool"
            </summary>
        </member>
        <member name="F:Morpheus.CGeneticAlgorithm.m_workingPool">
            <summary>
            A list that contains "blank" chromosomes, that must be created using any of a
            variety of methods. This helps alleviate garbage collection by not allocating new
            chromosomes all the time.
            </summary>
        </member>
        <member name="F:Morpheus.CGeneticAlgorithm.m_workingIndex">
            <summary>
            Reset at the start of every generation, this keeps track of any chromosomes that the
            application has injected into the generation via the <see cref="E:Morpheus.CGeneticAlgorithm.OnGenerationStart"/>
            event.
            </summary>
        </member>
        <member name="F:Morpheus.CGeneticAlgorithm.MutationRate">
            <summary>
            Percentage chance of a mutation occurring
            </summary>
        </member>
        <member name="F:Morpheus.CGeneticAlgorithm.MutationStrength">
            <summary>
            Chance of additional mutated bits per mutation
            </summary>
        </member>
        <member name="F:Morpheus.CGeneticAlgorithm.StopTime">
            <summary>
            Set this to terminate a Run after a certain amount of time
            </summary>
        </member>
        <member name="F:Morpheus.CGeneticAlgorithm.PoolSize">
            <summary>
            The number of chromosomes in the pool. Ignored if set/modified after the GA is run.
            </summary>
        </member>
        <member name="F:Morpheus.CGeneticAlgorithm.ElitismCount">
            <summary>
            How many of the top chromosomes will always make it into the next generation as-is
            </summary>
        </member>
        <member name="F:Morpheus.CGeneticAlgorithm.m_template">
            <summary>
            The template chromosome for the application
            </summary>
        </member>
        <member name="P:Morpheus.CGeneticAlgorithm.Generation">
            <summary>
            The current Generation that the GA is working on
            </summary>
        </member>
        <member name="P:Morpheus.CGeneticAlgorithm.MaxGeneration">
            <summary>
            The maximum number of generations to evolve through. May be set during evolution by
            the Application via <see cref="M:Morpheus.CGeneticAlgorithm.GetWorkingChromosome"/>
            </summary>
        </member>
        <member name="P:Morpheus.CGeneticAlgorithm.GenerationsSinceLastUpdate">
            <summary>
            The number of generations that have been processed since the last time an Update
            callback was performed.
            </summary>
        </member>
        <member name="P:Morpheus.CGeneticAlgorithm.Pool">
            <summary>
            The currently "full" pool of chromosomes that the application may access in order to
            inject new chromosomes (via <see cref="M:Morpheus.CGeneticAlgorithm.GetWorkingChromosome"/> )
            </summary>
        </member>
        <member name="F:Morpheus.CGeneticAlgorithm.UpdateInterval">
            <summary>
            How often should the <see cref="E:Morpheus.CGeneticAlgorithm.OnUpdateStatus"/> event be called, in Milliseconds
            </summary>
        </member>
        <member name="E:Morpheus.CGeneticAlgorithm.OnUpdateStatus">
            <summary>
            Called every so often for the purpose of allowing the application to update any
            status information, such as a status bar or printing current status of the GA. The
            application should not modify any of the GA parameters- This should be done inside
            the OnGenerationStart event handler.
            </summary>
        </member>
        <member name="E:Morpheus.CGeneticAlgorithm.OnGenerationStart">
            <summary>
            Allow the application to interfere at the beginning of each generation
            </summary>
        </member>
        <member name="P:Morpheus.CGeneticAlgorithm.NormalSampleCount">
            <summary>
            Counter to communicate the number of Normal distributions (high difference in errors
            of best and worst chromosomes)
            </summary>
            <remarks>
            If someone wants to use these numbers to tune the SAMPLING_HEURISTIC they can. Right
            now, its constant, but it could be made into an instance variable easily enough.
            </remarks>
        </member>
        <member name="P:Morpheus.CGeneticAlgorithm.LinearSampleCount">
            <summary>
            Counter to communicate the number of Linear distributions (low difference in errors
            of best and worst chromosomes)
            </summary>
            <remarks>
            If someone wants to use these numbers to tune the SAMPLING_HEURISTIC they can. Right
            now, its constant, but it could be made into an instance variable easily enough.
            </remarks>
        </member>
        <member name="M:Morpheus.CGeneticAlgorithm.#ctor(Morpheus.CChromosome)">
            <summary>
            Create a new GA using a specific chromosome as a template.
            </summary>
            <param name="_template">The template chromosome</param>
        </member>
        <member name="M:Morpheus.CGeneticAlgorithm.#ctor(System.Int32,System.Int32,System.Func{Morpheus.CChromosome,System.Double})">
            <summary>
            Construct a new GA using data that describes the template chromosome
            </summary>
            <param name="_wordCount">The number of words in the chromosome</param>
            <param name="_bitsPerWord">The number of bits per word</param>
            <param name="_evaluator">
            The (presumably non-trivial) evaluator for the chromosome
            </param>
        </member>
        <member name="M:Morpheus.CGeneticAlgorithm.GetWorkingChromosome">
            <summary>
            Grab the next uninitialized working chromosome. Return NULL when none are left.
            </summary>
            <returns>
            NULL if there are no more working chromosomes available, or a reference to an
            uninitialized chromosome if one is available.
            </returns>
        </member>
        <member name="M:Morpheus.CGeneticAlgorithm.StopEvolving">
            <summary>
            Called by the application in the <see cref="E:Morpheus.CGeneticAlgorithm.OnGenerationStart"/> handler to
            terminate evolution immediately. This does NOT imply any sort of error- It may be
            called simply because the application believes that one of the chromosomes is "good
            enough" already.
            </summary>
        </member>
        <member name="M:Morpheus.CGeneticAlgorithm.Run(System.Int32)">
            <summary>
            Run the GA for a specific number of generations.
            </summary>
            <param name="_generations">The number of generations to run for</param>
        </member>
        <member name="M:Morpheus.CGeneticAlgorithm.Sample">
            <summary>
            Sample the Pool based on a heuristic choice of methods.
            
            If the best and worst chromosomes are many magnitudes different than each other, the
            linear sampling method in MorpheusUtil will produce abnormally highly skewed values
            towards the best chromosomes due to the linear inverse method of error weighting
            that algorithm uses. In this case, a Gaussian (Normal) curve can be used to give a
            certain sanity to the selection.
            
            When the best and worst are relatively close, however, there is little to
            differentiate the best from the worst. The Gaussian (Normal) approach would not
            recognize that, treating the worst as "much worst" compared to the best when in
            reality they are close. It is here that the linear method found in MorpheusUtil will
            work better.
            </summary>
            <returns>A sampled chromosome</returns>
        </member>
        <member name="T:Morpheus.COpenSimplexNoise">
            <summary>
            A class used to generate noise in 2, 3 or 4 dimensions. 4 dimensions are useful for
            noise fields which are meant to "wrap around"
            </summary>
        </member>
        <member name="M:Morpheus.COpenSimplexNoise.#ctor">
            <summary>
            Construct the object using the current Ticks as the random seed- should generate a
            random noise pattern always.
            </summary>
        </member>
        <member name="M:Morpheus.COpenSimplexNoise.#ctor(System.Int64)">
            <summary>
            Construct the object using a specific RNG seed, thus assuring that all noise
            generated is the same from one program instance to another.
            </summary>
            <param name="_seed"></param>
        </member>
        <member name="M:Morpheus.COpenSimplexNoise.Evaluate(System.Double,System.Double)">
            <summary>
            Return the noise value for two coordinates in 2D space
            </summary>
            <param name="_x"></param>
            <param name="_y"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.COpenSimplexNoise.Evaluate(System.Double,System.Double,System.Double)">
            <summary>
            Return the noise value for three coordinates in 3D space
            </summary>
            <param name="_x"></param>
            <param name="_y"></param>
            <param name="_z"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.COpenSimplexNoise.Evaluate(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Return the noise value for four coordinates in 4D space
            </summary>
            <param name="_x"></param>
            <param name="_y"></param>
            <param name="_z"></param>
            <param name="_w"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.COpenSimplexNoise.EvaluateSeamless(System.Double,System.Double,System.Double)">
            <summary>
            Using 4D noise, return a noise value corresponding to a 2D square that is meant to
            "wrap around", providing seamless noise from the left edge to the right, top edge to
            the bottom.
            </summary>
            <param name="_x"></param>
            <param name="_y"></param>
            <param name="_density">
            The higher the density, the more diverse the noise will be. A low density will
            provide fewer peaks and valleys.
            </param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.COpenSimplexNoise.EvaluateSeamless(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Using 4D noise, return a noise value corresponding to a 2D square that is meant to
            "wrap around", providing seamless noise from the left edge to the right, top edge to
            the bottom.
            </summary>
            <param name="_x"></param>
            <param name="_y"></param>
            <param name="_offsetX">
            Offsets can be used to share the same noise engine (this object) amongst various
            noice images.
            </param>
            <param name="_offsetY">
            Offsets can be used to share the same noise engine (this object) amongst various
            noice images.
            </param>
            <param name="_width">
            Greater Width and Height will result in greater diversity in the resulting noise.
            </param>
            <param name="_height">
            Greater Width and Height will result in greater diversity in the resulting noise.
            </param>
            <returns></returns>
        </member>
        <member name="T:Morpheus.DPerlinNoise">
            <summary>
            The delegate that is used to reliably generate a pseudo-random value for a given
            point in 2d space given a particular seed
            </summary>
            <param name="_x">The X coord</param>
            <param name="_y">The Y coord</param>
            <param name="_noiseSeed">The Seed to use for PRNG generation</param>
            <returns>
            A floating point pseudo random number which will always be identical for the same
            three parameter X, Y, and Seed
            </returns>
        </member>
        <member name="T:Morpheus.DInterpolation">
            <summary>
            The delegate for a function to interpolate between two values
            </summary>
            <param name="_1">One of the values to interpolate between</param>
            <param name="_2">One of the values to interpolate between</param>
            <param name="_fraction">
            How far between the two values the function should generate a value for
            </param>
            <returns>
            A value "between" _1 and _2. "Between" doesn't necessarily mean greater than one
            and less than the other.
            </returns>
        </member>
        <member name="T:Morpheus.CPerlinNoise2d">
            <summary>
            Create Perlin Noise for a 2d field.
            </summary>
        </member>
        <member name="F:Morpheus.CPerlinNoise2d.Persistence">
            <summary>
            For each Octave, determines how much of that Octave's noise is present in the
            final noise value
            </summary>
        </member>
        <member name="F:Morpheus.CPerlinNoise2d.Octaves">
            <summary>
            The number of times noise is generated for a given point. Successive generations
            of noise count less towards the overall noise.
            </summary>
        </member>
        <member name="F:Morpheus.CPerlinNoise2d.PerlinNoiseFunction">
            <summary>
            How to generate noise
            </summary>
        </member>
        <member name="F:Morpheus.CPerlinNoise2d.InterpolationFunction">
            <summary>
            How to interpolate between two points
            </summary>
        </member>
        <member name="F:Morpheus.CPerlinNoise2d.NoiseSeed">
            <summary>
            The Seed to use for the Noise
            </summary>
        </member>
        <member name="F:Morpheus.CPerlinNoise2d.Width">
            <summary>
            Width and Height are used to create tiled noise patterns.
            </summary>
        </member>
        <member name="F:Morpheus.CPerlinNoise2d.Height">
            <summary>
            Width and Height are used to create tiled noise patterns.
            </summary>
        </member>
        <member name="M:Morpheus.CPerlinNoise2d.#ctor">
            <summary>
            Construct with default parameters
            </summary>
        </member>
        <member name="M:Morpheus.CPerlinNoise2d.#ctor(System.Double,System.Int32)">
            <summary>
            Construct with a Persistence and Octaves value
            </summary>
            <param name="_persistence">The Persistence to use</param>
            <param name="_octaves">The Octaves to use</param>
        </member>
        <member name="M:Morpheus.CPerlinNoise2d.Init">
            <summary>
            Initialize to default values
            </summary>
        </member>
        <member name="M:Morpheus.CPerlinNoise2d.Noise(System.Int32,System.Int32,System.Int32)">
            <summary>
            The Default function for noice generation. Uses the Knuth RNG algorithm.
            </summary>
            <param name="_x">The X coord</param>
            <param name="_y">The Y coord</param>
            <param name="_noiseSeed">The Seed to use for PRNG generation</param>
            <returns>
            A floating point pseudo random number which will always be identical for the
            same three parameter X, Y, and Seed
            </returns>
        </member>
        <member name="M:Morpheus.CPerlinNoise2d.CosineInterpolation(System.Double,System.Double,System.Double)">
            <summary>
            The default interpolation between two values. Uses Cosine interpolation.
            </summary>
            <param name="_1">One of the values to interpolate between</param>
            <param name="_2">One of the values to interpolate between</param>
            <param name="_fraction">
            How far between the two values the function should generate a value for
            </param>
            <returns>
            A value "between" _1 and _2. "Between" doesn't necessarily mean greater than
            one and less than the other, but in this case is is.
            </returns>
        </member>
        <member name="M:Morpheus.CPerlinNoise2d.SmoothedNoise(System.Int32,System.Int32)">
            <summary>
            Generate a "smoothed" noise value for integer coordinates (x,y).
            </summary>
            <remarks>
            Smoothed means that the center noise function value counts the most, the N,E,S,W
            coords count half as much, and the corners (NW, NE, SW, SE) count one quarter as
            much
            </remarks>
            <param name="_x">One coord to get noise from</param>
            <param name="_y">One coord to get noise from</param>
            <returns>Smoothed noise at the coordinate</returns>
        </member>
        <member name="M:Morpheus.CPerlinNoise2d.InterpolatedNoise(System.Double,System.Double)">
            <summary>
            Given smoothed noise at the four integer-aligned points surrounding a
            floating-point coordinate, interpolate what the noise would look like somewhere
            within the "square" with corners set on integer coordinate boundaries
            surrounding the (x,y) parameter values.
            </summary>
            <param name="_x">One coord to get noise from</param>
            <param name="_y">One coord to get noise from</param>
            <returns>
            Noise at the coordinate interpolated from smoothed noise calculated at four
            points surrounding the coordinate
            </returns>
        </member>
        <member name="M:Morpheus.CPerlinNoise2d.PerlinNoise(System.Double,System.Double)">
            <summary>
            Calculate the perlin noise at a given point based on the Octaves and Persistence
            values established.
            </summary>
            <param name="_x">One coord to get noise from</param>
            <param name="_y">One coord to get noise from</param>
            <returns>The Perlin Noise at a floating-point coordinate</returns>
        </member>
        <member name="T:Morpheus.CRandom">
            <summary>
            Extension to <see cref="T:System.Random"/> for generating random numbers
            </summary>
        </member>
        <member name="P:Morpheus.CRandom.RNG">
            <summary>
            A single instance of the RNG for better random numbers
            </summary>
        </member>
        <member name="M:Morpheus.CRandom.#ctor">
            <summary>
            Unlike the default implementation, this will virtually prevent multiple
            successive instantiations from returning the same string of random numbers
            </summary>
            <remarks>
            The following program snippet can be used to verify this operation. for (int i =
            0; i &lt; 20; i++) { Random rng = new CRandom(); // using "Random" instead of
            "CRandom" should produce a set of 20 identical numbers Console.WriteLine(
            rng.Next() ); }
            </remarks>
        </member>
        <member name="M:Morpheus.CRandom.#ctor(System.Int32)">
            <summary>
            Initialize the RNG with a pre-set seed.
            </summary>
            <param name="_seed">The seed to initialize the RNG with</param>
        </member>
        <member name="P:Morpheus.CRandom.BetterTickCount">
            <summary>
            Helper to add a "counter" to the default implementation's use of
            <see cref="P:System.Environment.TickCount"/>
            </summary>
            <remarks>
            Uses the reverse-byte-order of the singly-incrementing instantiation count to
            make sure that the upper-order bits get effected by the incrementing counter
            while the lower order bits get effected by the timer.
            
            Uses XOR to make sure that we don't destroy data from either value
            (instantiation count OR tick count)
            </remarks>
        </member>
        <member name="M:Morpheus.CRandom.NextGaussian(System.Double,System.Double)">
            <summary>
            Generate a random number with a Gaussian distribution centered on a MEAN with a
            given STANDARD DEVIATION
            </summary>
            <param name="_mean">The MEAN to center the random number on</param>
            <param name="_standardDeviation">
            The STANDARD DEVIATION of the normal distribution
            </param>
            <returns>
            A random number with a Gaussian distribution centered on a MEAN with a given
            STANDARD DEVIATION
            </returns>
        </member>
        <member name="M:Morpheus.CRandom.NextGaussian(System.Single,System.Single)">
            <summary>
            Generate a random number with a Gaussian distribution centered on a MEAN with a
            given STANDARD DEVIATION
            </summary>
            <param name="_mean">The MEAN to center the random number on</param>
            <param name="_standardDeviation">
            The STANDARD DEVIATION fo the normal distribution
            </param>
            <returns>
            A random number with a Gaussian distribution centered on a MEAN with a given
            STANDARD DEVIATION
            </returns>
        </member>
        <member name="M:Morpheus.CRandom.RollDice(System.Int32,System.Int32)">
            <summary>
            Simulate the rolling of a number of dice, where each die has the same number of
            sides.
            </summary>
            <param name="_numberOfDice">The number of dice to roll.</param>
            <param name="_sidesPerDie">The number of sides on each die rolled.</param>
            <returns>The sum of the results of all of the dice</returns>
        </member>
        <member name="M:Morpheus.CRandom.NextDouble(System.Double,System.Double)">
            <summary>
            Return a random floating point number between two specified numbers
            </summary>
            <param name="_first">one end of the range of numbers</param>
            <param name="_second">The other end of the range of numbers</param>
            <returns>A floating point number between the two parameters.</returns>
        </member>
        <member name="T:Morpheus.CRandomBase">
            <summary>
            
            </summary>
        </member>
        <member name="F:Morpheus.CRandomBase.sm_instantiationCount">
            <summary>
            Incremented by one for each call to <see cref="P:Morpheus.CRandomBase.BetterTickCount"/>
            </summary>
        </member>
        <member name="P:Morpheus.CRandomBase.BetterTickCount">
            <summary>
            Helper to add a "counter" to the default implementation's use of
            <see cref="P:System.Environment.TickCount"/>
            </summary>
            <remarks>
            Uses the reverse-byte-order of the singly-incrementing instantiation count to
            make sure that the upper-order bits get effected by the incrementing counter
            while the lower order bits get effected by the timer.
            
            Uses XOR to make sure that we don't destroy data from either value
            (instantiation count OR tick count)
            </remarks>
        </member>
        <member name="F:Morpheus.CRandomBase.m_gaussianHasLeftover">
            <summary>
            TRUE when m_gaussianLeftover has a value assigned to it, meaning that we can
            return that value instead of calculating a whole new pair
            </summary>
        </member>
        <member name="F:Morpheus.CRandomBase.m_gaussianLeftover">
            <summary>
            The leftover value from the Gaussian calculation. This class's implementation
            generates a pair of values from the algorithm. Throwing one of the pair away is
            wasteful.
            </summary>
        </member>
        <member name="M:Morpheus.CRandomBase.NextGaussian">
            <summary>
            Returns a random floating-point (double) value that represents a Normal
            distribution around zero with a standard deviation of one.
            </summary>
            <remarks>
            Roughly 68.269% of values will be between -1 and 1
            
            Roughly 95.450% of values will be between -2 and 2
            
            Roughly 99.730% of values will be between -3 and 3
            
            Roughly 99.994% of values will be between -4 and 4
            </remarks>
            <returns>
            A random floating-point (double) value that represents a Normal distribution
            around zero.
            </returns>
        </member>
        <member name="M:Morpheus.CRandomBase.NextGaussian(System.Double,System.Double)">
            <summary>
            Returns a random floating-point (double) value that represents a Normal
            distribution around a specific mean with a specified value for standard
            deviation.
            </summary>
            <remarks>
            Roughly 68.269% of values will be +/- ONE _standardDeviation of _mean
            
            Roughly 95.450% of values will be +/- TWO _standardDeviations of _mean
            
            Roughly 99.730% of values will be +/- THREE _standardDeviations of _mean
            
            Roughly 99.994% of values will be +/- FOUR _standardDeviations of _mean
            </remarks>
            <param name="_mean">The mean value for the normal distribution</param>
            <param name="_standardDeviation">
            The standard deviation governing the shape of the normal distribution curve
            </param>
            <returns>
            A random floating-point (double) value that represents a Normal distribution
            around _mean with a standard deviation of _standardDeviation
            </returns>
        </member>
        <member name="M:Morpheus.CRandomBase.Next(System.Int32)">
            <summary>
            Returns a non-negative random integer that is less than the specified maximum.
            </summary>
            <remarks>
            Unlike the default implementation of Next, this implementation does NOT rely on
            floating point math. All calculations are done using integers.
            </remarks>
            <param name="_upperBound">
            The exclusive upper bound of the random number to be generated. maxValue must be
            greater than or equal to 0.
            </param>
            <returns>
            A 32-bit signed integer that is greater than or equal to 0, and less than
            maxValue; that is, the range of return values ordinarily includes 0 but not
            maxValue. However, if maxValue equals 0, maxValue is returned.
            </returns>
        </member>
        <member name="M:Morpheus.CRandomBase.Next(System.Int32,System.Int32)">
            <summary>
            Returns a random integer that is within a specified range.
            </summary>
            <param name="_minValue">
            The inclusive lower bound of the random number returned.
            </param>
            <param name="_maxValue">
            The exclusive upper bound of the random number returned. _maxValue must be
            greater than or equal to _minValue.
            </param>
            <returns>
            A 32-bit signed integer greater than or equal to minValue and less than
            maxValue; that is, the range of return values includes minValue but not
            maxValue. If minValue equals maxValue, minValue is returned.
            </returns>
        </member>
        <member name="M:Morpheus.CRandomBase.Next">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CRandomBase.NextBytes(System.Byte[])">
            <summary>
            
            </summary>
            <param name="_buffer"></param>
        </member>
        <member name="M:Morpheus.CRandomBase.NextDouble">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CRandomBase.NextDouble(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="_minValue"></param>
            <param name="_maxValue"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CRandomBase.Dispose">
            <summary>
            By default, do nothing on Dispose(). Let a subclass deal with this differently
            if needed.
            </summary>
        </member>
        <member name="T:Morpheus.CRandomThreadsafe">
            <summary>
            Simple class to provide one-shot access to an RNG. This class is thread-safe.
            </summary>
        </member>
        <member name="M:Morpheus.CRandomThreadsafe.Next">
            <summary>
            Returns a nonnegative random number.
            </summary>
            <returns>
            A 32-bit signed integer greater than or equal to zero and less than
            System.Int32.MaxValue.
            </returns>
        </member>
        <member name="M:Morpheus.CRandomThreadsafe.Next(System.Int32)">
            <summary>
            Returns a nonnegative random number less than the specified maximum.
            </summary>
            <param name="_maxValue">
            The exclusive upper bound of the random number to be generated. maxValue must be
            greater than or equal to zero.
            </param>
            <returns>
            A 32-bit signed integer greater than or equal to zero, and less than maxValue; that
            is, the range of return values ordinarily includes zero but not maxValue. However,
            if maxValue equals zero, maxValue is returned.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            maxValue is less than zero.
            </exception>
        </member>
        <member name="M:Morpheus.CRandomThreadsafe.Next(System.Int32,System.Int32)">
            <summary>
            Returns a random number within a specified range.
            </summary>
            <param name="_minValue">
            The inclusive lower bound of the random number returned.
            </param>
            <param name="_maxValue">
            The exclusive upper bound of the random number returned. maxValue must be greater
            than or equal to minValue.
            </param>
            <returns>
            A 32-bit signed integer greater than or equal to minValue and less than maxValue;
            that is, the range of return values includes minValue but not maxValue. If minValue
            equals maxValue, minValue is returned.
            </returns>
        </member>
        <member name="M:Morpheus.CRandomThreadsafe.NextBytes(System.Byte[])">
            <summary>
            Fills the elements of a specified array of bytes with random numbers.
            </summary>
            <param name="_buffer">An array of bytes to contain random numbers.</param>
        </member>
        <member name="M:Morpheus.CRandomThreadsafe.NextDouble">
            <summary>
            Returns a random number in [0.0 , 1.0)
            </summary>
            <returns>
            A double-precision floating point number greater than or equal to 0.0, and less than
            1.0
            </returns>
        </member>
        <member name="M:Morpheus.CRandomThreadsafe.NextGaussian(System.Double,System.Double)">
            <summary>
            Generate a random number with a Gaussian distribution centered on a MEAN with a
            given STANDARD DEVIATION
            </summary>
            <param name="_mean">The MEAN to center the random number on</param>
            <param name="_standardDeviation">
            The STANDARD DEVIATION fo the normal distribution
            </param>
            <returns>
            A random number with a Gaussian distribution centered on a MEAN with a given
            STANDARD DEVIATION
            </returns>
        </member>
        <member name="M:Morpheus.CRandomThreadsafe.RollDice(System.Int32,System.Int32)">
            <summary>
            Simulate the rolling of a number of dice, where each die has the same number of
            sides.
            </summary>
            <param name="_numberOfDice">The number of dice to roll.</param>
            <param name="_sidesPerDie">The number of sides on each die rolled.</param>
            <returns>The sum of the results of all of the dice</returns>
        </member>
        <member name="T:Morpheus.CVolumeLabelDeviceLetter">
            <summary>
            helper class to translate a filename between using volume labels and device letters
            preceding the ":"
            </summary>
            <remarks>
            By way of example, if your "C" drive had the label "System", and your "D" drive has the
            label "Data"...
            
            <code>
            static void Main( string[] args )
            {
                Console.WriteLine( CVolumeLabelDeviceLetter.ToVolumeLabel( "d:" ) );
                Console.WriteLine( CVolumeLabelDeviceLetter.ToDeviceLetter( "System:" ) );
            }
            </code>
            
            would create the following output:
            
            <code>
            
            Data:
            C:
            
            </code>
            
            NOTE- The colons are required!
            </remarks>
        </member>
        <member name="M:Morpheus.CVolumeLabelDeviceLetter.ToDeviceLetter(System.String)">
            <summary>
            Translate a full path name that includes a volume label into a "proper"
            path/filename where the volume label has been replaced with the drive letter of the
            volume. ASSUME that any single letter device name is a drive letter.
            </summary>
            <param name="_filename">
            The filename (or directory name) that contains a volume label instead of a drive
            letter
            </param>
            <returns>
            A full file/path with a drive letter substituted for a volume label, if one exists
            </returns>
        </member>
        <member name="M:Morpheus.CVolumeLabelDeviceLetter.ToVolumeLabel(System.String)">
            <summary>
            Given a filename or directory name, check to see if there's a drive letter in it,
            and if there is, then replace that drive letter with the volume label for the drive
            (if it exists).
            </summary>
            <param name="_filename">The filename to translate</param>
            <returns>
            The filename with a valid device letter corresponding to a device with a volume
            label replaced with that volume label.
            </returns>
        </member>
        <member name="M:Morpheus.CVolumeLabelDeviceLetter.GetSortedDrives">
            <summary>
            Helper routine to build a list of reverse-sorted drives. Reverse-sorting places the
            "A" drive at the end, and since this is mostly "not ready" and causes a program to
            pause, we don't want to put it at the beginning of the list so its queried each and
            every time.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Morpheus.CWorkThread">
            <summary>
            A class that handles "Work" that is generated at one time and executed at another time.
            Does not differentiate what kind of work is performed. Provides support for pausing,
            shutting down, polling.
            </summary>
        </member>
        <member name="P:Morpheus.CWorkThread.PollRateMs">
            <summary>
            Poll rate for "no work" state
            </summary>
        </member>
        <member name="P:Morpheus.CWorkThread.IsRunning">
            <summary>
            When TRUE, a thread is running. When FALSE, there's no thread running.
            </summary>
        </member>
        <member name="P:Morpheus.CWorkThread.IsPaused">
            <summary>
            Indicates that the thread is paused- It will not call back to any overridden
            functions.
            </summary>
        </member>
        <member name="P:Morpheus.CWorkThread.WakeEvent">
            <summary>
            When signalled, this event will wake up from the polling wait.
            </summary>
        </member>
        <member name="P:Morpheus.CWorkThread.ShutdownEvent">
            <summary>
            Allow application to set this- When the event is Signalled, the application is
            expecting to shut down and so should this thread (if its still running).
            </summary>
        </member>
        <member name="E:Morpheus.CWorkThread.OnWork">
            <summary>
            Called every poll loop when the WorkThread is Awake. If the application would like a
            repeated call to OnWork until there's no work left, it should call the Wake() method
            on this class before returning. <see cref="M:Morpheus.CWorkThread.Wake"/>
            </summary>
        </member>
        <member name="E:Morpheus.CWorkThread.OnPollTimeout">
            <summary>
            Called every time the polling timeout elapses. This allows the application to do
            stuff "every so often".
            </summary>
        </member>
        <member name="E:Morpheus.CWorkThread.OnPrint">
            <summary>
            Allows the application to do something with all messages that are printed.
            </summary>
        </member>
        <member name="M:Morpheus.CWorkThread.StartThread(System.String)">
            <summary>
            Start the thread and return the Thread object.
            </summary>
            <param name="_threadName">The name of the thread. Used for logging mainly.</param>
            <returns>The Thread object controlling this work thread</returns>
        </member>
        <member name="M:Morpheus.CWorkThread.Stop">
            <summary>
            Stop the work loop.
            </summary>
        </member>
        <member name="M:Morpheus.CWorkThread.Pause">
            <summary>
            Do not perform any callbacks within the work loop. Will still monitor Shutdown and
            Stop commands.
            </summary>
        </member>
        <member name="M:Morpheus.CWorkThread.Resume">
            <summary>
            Turn application-callbacks back on.
            </summary>
        </member>
        <member name="M:Morpheus.CWorkThread.Wake">
            <summary>
            Cause the work loop to immediately call the application-defined callback for Work.
            </summary>
        </member>
        <member name="M:Morpheus.CWorkThread.Run">
            <summary>
            The main thread routine. Handles the looping, pausing, and termination of the
            thread.
            </summary>
        </member>
        <member name="M:Morpheus.CWorkThread.PollTimeout">
            <summary>
            Called by the thread loop when the poll timed out
            </summary>
        </member>
        <member name="M:Morpheus.CWorkThread.DoWorkUnit">
            <summary>
            Called by the thread when its time to do application work.
            </summary>
        </member>
        <member name="M:Morpheus.CWorkThread.Print(System.String,System.Object[])">
            <summary>
            Generate a logging string. Allows the application to hook this so it can log it any
            way it likes.
            </summary>
            <param name="_format"></param>
            <param name="_params"></param>
            <returns></returns>
        </member>
        <member name="M:Morpheus.CWorkThread.PrintError(System.String,System.Object[])">
            <summary>
            Generate a logging string. Allows the application to hook this so it can log it any
            way it likes.
            </summary>
            <param name="_format"></param>
            <param name="_params"></param>
            <returns></returns>
        </member>
        <member name="T:Morpheus.IRandom">
            <summary>
            An interface for Random Number Generation. Provides a number of helper methods that
            add functionality that may not be considered "core".
            </summary>
        </member>
        <member name="M:Morpheus.IRandom.Next">
            <summary>
            Returns a non-negative random integer.
            </summary>
            <returns>
            A 32-bit signed integer that is greater than or equal to 0 and less than
            <see cref="F:System.Int32.MaxValue"/> .
            </returns>
        </member>
        <member name="M:Morpheus.IRandom.Next(System.Int32)">
            <summary>
            Returns a non-negative random integer that is less than the specified maximum.
            </summary>
            <param name="_upperBound">
            The exclusive upper bound of the random number to be generated. maxValue must be
            greater than or equal to 0.
            </param>
            <returns>
            A 32-bit signed integer that is greater than or equal to 0, and less than
            maxValue; that is, the range of return values ordinarily includes 0 but not
            maxValue. However, if maxValue equals 0, maxValue is returned.
            </returns>
        </member>
        <member name="M:Morpheus.IRandom.Next(System.Int32,System.Int32)">
            <summary>
            Returns a random integer that is within a specified range.
            </summary>
            <param name="_minValue">
            The inclusive lower bound of the random number returned.
            </param>
            <param name="_maxValue">
            The exclusive upper bound of the random number returned. _maxValue must be
            greater than or equal to _minValue.
            </param>
            <returns>
            A 32-bit signed integer greater than or equal to minValue and less than
            maxValue; that is, the range of return values includes minValue but not
            maxValue. If minValue equals maxValue, minValue is returned.
            </returns>
        </member>
        <member name="M:Morpheus.IRandom.NextBytes(System.Byte[])">
            <summary>
            Fills the elements of a specified array of bytes with random numbers.
            </summary>
            <param name="_buffer">An array of bytes to contain random numbers.</param>
        </member>
        <member name="M:Morpheus.IRandom.NextDouble">
            <summary>
            Returns a random floating-point number that is greater than or equal to 0.0, and
            less than 1.0.
            </summary>
            <returns>
            A double-precision floating point number that is greater than or equal to 0.0,
            and less than 1.0.
            </returns>
        </member>
        <member name="M:Morpheus.IRandom.NextDouble(System.Double,System.Double)">
            <summary>
            Returns a floating point number that is greater or equal to _minValue and less
            than _maxValue
            </summary>
            <param name="_minValue">The lower inclusive bound for the return value</param>
            <param name="_maxValue">The upper exclusive bound for the return value</param>
            <returns>
            A floating point number that is greater or equal to _minValue and less than
            _maxValue
            </returns>
        </member>
        <member name="M:Morpheus.IRandom.NextGaussian">
            <summary>
            Returns a random floating-point (double) value that represents a Normal
            distribution around zero with a standard deviation of one.
            </summary>
            <remarks>
            Roughly 68.269% of values will be between -1 and 1
            
            Roughly 95.450% of values will be between -2 and 2
            
            Roughly 99.730% of values will be between -3 and 3
            
            Roughly 99.994% of values will be between -4 and 4
            </remarks>
            <returns>
            A random floating-point (double) value that represents a Normal distribution
            around zero.
            </returns>
        </member>
        <member name="M:Morpheus.IRandom.NextGaussian(System.Double,System.Double)">
            <summary>
            Returns a random floating-point (double) value that represents a Normal
            distribution around a specific mean with a specified value for standard
            deviation.
            </summary>
            <remarks>
            Roughly 68.269% of values will be +/- ONE _standardDeviation of _mean
            
            Roughly 95.450% of values will be +/- TWO _standardDeviations of _mean
            
            Roughly 99.730% of values will be +/- THREE _standardDeviations of _mean
            
            Roughly 99.994% of values will be +/- FOUR _standardDeviations of _mean
            </remarks>
            <param name="_mean">The mean value for the normal distribution</param>
            <param name="_standardDeviation">
            The standard deviation governing the shape of the normal distribution curve
            </param>
            <returns>
            A random floating-point (double) value that represents a Normal distribution
            around _mean with a standard deviation of _standardDeviation
            </returns>
        </member>
        <member name="T:Morpheus.IRngBaseProvider">
            <summary>
            Implement a base provider of raw random numbers. Each implementation of this
            interface should natively generate random numbers in at least one of three ways.
            Then, based on the native representation, be able to accurately translate the random
            numbers to the other two representations.
            
            We assume that the rng provider will generate randomness as one of (a) a stream of
            bytes; (b) a 32-bit integer; and/or (c) a floating point value in the range [0..1)
            </summary>
        </member>
        <member name="M:Morpheus.IRngBaseProvider.GetInt">
            <summary>
            Get a random positive integer
            </summary>
            <remarks>
            NOTE: This is a departure from the new broken System.Random which will no longer
            return int.MaxValue
            </remarks>
            <returns>A random positive integer in the range [0..MaxValue]</returns>
        </member>
        <member name="M:Morpheus.IRngBaseProvider.GetBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Fill (part of) an array with random bytes
            </summary>
            <param name="_array">The array to receive the bytes</param>
            <param name="_startingIndex">
            The first index within the array to fill with bytes
            </param>
            <param name="_count">
            The number of bytes to place into the array, starting at _startingIndex
            </param>
        </member>
        <member name="T:Morpheus.XException">
            <summary>
            A base override of Exception that works with Morpheus Code Snippets and distinguishes Morpheus exceptions from .NET exceptions.
            </summary>
        </member>
        <member name="M:Morpheus.XException.#ctor(System.String)">
            <summary>
            Just contains a simple string as a message
            </summary>
            <param name="_message">The message. May be null.</param>
        </member>
        <member name="M:Morpheus.XException.#ctor(System.String,System.Exception)">
            <summary>
            Construct with a simple message and an "inner exception"
            </summary>
            <param name="_message">The simple messsage</param>
            <param name="_baseException">The inner exception</param>
        </member>
        <member name="M:Morpheus.XException.#ctor(System.String,System.Object[])">
            <summary>
            A string.format style exception with no inner exception
            </summary>
            <param name="_format">The format for "string.Format"</param>
            <param name="_params">The parameters for "string.Format"</param>
        </member>
        <member name="M:Morpheus.XException.#ctor(System.Exception,System.String,System.Object[])">
            <summary>
            A string.format style exception with an inner exception
            </summary>
            <param name="_innerException">The inner exception</param>
            <param name="_format">The format for "string.Format"</param>
            <param name="_params">The parameters for "string.Format"</param>
        </member>
    </members>
</doc>

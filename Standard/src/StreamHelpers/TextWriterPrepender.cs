namespace Morpheus;


/// <summary>
/// A wrapper class for TextWriters that makes sure every "line" of text, as defined by
/// <see cref="TextWriter.CoreNewLine"/> starts with a specifed string. This allows for
/// static strings and strings generated by lambda functions, which are useful for instance
/// if you want to timestamp every line of text.
/// </summary>
/// <remarks>
/// This code snippet shows both how to create a timestamp prepender and how to use the
/// <see cref="TextWriterSplitter"/> .
/// <code>
/// var outFile = File.CreateText( @"\t.txt" );
/// 
/// // Prepends the date/time of when the prepender was created to every line (not very useful)
/// var timestamper = new CTextWriterPrepender( outFile, DateTime.Now.ToString() + " ---->   " );
/// 
/// // Prepends the current date/time, as the lambda function is called as soon as the first character of the new line is written
/// var timestamper = new CTextWriterPrepender( outFile, () => DateTime.Now.ToString() + " ---->   " );
/// 
/// // A bit more sophisticated maybe? Dunno... your call
/// var timestamper = new CTextWriterPrepender( outFile )
/// {
///     StringToPrepend = " --> ",
///     PrependerFunction = () => DateTime.Now.ToString()
/// };
/// 
/// 
/// // Redirect Console.Out with the prepender
/// Console.SetOut( timestamper );
/// 
/// // -or-  with the splitter/prepender combo
/// Console.SetOut( new CTextWriterSplitter( Console.Out, timestamper ) );
///</code>
/// </remarks>
public class TextWriterPrepender : TextWriter
{
    private readonly TextWriter m_writer;

    private bool m_needPrepend = true;
    private char m_lastChar = default;
    private bool m_disposed = false;

    /// <summary>
    /// A static string that is prepended before the first character of every line, but
    /// AFTER the PrependerFunction's string if its specified.
    /// </summary>
    public string? StringToPrepend { get; set; }

    /// <summary>
    /// This function is called before the first character of every line is written. The
    /// string returned from this function will be placed BEFORE the
    /// <see cref="StringToPrepend"/> string.
    /// </summary>
    public Func<string>? PrependerFunction { get; set; }



    /// <summary>
    /// Construct wrapping an existing TextWriter
    /// </summary>
    /// <param name="_writer">The TextWriter to wrap with this prepender</param>
    public TextWriterPrepender( TextWriter _writer )
    {
        m_writer = _writer ?? throw new ArgumentNullException( string.Format( "Must specify a non-null writer that this class will wrap" ) );
    }

    /// <summary>
    /// Construct with a TextWriter and a static string
    /// </summary>
    /// <param name="_writer">The TextWriter to wrap with this prepender</param>
    /// <param name="_stringToPrepend">
    /// The string to be prepended to every line of text
    /// </param>
    public TextWriterPrepender( TextWriter _writer, string _stringToPrepend )
        : this( _writer )
    {
        StringToPrepend = _stringToPrepend;
    }

    /// <summary>
    /// Construct with a lambda function (or delegate) to be called before writing the first
    /// character of text on every line
    /// </summary>
    /// <param name="_writer">The TextWriter to wrap with this prepender</param>
    /// <param name="_prependerFunction">
    /// The function that generates the string to prepend
    /// </param>
    public TextWriterPrepender( TextWriter _writer, Func<string> _prependerFunction )
        : this( _writer )
    {
        PrependerFunction = _prependerFunction;
    }

    /// <summary>
    /// Make sure things like Files get flushed and closed. One of those rare instances when
    /// you need a finalizer.
    /// </summary>
    ~TextWriterPrepender()
    {
        Dispose( true );
    }

    /// <summary>
    /// The encoding of the TextWriter that this object is wrapping
    /// </summary>
    public override Encoding Encoding => m_writer.Encoding;


    /// <summary>
    /// Write a character of text. Includes the logic to detect "Beginning of Line" and act
    /// appropriately
    /// </summary>
    /// <param name="_char"></param>
    public override void Write( char _char )
    {
        PrependIfNeeded();

        CheckForEndOfLine( _char );

        m_writer.Write( _char );
    }

    /// <summary>
    /// Checks to see if a character will be the last character of a line... the last
    /// character of the <see cref="TextWriter.CoreNewLine"/> Only checks for up to 2
    /// newline characters (usually carriage-return line-feed)
    /// </summary>
    /// <param name="_char">The character that is going to be written next</param>
    private void CheckForEndOfLine( char _char )
    {
        var nlLen = CoreNewLine.Length;
        if (nlLen == 1)
        {
            if (_char == CoreNewLine[0])
                m_needPrepend = true;
        }
        else if (nlLen > 1)
        {
            if (_char == CoreNewLine[nlLen - 1] && m_lastChar == CoreNewLine[nlLen - 2])
                m_needPrepend = true;
        }
        m_lastChar = _char;
    }

    /// <summary>
    /// Checks to see if we need to prepend text and prepend the right text if needed.
    /// </summary>
    private void PrependIfNeeded()
    {
        if (m_needPrepend)
        {
            if (PrependerFunction != null)
                m_writer.Write( PrependerFunction() );
            if (StringToPrepend != null)
                m_writer.Write( StringToPrepend );

            m_needPrepend = false;
        }
    }

    /// <summary>
    /// Make sure that the wrapped object gets disposed too
    /// </summary>
    /// <param name="_disposing"></param>
    protected override void Dispose( bool _disposing )
    {
        if (!m_disposed)
        {
            m_disposed = true;
            try
            {
                base.Dispose( _disposing );
            }
            catch { };

            try
            {
                m_writer.Dispose();
            }
            catch { };
        }
    }
}
